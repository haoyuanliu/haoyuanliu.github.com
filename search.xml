<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gcc/g++编译过程]]></title>
    <url>%2F2017%2F06%2F11%2Fgcc-g-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[gcc/g++编译过程一共包括四个步骤，分别是预处理、编译、汇编和链接，以如下test.cpp源代码为例，详细介绍各个步骤的作用。1234567#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; "Hello, World!" &lt;&lt; endl; return 0;&#125; 预处理就是将所有的#include的文件和宏定义替换成其真正的内容，预处理之后得到的仍然是文本代码，但是文件的体积会大很多。gcc的预处理是使用预处理器cpp完成的。1g++ -E test.cpp -o test.i 或者使用cpp预处理命令1cpp test.cpp -o test.i 其中，上述命令中的-E是编译器在完成预处理后就结束，不再继续进行编译过程；-o指定输出文件名 编译编译是指将预处理之后的程序转换成特定的汇编代码的过程，是将程序从源文件转换成二进制可执行文件的第一部分操作。编译命令如下：1g++ -S test.i -o test.s 其中-S表示编译器在编译完成之后就停止，不进行后续过程。 汇编汇编将编译得到的汇编代码转换成机器码，生成二进制目标文件，gcc使用as命令完成汇编过程。1as test.s -o test.o 等价于1g++ -c test.s -o test.o 这一步会为每一个.cpp源文件生成一个.o文件。 链接链接过程将多个目标文件以及所需要的库文件(.so等)链接成最终的可执行文件，命令如下：12g++ test.o -o test./test 总结来说，C语言编译一共需要四个步骤：预处理-&gt;编译-&gt;汇编-&gt;链接四个步骤！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GCC/G++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Greedy]]></title>
    <url>%2F2017%2F02%2F28%2FLeetCode-Greedy%2F</url>
    <content type="text"><![CDATA[本篇文章的主要内容是LeetCode有关贪心算法的习题练习，主要包含如下题目： 44. Wildcard Matching45. Jump Game II55. Jump Game122. Best Time to Buy and Sell Stock II134. Gas Station135. Candy316. Remove Duplicate Letters321. Create Maximum Number330. Patching Array376. Wiggle Subsequence392. Is Subsequence402. Remove K Digits406. Queue Reconstruction by Height435. Non-overlapping Intervals452. Minimum Number of Arrows to Burst Balloons455. Assign Cookies502. IPO 44. Wildcard Matching解题思路使用动态规划的思路，dp[i][j]表示字符串s的前i个字符与字符串p的前j个字符是否匹配，然后：如果p[j] == &#39;*&#39;，则dp[i][j+1] = dp[i][j] || dp[i-1][j] (‘‘匹配与不匹配)；如果`p[j] != ‘‘, 则只有p[j] == s[i] || p[j] == ‘?’的时候，dp[i][j+1] = dp[i-1][j]`; 代码123456789101112131415161718192021222324252627282930313233class Solution&#123; public: bool isMatch(string s, string p) &#123; int m = s.size(); int n = p.size(); int cnt = count(p.begin(), p.end(), '*'); if(n - cnt &gt; m) return false; vector&lt;bool&gt; dp(n+1, false); dp[0] = 1; for(int i = 0; i &lt; n; ++i) if(p[i] == '*') dp[i+1] = dp[i]; for(int i = 1; i &lt;= m; ++i) &#123; vector&lt;bool&gt; cur(n+1, false); for(int j = 1; j &lt;= n; ++j) &#123; if(p[j-1] == '*') cur[j] = cur[j-1] || dp[j]; else &#123; if(p[j-1] == s[i-1] || p[j-1] == '?') cur[j] = dp[j-1]; &#125; &#125; dp = cur; &#125; return dp[n]; &#125;&#125;; 45. Jump Game II解题思路维持一个curJump变量，保存目前为止所能跳转到的最大下标，lastJump表示最近一次最大跳转到达的元素下标，遍历整个数组并更新curJump和lastJump变量，如果lastJump已经到达或者超过数组范围，返回跳转计数。 代码123456789101112131415161718192021222324class Solution&#123; public: int jump(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); int curJump = 0; int lastJump = 0; int count = 0; for(int i = 0; i &lt; len; ++i) &#123; if(lastJump &lt; i) &#123; count++; lastJump = curJump; &#125; if(lastJump &gt;= len-1) return count; if(curJump &gt;= i) curJump = max(curJump, i + nums[i]); &#125; return count; &#125;&#125;; 55. Jump Game解题思路I直接使用贪心的算法解决，每遍历一个节点，更新最大Jump的距离maxJump，如果maxJump为0则无法跳到最后节点。 代码12345678910111213141516class Solution&#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int maxJump = nums[0]; for(int i = 1; i &lt; len; ++i) &#123; if(maxJump == 0) return false; maxJump = max(--maxJump, nums[i]); &#125; return true; &#125;&#125;; 解题思路II对思路I的算法进行优化，维持一个cover变量，记录能够跳到的最大数组下标，每遍历一个节点，更新cover = max(cover, i + nums[i])，一旦cover &gt;= len - 1则肯定能够跳到最后一个节点，直接返回true； 代码1234567891011121314151617class Solution&#123; public: bool canJump(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); int cover = 0; for(int i = 0; i &lt; len; ++i) &#123; if(cover &gt;= len - 1) return true; if(cover &gt;= i) cover = max(cover, i + nums[i]); &#125; return false; &#125;&#125;; 122. Best Time to Buy and Sell Stock II解题思路股票的买入和抛售，原则就是最低价买入，然后最高价抛售，价格上升的区间就是获取利润的区间，直接遍历整个数组，将上升趋势的价格差额累加起来就得到最终的最大利润。 代码12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; for(int i = 1; i &lt; prices.size(); ++i) &#123; res += max(prices[i] - prices[i-1], 0); &#125; return res; &#125;&#125;; 134. Gas Station解题思路 如果从A点无法到达B点，那么在A、B两点之间任意一点都无法到达B点，也就是说，如果判断得到从A点无法到达B点，那么A、B两点之间的任何一点都不能作为起始点，因为都到达不了B点。（证明：因为B点无法到达，所以B点的cost &gt; gas; 假设A、B中间一点C，因为从A到B点无法到达，所以总体的cost &gt; gas, A点是可以到达Ｃ点的，所以AC段cost &lt; gas，那么CB段必定cost &gt; gas，所以C点无法到达B点） 对于全部路程，总体gas大于总体cost才有解，否则无解； 代码1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int total = 0; int tank = 0; int start = 0; for(int i = 0; i &lt; gas.size(); ++i) &#123; if((tank = tank + gas[i] - cost[i]) &lt; 0) &#123; start = i+1; total += tank; tank = 0; &#125; &#125; return (total + tank &gt;= 0) ? start : -1; &#125;&#125;; 135. Candy解题思路确保每个小孩至少一颗糖，初始化每个人一颗，同时观察发现，只有当存在等级差别的时候才需要增加糖的数量，向后向前遍历两遍数组，计算需要增加的糖果数量，最后加和给出结果。 代码12345678910111213141516171819202122232425class Solution&#123;public: int candy(vector&lt;int&gt;&amp; ratings) &#123; int res = 0; int len = ratings.size(); if(len &lt; 2) return len; vector&lt;int&gt; candies(len, 1); for(int i = 1; i &lt; len; ++i) &#123; if(ratings[i] &gt; ratings[i-1]) candies[i] = candies[i-1] + 1; &#125; for(int i = len-2; i &gt;= 0; --i) &#123; if(ratings[i] &gt; ratings[i+1]) candies[i] = max(candies[i+1]+1, candies[i]); &#125; for(int i = 0; i &lt; len; ++i) res += candies[i]; return res; &#125;&#125;; 316. Remove Duplicate Letters解题思路使用栈结构的性质，对于每一个字符，如果已经在栈中了，就跳过；如果没有在栈中，如果该字符小于栈顶的字符，并且栈顶字符在后面字符串中还有（计数值大于0），则将栈顶元素出栈，然后继续循环判断新的栈顶元素是否需要出栈，循环判断结束后最后将新字符入栈。 代码123456789101112131415161718192021222324252627class Solution&#123;public: string removeDuplicateLetters(string s) &#123; string res = "0"; int len = s.size(); int m[256] = &#123;0&#125;; int visited[256] = &#123;0&#125;; for(int i = 0; i &lt; len; ++i) m[s[i]]++; for(const auto c : s) &#123; m[c]--; if(visited[c]) continue; while(c &lt; res.back() &amp;&amp; m[res.back()]) &#123; visited[res.back()] = 0; res.pop_back(); &#125; res += c; visited[c] = 1; &#125; return res.substr(1); &#125;&#125;; 321. Create Maximum Number解题思路核心算法是遍历k1，nums1取k1个数字，nums2取k-k1个数字，都获得其最大值然后进行合并，最后比较大小返回最大的那一个。这道题学习了StefanPochmann大神的代码，真的厉害，各种c++的技巧用得太巧妙了。StefanPochmann大神对于函数重载以及引用等技巧的使用太赞了！ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution&#123;public: vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; int n1 = nums1.size(); int n2 = nums2.size(); vector&lt;int&gt; res; for(int i = max(0, k - n2); i &lt;= min(k, n1); ++i) &#123; res = max(res, maxNumber(maxNumber(nums1, i), maxNumber(nums2, k-i))); &#125; return res; &#125; vector&lt;int&gt; maxNumber(vector&lt;int&gt; nums, int k) &#123; int drop = nums.size() - k; vector&lt;int&gt; res; for(const auto n : nums) &#123; while(drop &amp;&amp; !res.empty() &amp;&amp; n &gt; res.back()) &#123; res.pop_back(); drop--; &#125; res.push_back(n); &#125; res.resize(k); return res; &#125; vector&lt;int&gt; maxNumber(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2) &#123; vector&lt;int&gt; res; while(nums1.size() + nums2.size()) &#123; vector&lt;int&gt; &amp;temp = nums1 &gt; nums2 ? nums1 : nums2; res.push_back(temp[0]); temp.erase(temp.begin()); &#125; return res; &#125;&#125;; 330. Patching Array解题思路miss表示[1,n]中我们无法得到的最小值，也就意味着我们可以得到小于miss的所有数字，取值区间为[1, miss)。如果nums数组中有元素num &lt; miss，之前我们可以得到范围[1, miss)的数值，现在统一加上num就可以得到[1, miss+num)范围的数值；如果数组中没有小于miss的值，则此时我们需要加入一个新的值来达到要求，这里最好的选择是miss，同时结果计数进行累加计算；StefanPochmann大神详细题解可以参考这个&lt;链接&gt;！ 代码123456789101112131415161718192021222324class Solution&#123;public: int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123; int len = nums.size(); int res = 0; int cur = 0; long miss = 1; while(miss &lt;= n) &#123; if(cur &lt; len &amp;&amp; nums[cur] &lt;= miss) &#123; miss += nums[cur++]; &#125; else &#123; miss &lt;&lt;= 1; res++; &#125; &#125; return res; &#125;&#125;; 376. Wiggle Subsequence解题思路使用贪心算法解决，遍历整个数组，使用pos表示已遍历数组中符合要求的连续数列长度，且最后的difference是正值，neg就表示最后difference是复制的连续数列长度。如此以来，如果nums[i] &gt; nums[i-1]，则difference是正值，此时pos = neg + 1，反之neg = pos + 1； 代码123456789101112131415161718class Solution&#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int pos = 1; int neg = 1; for(int i = 1; i &lt; len; ++i) &#123; if(nums[i] &gt; nums[i-1]) pos = neg + 1; else if(nums[i] &lt; nums[i-1]) neg = pos + 1; &#125; return min(len, max(neg, pos)); &#125;&#125;; 392. Is Subsequence解题思路这道题按照顺序去比较每一个字符是否相同即可； 代码1234567891011121314151617181920class Solution&#123;public: bool isSubsequence(string s, string t) &#123; int i = 0; int len = s.size(); if(len == 0) return true; for(const auto x : t) &#123; if(x == s[i]) &#123; if(++i == len) return true; &#125; &#125; return false; &#125;&#125;; 402. Remove K Digits解题思路利用string的栈结构特性，保证位于高位的数字达到最小即可，最后进行字符串的整理和特例处理。 代码123456789101112131415161718192021222324252627class Solution&#123;public: string removeKdigits(string num, int k) &#123; int len = num.size(); string res = ""; int drop = k; for(int i = 0; i &lt; len; ++i) &#123; while(drop &amp;&amp; res.size() &amp;&amp; num[i] &lt; res.back()) &#123; res.pop_back(); drop--; &#125; res += num[i]; &#125; while(drop &amp;&amp; res.size()) &#123; res.pop_back(); drop--; &#125; while(res[0] == '0') res.erase(res.begin()); return res.empty() ? "0" : res; &#125;&#125;; 406. Queue Reconstruction by Height解题思路I将people数组元素进行排序，然后按照身高从矮到高的顺序置入结果队列中，通过遍历结果队列更新计数值来决定应该置入的位置。 代码1234567891011121314151617181920212223242526class Solution&#123;public: vector&lt;pair&lt;int, int&gt;&gt; reconstructQueue(vector&lt;pair&lt;int, int&gt;&gt;&amp; people) &#123; int len = people.size(); vector&lt;pair&lt;int, int&gt;&gt; res(len, &#123;-1, -1&#125;); sort(people.begin(), people.end()); int count, i; for(const auto p : people) &#123; count = 0; i = 0; for(i = 0; i &lt; len; ++i) &#123; if(res[i].first == -1 || res[i].first &gt;= p.first) count++; if(count &gt; p.second) break; &#125; res[i].first = p.first; res[i].second = p.second; &#125; return res; &#125;&#125;; 解题思路II首先还是对people数组排序，身高高的排在前面，身高一样的，前面人少的排在前面。简单来说就是按照身高从高到低进行排序，然后高个子先置入结果数组中。这样每一个people数组元素置入的时候，由于比他高的全都已经在结果数组中了，所以此时他的位置也就直接确定了，使用insert执行置入操作即可； 代码1234567891011121314151617class Solution&#123;public: vector&lt;pair&lt;int, int&gt;&gt; reconstructQueue(vector&lt;pair&lt;int, int&gt;&gt;&amp; people) &#123; auto comp = [](const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) &#123; return a.first &gt; b.first || (a.first == b.first &amp;&amp; a.second &lt; b.second); &#125;; vector&lt;pair&lt;int, int&gt;&gt; res; sort(people.begin(), people.end(), comp); for(auto p : people) res.insert(res.begin()+p.second, p); return res; &#125;&#125;; 435. Non-overlapping Intervals解题思路首先对数组进行排序，按照start从小到大进行排序，如果start相同，按照包含区间从小到大进行排序。遍历整个数组，如果当前interval的start小于前一个interval的end，即cur.start &lt; pre.end，则此时必定发生overlapping，结果计数加一，如果cur.end &lt; pre.end时，cur包含在pre中，此时应该舍弃pre并更新cur为新的pre。反之，如果一开始就cur.start &gt;= pre.end的话，区间没有overlapping，更新cur为新的pre，继续遍历即可。 代码1234567891011121314151617181920212223242526272829class Solution&#123;public: int eraseOverlapIntervals(vector&lt;Interval&gt;&amp; intervals) &#123; int res = 0; int len = intervals.size(); if(len &lt; 2) return res; auto cmp = [](const Interval &amp;a, const Interval &amp;b) &#123; return a.start &lt; b.start || (a.start == b.start &amp;&amp; a.end - a.start &lt; b.end - b.start); &#125;; sort(intervals.begin(), intervals.end(), cmp); int pre = 0; for(int i = 1; i &lt; len; ++i) &#123; if(intervals[i].start &lt; intervals[pre].end) &#123; res++; if(intervals[i].end &lt; intervals[pre].end) pre = i; &#125; else pre = i; &#125; return res; &#125;&#125;; 452. Minimum Number of Arrows to Burst Balloons解题思路首先对points数组进行排序，维持left和right代表公共区间的左右边界，遍历整个数组，如果气球范围出了公共区间，则此时应该射一箭，反之，则应该继续更新公共区间，如此遍历全部气球数组。注意这里公共区间边界如果left==right也是可以的；遍历过程中最后一箭是没有射出去的，所以res初始化为1。 代码123456789101112131415161718192021222324252627282930313233class Solution&#123;public: int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; if(points.size() == 0) return 0; auto cmp = [](const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) &#123; return a.first &lt; b.first; &#125;; sort(points.begin(), points.end(), cmp); int res = 1; int left = points[0].first; int right = points[0].second; for(int i = 1; i &lt; points.size(); ++i) &#123; if(points[i].first &gt; right) &#123; res++; left = points[i].first; right = points[i].second; &#125; else &#123; left = max(left, points[i].first); right = min(right, points[i].second); &#125; &#125; return res; &#125;&#125;; 455. Assign Cookies解题思路对两个数组进行排序，首先用最大的饼干来满足要求最高的孩子，如果无法满足，则换下一个要求小一点的孩子，如果能够满足，则执行--操作继续进行匹配遍历。 代码12345678910111213141516171819class Solution&#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; int res = 0; sort(g.begin(), g.end()); sort(s.begin(), s.end()); int x = g.size() - 1; int y = s.size() - 1; while(x &gt;= 0 &amp;&amp; y &gt;= 0) &#123; if(g[x] &gt; s[y]) x--; else if(g[x--] &lt;= s[y--]) res++; &#125; return res; &#125;&#125;; 502. IPO解题思路使用一个大顶堆结构保存现阶段可以进行的项目，使用vector保存那些不能进行的项目，每次都只执行堆顶的利益最大的项目，执行完毕之后，将已执行的项目pop删除，遍历vector更新可执行的项目，置入到堆中并从vector中删除。 代码12345678910111213141516171819202122232425262728293031323334353637class Solution&#123;public: int findMaximizedCapital(int k, int W, vector&lt;int&gt;&amp; Profits, vector&lt;int&gt;&amp; Capital) &#123; int res = W; priority_queue&lt;int&gt; doable; vector&lt;pair&lt;int, int&gt;&gt; notdoable; for(int i = 0; i &lt; Profits.size(); ++i) &#123; if(Profits[i]) &#123; if(Capital[i] &lt;= W) doable.push(Profits[i]); else notdoable.push_back(make_pair(Profits[i], Capital[i])); &#125; &#125; while(k-- &amp;&amp; doable.size()) &#123; res += doable.top(); doable.pop(); for(auto it = notdoable.begin(); it != notdoable.end(); ) &#123; if(it-&gt;second &lt;= res) &#123; doable.push(it-&gt;first); it = notdoable.erase(it); &#125; else it++; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Trapping Rain Water]]></title>
    <url>%2F2017%2F02%2F24%2FLeetCode-Trapping-Rain-Water%2F</url>
    <content type="text"><![CDATA[本文包含如下两个题目：42. Trapping Rain Water407. Trapping Rain Water II 42. Trapping Rain Water解题思路从两头开始向中间搜索，维持一个secondHeight的变量，记录已遍历的节点中第二高的点。遍历到的节点高度小于secondHeight的话，可以装水，如果大于secondHeight的话，则此时需要更新secondHeight。 代码1234567891011121314151617181920212223242526272829303132class Solution&#123; public: int trap(vector&lt;int&gt; &amp;height) &#123; int res = 0; int len = height.size(); int l = 0; int r = len-1; int secondHeight = 0; while(l &lt; r) &#123; if(height[l] &lt; height[r]) &#123; if(secondHeight &lt; height[l]) secondHeight = height[l]; else res += secondHeight - height[l]; l++; &#125; else &#123; if(secondHeight &lt; height[r]) secondHeight = height[r]; else res += secondHeight - height[r]; r--; &#125; &#125; return res; &#125;&#125;; 407. Trapping Rain Water II解题思路首先将边缘的高度全部统计，使用堆排序进行排序，建立最初的水池边框。然后取边框中高度最低的作为参照，取其上下左右四个相邻块的高度，如果高度小于参照高度，则可以储水，如果大于等于参照高度，则无法储水，就应该划归到边框中，置入堆中进行排序，然后循环如上操作。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution&#123;public: int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap) &#123; int res = 0; if(heightMap.size() &lt;= 2) return res; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; que; int row = heightMap.size(); int col = heightMap[0].size(); vector&lt;vector&lt;int&gt;&gt; visited(row, vector&lt;int&gt;(col, 0)); for(int i = 0; i &lt; row; ++i) &#123; for(int j = 0; j &lt; col; ++j) &#123; if(!(i==0 || i==row-1 || j==0 || j==col-1)) continue; que.push(make_pair(heightMap[i][j], i*col+j)); visited[i][j] = 1; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; dir = &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;; int minHeight = 1&lt;&lt;31; while(!que.empty()) &#123; int height = que.top().first; int x = que.top().second / col; int y = que.top().second % col; que.pop(); minHeight = max(minHeight, height); for(const auto d : dir) &#123; int x2 = x + d[0]; int y2 = y + d[1]; if(x2 &lt; 0 || x2 &gt;= row || y2 &lt; 0 || y2 &gt;= col || visited[x2][y2]) continue; if(heightMap[x2][y2] &lt; minHeight) res += minHeight - heightMap[x2][y2]; que.push(make_pair(heightMap[x2][y2], x2 * col + y2)); visited[x2][y2] = 1; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Heap]]></title>
    <url>%2F2017%2F02%2F08%2FLeetCode-Heap%2F</url>
    <content type="text"><![CDATA[本文包含如下题目： 264. Ugly Number II295. Find Median from Data Stream313. Super Ugly Number347. Top K Frequent Elements355. Design Twitter373. Find K Pairs with Smallest Sums378. Kth Smallest Element in a Sorted Matrix451. Sort Characters By Frequency 264. Ugly Number II解题思路使用动态规划的思想，已知res[0] = 1，此时可以得到res[1] = min(res[0]*2, res[0]*3, res[0]*5)，然后可以求得res[2] = min(res[1]*2, res[0]*3, res[0]*5。 代码123456789101112131415161718class Solution&#123;public: int nthUglyNumber(int n) &#123; if(n &lt; 0) return 0; vector&lt;int&gt; res(n, 1); int t2 = 0, t3 = 0, t5 = 0; for(int i = 1; i &lt; n; ++i) &#123; res[i] = min(res[t2]*2, min(res[t3]*3, res[t5]*5)); if(res[i] == res[t2]*2) t2++; if(res[i] == res[t3]*3) t3++; if(res[i] == res[t5]*5) t5++; &#125; return res[n-1]; &#125;&#125;; 295. Find Median from Data Stream解题思路利用STL库函数中的priority_queue，维持一个大顶堆和一个小顶堆（利用负数实现），然后动态更新保持两个堆的元素数量的平衡，最后返回中位数。 代码1234567891011121314151617181920212223242526272829class MedianFinder&#123; priority_queue&lt;int&gt; small, large;public: void addNum(int num) &#123; if(!large.empty() &amp;&amp; -large.top() &lt; num) large.push(-num); else small.push(num); if(small.size() - large.size() == 2) &#123; large.push(-small.top()); small.pop(); &#125; else if(large.size() - small.size() == 2) &#123; small.push(-large.top()); large.pop(); &#125; &#125; double findMedian() &#123; if(small.size() &gt; large.size()) return small.top(); else if(small.size() &lt; large.size()) return -large.top(); else return (small.top() - large.top()) / 2.0; &#125;&#125;; 313. Super Ugly Number解题思路使用动态规划的思路，使用一个res(vector)保存顺序排列的丑数，然后使用一个idx(vector)保存每个primes中元素所对应的乘法因子，然后每次取乘法结果的最小的值作为新的丑数，同时遍历idx进行去重操作。 代码123456789101112131415161718192021222324class Solution&#123;public: int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; vector&lt;int&gt; res(n, 1); vector&lt;int&gt; idx(primes.size(), 0); if(n == 1) return res[0]; for(int i = 1; i &lt; n; ++i) &#123; res[i] = 0x7fffffff; for(int j = 0; j &lt; primes.size(); ++j) &#123; res[i] = min(res[i], primes[j] * res[idx[j]]); &#125; for(int j = 0; j &lt; primes.size(); ++j) &#123; while(res[idx[j]] * primes[j] &lt;= res[i]) idx[j]++; &#125; &#125; return res[n-1]; &#125;&#125;; 347. Top K Frequent Elements解题思路使用unordered_map对输入的数字进行频率统计，然后使用priority_queue堆结构对之前得到的频率进行统计，最后将要求结果保存返回即可。 代码123456789101112131415161718192021222324class Solution&#123;public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; unordered_map&lt;int, int&gt; m; for(int i = 0; i &lt; nums.size(); ++i) &#123; m[nums[i]]++; &#125; priority_queue&lt;pair&lt;int, int&gt;&gt; que; for(auto it = m.begin(); it != m.end(); ++it) &#123; que.push(make_pair(it-&gt;second, it-&gt;first)); &#125; for(int i = 0; i &lt; k; ++i) &#123; res.push_back(que.top().second); que.pop(); &#125; return res; &#125;&#125;; 355. Design Twitter解题思路建立一个tweet结构，保存tweet的userId,tweetId和tweetTime(发布时间)使用hashMap建立user和tweet之间的联系，使用hashMap和set结构处理user之间的follow关系，收集tweet完成之后，使用priority_queue进行堆排序，获取最近的10个tweet。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Twitter&#123; struct tweet &#123; int userId; int tweetId; int tweetTime; tweet(int userId_, int tweetId_) : userId(userId_), tweetId(tweetId_) &#123;&#125; &#125;; int userId; int time = 0; unordered_map&lt;int, vector&lt;tweet&gt;&gt; userToTweet; unordered_map&lt;int, unordered_set&lt;int&gt;&gt; userToFollowee;public: /** Initialize your data structure here. */ Twitter() &#123; userId = 0; time++; &#125; /** Compose a new tweet. */ void postTweet(int userId, int tweetId) &#123; tweet temp = tweet(userId, tweetId); temp.tweetTime = time++; userToTweet[userId].push_back(temp); &#125; /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector&lt;int&gt; getNewsFeed(int userId) &#123; vector&lt;int&gt; res; priority_queue&lt;pair&lt;int, int&gt;&gt; que; int count = 0; for(auto const tweet : userToTweet[userId]) &#123; que.push(make_pair(tweet.tweetTime, tweet.tweetId)); &#125; for(auto const followee : userToFollowee[userId]) &#123; for(auto const tweet : userToTweet[followee]) &#123; que.push(make_pair(tweet.tweetTime, tweet.tweetId)); &#125; &#125; while(!que.empty()) &#123; res.push_back(que.top().second); que.pop(); if(++count &gt;= 10) break; &#125; return res; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow(int followerId, int followeeId) &#123; if(followerId != followeeId) userToFollowee[followerId].insert(followeeId); &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow(int followerId, int followeeId) &#123; userToFollowee[followerId].erase(followeeId); &#125;&#125;; 373. Find K Pairs with Smallest Sums解题思路遍历所有的可能情况，然后将其组合置入一个堆结构中，最后按照要求弹出返回结果。 代码12345678910111213141516171819202122class Solution&#123;public: vector&lt;pair&lt;int, int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; vector&lt;pair&lt;int, int&gt;&gt; res; priority_queue&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; que; for(int i = 0; i &lt; nums1.size(); ++i) &#123; for(int j = 0; j &lt; nums2.size(); ++j) &#123; que.push(make_pair(-nums1[i]-nums2[j], make_pair(nums1[i], nums2[j]))); &#125; &#125; for(int i = 0; i &lt; k &amp;&amp; !que.empty(); ++i) &#123; res.push_back(make_pair(que.top().second.first, que.top().second.second)); que.pop(); &#125; return res; &#125;&#125;; 378. Kth Smallest Element in a Sorted Matrix解题思路I这道题我直接用堆排序解决了。。。 代码12345678910111213141516171819202122class Solution&#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; int res; priority_queue&lt;int&gt; que; for(int i = 0; i &lt; matrix.size(); i++) &#123; for(int j = 0; j &lt; matrix.size(); ++j) &#123; que.push(-matrix[i][j]); &#125; &#125; for(int i = 0; i &lt; k &amp;&amp; !que.empty(); ++i) &#123; res = -que.top(); que.pop(); &#125; return res; &#125;&#125;; 解题思路II充分利用矩阵每行每列有序的性质，维护一个最小堆，从左上角开始置入堆中，如果是首行元素，则将元素右边的元素置入堆中，这样能够避免重复，同是确保所有的可能结果都在堆中。 代码123456789101112131415161718192021222324252627282930class Solution&#123; struct Node &#123; int idx; int idy; int val; Node(int x, int y, int v) : idx(x), idy(y), val(v) &#123;&#125; bool operator &lt; (const Node &amp;ref) const &#123; return val &gt; ref.val; &#125; &#125;;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; int res; int len = matrix.size(); priority_queue&lt;Node&gt; que; int left = 0; int right = 0; que.push(Node(left, right, matrix[left][right])); for(int i = 1; i &lt; k; ++i) &#123; left = que.top().idx; right = que.top().idy; que.pop(); if(left == 0 &amp;&amp; right+1 &lt; len) que.push(Node(left, right+1, matrix[left][right+1])); if(left+1 &lt; len) que.push(Node(left+1, right, matrix[left+1][right])); &#125; return que.top().val; &#125;&#125;; 451. Sort Characters By Frequency解题思路使用unordered_map和priority_que进行hash匹配和堆排序，最后输出结果即可； 代码123456789101112131415161718192021222324class Solution&#123;public: string frequencySort(string s) &#123; string res; if(s == "") return res; unordered_map&lt;char, int&gt; m; priority_queue&lt;pair&lt;int, char&gt;&gt; que; for(int i = 0; i &lt; s.size(); ++i) m[s[i]]++; for(auto it = m.begin(); it != m.end(); ++it) que.push(make_pair((*it).second, (*it).first)); while(!que.empty()) &#123; for(int i = 0; i &lt; que.top().first; ++i) &#123; res += que.top().second; &#125; que.pop(); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地址查询函数gethostbyname()和getaddrinfo()]]></title>
    <url>%2F2017%2F01%2F16%2F%E5%9C%B0%E5%9D%80%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0gethostbyname-%E5%92%8Cgetaddrinfo%2F</url>
    <content type="text"><![CDATA[地址查询函数的功能也就是通过主机名或者域名返回详细的主机信息，其中我们最常用的功能就是通过主机名获得主机的IP地址等信息。gethostbyname()和其可重入版本gethostbyname_r()是我们之前较多使用的函数，由于SUSv4已经删除了它们并认为它们已经是过时的了，现在我们更推荐使用getaddrinfo()来完成相应的功能。 gethostbyname()函数函数原型1struct hostent *gethostbyname(const char *name); 功能：用域名或主机名获取IP地址头文件：&lt;netdb.h&gt;, &lt;sys/socket.h&gt; hostent结构体hostent的结构如下所示：123456789struct hostent&#123; char *h_name;//主机的规范名 char **h_aliases;//主机的别名 int h_addrtype;//主机ip地址的类型 int h_length;//主机ip地址的长度 char **h_addr_list;//主机的ip地址 #define h_addr h_addr_list[0];&#125;; 代码实例代码12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;netdb.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char *argv[])&#123; if(argc != 2) &#123; printf("ERROR: usage %s\n", argv[0]); return 1; &#125; char *ptr, **pptr; char buf[1024]; struct hostent *hent; if((hent = gethostbyname(argv[1])) == NULL) &#123; printf("ERROR: gethostbyname error for hostname: %s\n", argv[1]); return 0; &#125; printf("Official hostname: %s\n", hent-&gt;h_name); for(pptr = hent-&gt;h_aliases; *pptr != NULL; pptr++) printf("Alias hostname: %s\n", *pptr); printf("Host Address Type: %d(AF_INET: %d)\n", hent-&gt;h_addrtype, (int)AF_INET); for(pptr = hent-&gt;h_addr_list; *pptr != NULL; pptr++) &#123; printf("IP Address: %s\n", inet_ntop(hent-&gt;h_addrtype, *pptr, buf, sizeof buf)); &#125; return 0;&#125; 执行结果：1234567./a.out www.baidu.comOfficial hostname: www.a.shifen.comAlias hostname: www.baidu.comHost Address Type: 2(AF_INET: 2)IP Address: 61.135.169.125IP Address: 61.135.169.121 gethostbyname_r()函数gethostbyname_r()函数是gethostbyname()函数的可重入版本，两个函数的功能是一样的。 gethostbyname_r()函数原型123int gethostbyname_r(const char *name, struct hostent *ret, char *buf, size_t buflen, struct hostent **result, int *h_errnop); 功能：用域名或主机名获取IP地址头文件：&lt;netdb.h&gt;, &lt;sys/socket.h&gt; 代码实例代码12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;netdb.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char *argv[])&#123; if(argc != 2) &#123; printf("ERROR: usage %s\n", argv[0]); return 0; &#125; char *ptr, **pptr; struct hostent hent, *hptr; char buf[1024]; int ret; if(gethostbyname_r(argv[1], &amp;hent, buf, sizeof(buf), &amp;hptr, &amp;ret)) &#123; printf("ERROR: gethostbyname_r(%s) ret: %d\n", argv[1], ret); return 0; &#125; printf("Get host by name(%s) success!\n", argv[1]); printf("Official hostname: %s\n", hptr-&gt;h_name); for(pptr = hptr-&gt;h_aliases; *pptr != NULL; pptr++) printf("Alias hostname: %s\n", *pptr); printf("Host Address Type: %d(AF_INET: %d)\n", hptr-&gt;h_addrtype, (int)AF_INET); for(pptr = hptr-&gt;h_addr_list; *pptr != NULL; pptr++) printf("IP Address: %s\n", inet_ntop(hptr-&gt;h_addrtype, *pptr, buf, sizeof buf)); return 0;&#125; 执行结果12345678./a.out www.baidu.comGet host by name(www.baidu.com) success!Official hostname: www.a.shifen.comAlias hostname: www.baidu.comHost Address Type: 2(AF_INET: 2)IP Address: 61.135.169.125IP Address: 61.135.169.121 getaddrinfo()函数getaddrinfo()函数是现在用来替代gethostbyname()功能的函数，他具有更加强大的功能。 getaddrinfo()函数原型12345int getaddrinfo(const char *restrict host, const char *restrict service, const struct addrinfo *restrict hint, struct addrinfo **restrict res); 返回值：若成功，返回0；若出错，返回非0错误码 功能：用主机名或服务名获取IP地址头文件：&lt;netdb.h&gt;, &lt;sys/socket.h&gt; 代码实例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;void print_family(struct addrinfo *aip)&#123; printf("Family:"); switch (aip-&gt;ai_family) &#123; case AF_INET: printf("inet"); break; case AF_INET6: printf("inet6"); break; case AF_UNIX: printf("unix"); break; case AF_UNSPEC: printf("unspecified"); break; default: printf("unknown"); &#125;&#125;void print_type(struct addrinfo *aip)&#123; printf(" Type:"); switch (aip-&gt;ai_socktype) &#123; case SOCK_STREAM: printf("stream"); break; case SOCK_DGRAM: printf("datagram"); break; case SOCK_SEQPACKET: printf("seqpacket"); break; case SOCK_RAW: printf("raw"); break; default: printf("unknown (%d)", aip-&gt;ai_socktype); &#125;&#125;void print_protocol(struct addrinfo *aip)&#123; printf(" Protocol:"); switch (aip-&gt;ai_protocol) &#123; case 0: printf("default"); break; case IPPROTO_TCP: printf("TCP"); break; case IPPROTO_UDP: printf("UDP"); break; case IPPROTO_RAW: printf("raw"); break; default: printf("unknown (%d)", aip-&gt;ai_protocol); &#125;&#125;void print_flags(struct addrinfo *aip)&#123; printf(" Flags:"); if (aip-&gt;ai_flags == 0) &#123; printf(" 0"); &#125; else &#123; if (aip-&gt;ai_flags &amp; AI_PASSIVE) printf(" passive"); if (aip-&gt;ai_flags &amp; AI_CANONNAME) printf(" canon"); if (aip-&gt;ai_flags &amp; AI_NUMERICHOST) printf(" numhost"); if (aip-&gt;ai_flags &amp; AI_NUMERICSERV) printf(" numserv"); if (aip-&gt;ai_flags &amp; AI_V4MAPPED) printf(" v4mapped"); if (aip-&gt;ai_flags &amp; AI_ALL) printf(" all"); &#125;&#125;int main(int argc, char *argv[])&#123; if(argc != 2) &#123; printf("ERROR: usage %s\n", argv[0]); return 0; &#125; struct addrinfo *ai, *aip; struct addrinfo hint; struct sockaddr_in *sinp; const char *addr; int err; char buf[1024]; hint.ai_flags = AI_CANONNAME; hint.ai_family = 0; hint.ai_socktype = 0; hint.ai_protocol = 0; hint.ai_addrlen = 0; hint.ai_canonname = NULL; hint.ai_addr = NULL; hint.ai_next = NULL; if((err = getaddrinfo(argv[1], NULL, &amp;hint, &amp;ai)) != 0) printf("ERROR: getaddrinfo error: %s\n", gai_strerror(err)); for(aip = ai; aip != NULL; aip = aip-&gt;ai_next) &#123; print_family(aip); print_type(aip); print_protocol(aip); print_flags(aip); printf("\n"); printf("Canonical Name: %s\n", aip-&gt;ai_canonname); if(aip-&gt;ai_family == AF_INET) &#123; sinp = (struct sockaddr_in *)aip-&gt;ai_addr; addr = inet_ntop(AF_INET, &amp;sinp-&gt;sin_addr, buf, sizeof buf); printf("IP Address: %s ", addr); printf("Port: %d\n", ntohs(sinp-&gt;sin_port)); &#125; printf("\n"); &#125; return 0;&#125; 执行结果：1234567891011121314151617181920212223242526./a.out www.baidu.comFamily:inet Type:stream Protocol:TCP Flags: canonCanonical Name: www.a.shifen.comIP Address: 61.135.169.125 Port: 0Family:inet Type:datagram Protocol:UDP Flags: canonCanonical Name: (null)IP Address: 61.135.169.125 Port: 0Family:inet Type:raw Protocol:default Flags: canonCanonical Name: (null)IP Address: 61.135.169.125 Port: 0Family:inet Type:stream Protocol:TCP Flags: canonCanonical Name: (null)IP Address: 61.135.169.121 Port: 0Family:inet Type:datagram Protocol:UDP Flags: canonCanonical Name: (null)IP Address: 61.135.169.121 Port: 0Family:inet Type:raw Protocol:default Flags: canonCanonical Name: (null)IP Address: 61.135.169.121 Port: 0]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>UNIX/Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地址转换函数inet_addr(), inet_aton(), inet_ntoa()和inet_ntop(), inet_pton()]]></title>
    <url>%2F2017%2F01%2F15%2F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0inet-addr-inet-aton-inet-ntoa-%E5%92%8Cinet-ntop-inet-pton%2F</url>
    <content type="text"><![CDATA[对于地址转换函数，BSD网络软件包含inet_addr(), inet_aton()和inet_ntoa()三个函数用于二进制地址格式与点分十进制之间的相互转换，但是仅仅适用于IPv4，两个新函数inet_ntop()和inet_pton()具有相似的功能，并且同时支持IPv4和IPv6。 inet_addr(), inet_aton()和inet_ntoa()函数inet_addr()函数功能：inet_addr()函数用于将点分十进制IP地址转换成网络字节序IP地址;原型：in_addr_t inet_addr(const char *cp);返回值：如果正确执行将返回一个无符号长整数型数。如果传入的字符串不是一个合法的IP地址，将返回INADDR_NONE;头文件：arpa/inet.h (Linux) inet_aton()函数功能：inet_aton()函数用于将点分十进制IP地址转换成网络字节序IP地址;原型：int inet_aton(const char *string, struct in_addr *addr);返回值：如果这个函数成功，函数的返回值非零，如果输入地址不正确则会返回零;头文件：sys/socket.h (Linux) inet_ntoa()函数功能inet_ntoa()函数用于网络字节序IP转化点分十进制IP;原型：char *inet_ntoa (struct in_addr);返回值：若无错误发生，inet_ntoa()返回一个字符指针。否则的话，返回NULL。其中的数据应在下一个WINDOWS套接口调用前复制出来;头文件：arpa/inet.h (Linux) 应用实例代码123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123; int i; char lo[] = "127.0.0.1"; struct in_addr netAddr; netAddr.s_addr = inet_addr(lo); printf("NetIP: 0x%x\n", netAddr.s_addr); char *strAddr = inet_ntoa(netAddr); printf("StrIP: %s\n", strAddr); int ret = inet_aton(strAddr, &amp;netAddr); printf("NetIP: 0x%x\n", netAddr.s_addr); return 0;&#125; 输出结果：123NetIP: 0x100007f(网络序)StrIP: 127.0.0.1NetIP: 0x100007f(网络序) inet_ntop()和inet_pton()函数inet_ntop()函数功能：inet_ntop()函数用于将网络字节序的二进制地址转换成文本字符串;原型：const char *inet_pton(int domain, const void *restrict addr, char *restrict str, socklen_t size);返回值：若成功，返回地址字符串指针；若出错，返回NULL;头文件：arpa/inet.h (Linux) inet_pton()函数功能：inet_pton()函数用于将文本字符串格式转换成网络字节序二进制地址;原型：int inet_pton(int domain, const char *restrict str, void *restrict addr);返回值：若成功，返回1；若格式无效，返回0；若出错，返回-1;头文件：arpa/inet.h (Linux) 应用实例代码1234567891011121314#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;int main()&#123; struct in_addr addr; if(inet_pton(AF_INET, "127.0.0.1", &amp;addr.s_addr) == 1) printf("NetIP: %x\n", addr.s_addr); char str[20]; if(inet_ntop(AF_INET, &amp;addr.s_addr, str, sizeof str)) printf("StrIP: %s\n", str); return 0;&#125; 输出结果：12NetIP: 100007fStrIP: 127.0.0.1]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>UNIX/Linux</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Tree II]]></title>
    <url>%2F2017%2F01%2F12%2FLeetCode-Tree-II%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：114. Flatten Binary Tree to Linked List116. Populating Next Right Pointers in Each Node117. Populating Next Right Pointers in Each Node II124. Binary Tree Maximum Path Sum129. Sum Root to Leaf Numbers144. Binary Tree Preorder Traversal145. Binary Tree Postorder Traversal173. Binary Search Tree Iterator199. Binary Tree Right Side View222. Count Complete Tree Nodes226. Invert Binary Tree230. Kth Smallest Element in a BST235. Lowest Common Ancestor of a Binary Search Tree236. Lowest Common Ancestor of a Binary Tree257. Binary Tree Paths297. Serialize and Deserialize Binary Tree337. House Robber III404. Sum of Left Leaves449. Serialize and Deserialize BST450. Delete Node in a BST 114. Flatten Binary Tree to Linked List解题思路 I 使用一个栈结构存储各个节点，通过出栈入栈操作重新搭建树结构； 注意这里要先将右子节点入栈，保证先访问的是左子节点； 代码1234567891011121314151617181920212223class Solution &#123;public: void flatten(TreeNode* root) &#123; if(root == NULL) return; stack&lt;TreeNode*&gt; st; TreeNode* p = root; if(p-&gt;right) st.push(p-&gt;right); if(p-&gt;left) st.push(p-&gt;left); while(!st.empty()) &#123; p-&gt;left = NULL; p-&gt;right = st.top(); p = p-&gt;right; TreeNode* temp = st.top(); st.pop(); if(temp-&gt;right) st.push(temp-&gt;right); if(temp-&gt;left) st.push(temp-&gt;left); &#125; &#125;&#125;; 解题思路 II 使用递归的方法，先对右子树进行转换操作，然后左子树，最后根节点，使用一个pre参数保存每次转换之后的根节点，不断进行递归即可； 代码12345678910111213141516class Solution &#123;private: TreeNode* pre = NULL;public: void flatten(TreeNode* root) &#123; if(root == NULL) return; flatten(root-&gt;right); flatten(root-&gt;left); root-&gt;right = pre; root-&gt;left = NULL; pre = root; &#125;&#125;; 解题思路 III 将根节点右子树置于左子树叶子节点的右子树位置； 将左子树置于根节点的右子树位置，根节点左子树置为NULL； 不断循环上述操作； 代码123456789101112131415161718192021class Solution &#123;public: void flatten(TreeNode* root) &#123; while(root) &#123; if(root-&gt;left &amp;&amp; root-&gt;right) &#123; TreeNode* l = root-&gt;left; while(l-&gt;right) l = l-&gt;right; l-&gt;right = root-&gt;right; &#125; if(root-&gt;left) root-&gt;right = root-&gt;left; root-&gt;left = NULL; root = root-&gt;right; &#125; &#125;&#125;; 116. Populating Next Right Pointers in Each Node解题思路 I 使用一个queue进行BFS，然后依次进行连接构建； 代码1234567891011121314151617181920212223242526272829class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root == NULL) return; queue&lt;TreeLinkNode*&gt; que; que.push(root); while(!que.empty()) &#123; TreeLinkNode* p = que.front(); int len = que.size(); for(int i = 0; i &lt; len; ++i) &#123; if(que.front()-&gt;left) que.push(que.front()-&gt;left); if(que.front()-&gt;right) que.push(que.front()-&gt;right); que.pop(); if(i &lt; len-1) &#123; p-&gt;next = que.front(); p = p-&gt;next; &#125; &#125; p-&gt;next = NULL; &#125; &#125;&#125;; 解题思路 II 遍历每一层进行连接即可； 代码12345678910111213141516171819202122class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root == NULL) return; TreeLinkNode* pre = root; TreeLinkNode* cur = NULL; while(pre-&gt;left) &#123; cur = pre; while(cur) &#123; cur-&gt;left-&gt;next = cur-&gt;right; if(cur-&gt;next) cur-&gt;right-&gt;next = cur-&gt;next-&gt;left; cur = cur-&gt;next; &#125; pre = pre-&gt;left; &#125; &#125;&#125;; 117. Populating Next Right Pointers in Each Node II解题思路 I 如116题，使用queue可以AC； 代码1234567891011121314151617181920212223242526272829class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root == NULL) return; queue&lt;TreeLinkNode*&gt; que; que.push(root); while(!que.empty()) &#123; TreeLinkNode* p = que.front(); int len = que.size(); for(int i = 0; i &lt; len; ++i) &#123; if(que.front()-&gt;left) que.push(que.front()-&gt;left); if(que.front()-&gt;right) que.push(que.front()-&gt;right); que.pop(); if(i &lt; len-1) &#123; p-&gt;next = que.front(); p = p-&gt;next; &#125; &#125; p-&gt;next = NULL; &#125; &#125;&#125;; 解题思路 II 使用指针的方法，遍历每一层进行树结构的构建； 使用一个指针head保存每一层头节点，使用指针pre保存上一个连接的节点，方便进行连接； 仍然使用指针cur保存上层节点，实现遍历； 代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if(root == NULL) return; TreeLinkNode* head = NULL; TreeLinkNode* pre = NULL; TreeLinkNode* cur = root; while(cur) &#123; while(cur) &#123; if(cur-&gt;left) &#123; if(!head) head = cur-&gt;left; else pre-&gt;next = cur-&gt;left; pre = cur-&gt;left; &#125; if(cur-&gt;right) &#123; if(!head) head = cur-&gt;right; else pre-&gt;next = cur-&gt;right; pre = cur-&gt;right; &#125; cur = cur-&gt;next; &#125; cur = head; head = pre = NULL; &#125; &#125;&#125;; 124. Binary Tree Maximum Path Sum解题思路 首先要维持一个最大值res，将其初始值设置为最小值；使用辅助递归函数遍历所有的节点，返回以该节点为根节点的最大路径和，同时更新res的值； 代码1234567891011121314151617181920class Solution &#123;public: int maxPathSum(TreeNode* root) &#123; int res = (1&lt;&lt;31); if(root == NULL) return 0; getMax(root, res); return res; &#125; int getMax(TreeNode* root, int &amp;res) &#123; if(root == NULL) return 0; int left = max(0, getMax(root-&gt;left, res)); int right = max(0, getMax(root-&gt;right, res)); res = max(res, left + right + root-&gt;val); return root-&gt;val + max(left, right); &#125;&#125;; 129. Sum Root to Leaf Numbers解题思路 仍然是使用搜索递归，计算每一条支路的加和最后返回到主函数； 代码1234567891011121314151617class Solution &#123;public: int sumNumbers(TreeNode* root) &#123; if(root == NULL) return 0; return solve(root, 0); &#125; int solve(TreeNode* root, int res) &#123; if(root == NULL) return 0; if(!root-&gt;left &amp;&amp; !root-&gt;right) return res * 10 + root-&gt;val; return solve(root-&gt;left, res * 10 + root-&gt;val) + solve(root-&gt;right, res * 10 + root-&gt;val); &#125;&#125;; 144. Binary Tree Preorder Traversal解题思路 考察树的非递归遍历； 代码123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(root == NULL) return res; stack&lt;TreeNode*&gt; s; TreeNode* p = root; while(p || !s.empty()) &#123; while(p) &#123; res.push_back(p-&gt;val); s.push(p); p = p-&gt;left; &#125; if(!s.empty()) &#123; p = s.top(); s.pop(); p = p-&gt;right; &#125; &#125; return res; &#125;&#125;; 145. Binary Tree Postorder Traversal解题思路 二叉树的后序遍历，使用非递归方法； 方法一：设置pre和cur两个指针，通过判断pre和cur两个指针的属性和关系进行遍历； 方法二：类似于先序遍历的非递归遍历，将节点按照根节点-&gt;右子节点-&gt;左子节点的顺序放到vector中，最后将vector逆序返回即可； 代码方法一：123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(root == NULL) return res; stack&lt;TreeNode*&gt; s; TreeNode *pre = NULL; TreeNode *cur = NULL; s.push(root); while(!s.empty()) &#123; cur = s.top(); if((!cur-&gt;left &amp;&amp; !cur-&gt;right) || (pre &amp;&amp; (cur-&gt;left == pre || cur-&gt;right == pre))) &#123; res.push_back(cur-&gt;val); s.pop(); pre = cur; &#125; else &#123; if(cur-&gt;right) s.push(cur-&gt;right); if(cur-&gt;left) s.push(cur-&gt;left); &#125; &#125; return res; &#125;&#125;; 方法二：12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; if(root == NULL) return res; stack&lt;TreeNode*&gt; s; TreeNode *cur = NULL; s.push(root); while(!s.empty()) &#123; cur = s.top(); s.pop(); res.push_back(cur-&gt;val); if(cur-&gt;left) s.push(cur-&gt;left); if(cur-&gt;right) s.push(cur-&gt;right); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 173. Binary Search Tree Iterator解题思路 就是利用二叉树的中序遍历不断获取数据即可，二叉搜索树的中序遍历即为从小到大的有序遍历； 代码1234567891011121314151617181920212223242526272829class BSTIterator &#123; stack&lt;TreeNode*&gt; s;public: BSTIterator(TreeNode *root) &#123; pushAll(root); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !s.empty(); &#125; /** @return the next smallest number */ int next() &#123; TreeNode* temp = s.top(); s.pop(); pushAll(temp-&gt;right); return temp-&gt;val; &#125;private: void pushAll(TreeNode* node) &#123; for(; node != NULL; s.push(node), node = node-&gt;left); &#125;&#125;; 199. Binary Tree Right Side View解题思路 方法一：使用一个queue去遍历每一层的节点，将最后一个节点保存到结果中； 方法二：使用类似于先序遍历的方法，每次都先进行右子节点的操作，从而保证每一层最开始访问的节点必定是该层最右边的节点，且只将该节点保存到结果中； 代码方法一12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; if(root == NULL) return res; queue&lt;TreeNode*&gt; que; TreeNode* cur = NULL; que.push(root); while(!que.empty()) &#123; int len = que.size(); for(int i = 0; i &lt; len; ++i) &#123; cur = que.front(); que.pop(); if(cur-&gt;left) que.push(cur-&gt;left); if(cur-&gt;right) que.push(cur-&gt;right); &#125; res.push_back(cur-&gt;val); &#125; return res; &#125;&#125;; 方法二123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; res; if(root == NULL) return res; solve(root, res, 0); return res; &#125; void solve(TreeNode* root, vector&lt;int&gt; &amp;res, int depth) &#123; if(root == NULL) return; if(depth == res.size()) res.push_back(root-&gt;val); solve(root-&gt;right, res, depth+1); solve(root-&gt;left, res, depth+1); &#125;&#125;; 222. Count Complete Tree Nodes解题思路 首先获取整个二叉树的高度为h，如果右子树的高度为h-1，则左子树是一个完全二叉树，反之右子树是一个完全二叉树。对于完全二叉树我们很容易计算他的节点数量，然后使用递归解决。 代码12345678910111213class Solution &#123;public: int countNodes(TreeNode* root) &#123; int h = getHeight(root); return h &lt; 0 ? 0 : getHeight(root-&gt;right) == h-1 ? (1&lt;&lt;h) + countNodes(root-&gt;right) : (1&lt;&lt;h-1) + countNodes(root-&gt;left); &#125; int getHeight(TreeNode* root) &#123; return root == NULL ? -1 : 1 + getHeight(root-&gt;left); &#125;&#125;; 226. Invert Binary Tree解题思路 方法一：递归，分别计算左右子节点的invert，然后将左右子节点交换完成invert； 方法二：使用栈结构，利用栈结构的FIFO性质，实现节点的反转，同时对每个节点都要交换左右子节点； 代码方法一123456789101112class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(root == NULL) return NULL; root-&gt;left = invertTree(root-&gt;left); root-&gt;right = invertTree(root-&gt;right); swap(root-&gt;left, root-&gt;right); return root; &#125;&#125;; 方法二12345678910111213141516171819202122class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(root == NULL) return NULL; stack&lt;TreeNode*&gt; s; s.push(root); while(!s.empty()) &#123; TreeNode* cur = s.top(); s.pop(); if(cur) &#123; s.push(cur-&gt;left); s.push(cur-&gt;right); swap(cur-&gt;left, cur-&gt;right); &#125; &#125; return root; &#125;&#125;; 230. Kth Smallest Element in a BST解题思路 考察树的中序遍历，使用递归遍历和非递归遍历解决； 代码递归方法12345678910111213141516171819202122class Solution &#123;public: int count = 0; int res; int kthSmallest(TreeNode* root, int k) &#123; inOrder(root, k); return res; &#125; void inOrder(TreeNode* root, int k) &#123; if(root == NULL) return; inOrder(root-&gt;left, k); if(++count == k) &#123; res = root-&gt;val; return; &#125; inOrder(root-&gt;right, k); &#125;&#125;; 非递归123456789101112131415161718192021222324class Solution &#123;public: int kthSmallest(TreeNode* root, int k) &#123; stack&lt;TreeNode*&gt; s; int count = 0; TreeNode* p = root; while(!s.empty() || p) &#123; while(p) &#123; s.push(p); p = p-&gt;left; &#125; p = s.top(); s.pop(); if(++count == k) return p-&gt;val; p = p-&gt;right; &#125; return 0; &#125;&#125;; 235. Lowest Common Ancestor of a Binary Search Tree解题思路 因为是二叉搜索树，所以需要判断p和q两个节点的值与root节点的关系，如果在root两边或者直接等于root则祖先节点就是root，否则，祖先节点就有可能root-&gt;left和root-&gt;right两个中再次求取； 代码12345678910class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; while((root-&gt;val - p-&gt;val) * (root-&gt;val - q-&gt;val) &gt; 0) root = p-&gt;val &lt; root-&gt;val ? root-&gt;left : root-&gt;right; return root; &#125;&#125;; 236. Lowest Common Ancestor of a Binary Tree解题思路 有点类似分治的思路，如果root == p || root == q直接返回root； 分别求取lowestCommonAncestor(root-&gt;left, p, q)和lowestCommonAncestor(root-&gt;right, p, q);，如果结果为NULL则证明p和q都不在该子树中，反之，则至少有一个在该子树中，然后继续讨论即可； 代码1234567891011class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(!root || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q); return !left ? right : !right ? left : root; &#125;&#125;; 257. Binary Tree Paths解题思路 使用递归的思路，遍历每一条路径； 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123; vector&lt;string&gt; res; if(root == NULL) return res; dfs(res, root, ""); return res; &#125; void dfs(vector&lt;string&gt; &amp;res, TreeNode* root, string str) &#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; res.push_back(str+to_string(root-&gt;val)); return; &#125; if(root-&gt;left) dfs(res, root-&gt;left, str+to_string(root-&gt;val)+"-&gt;"); if(root-&gt;right) dfs(res, root-&gt;right, str+to_string(root-&gt;val)+"-&gt;"); &#125;&#125;; 297. Serialize and Deserialize Binary Tree解题思路 详细思路请参考此链接！！ 代码1234567891011121314151617181920212223242526272829303132333435363738class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; ostringstream out; myserialize(root, out); return out.str(); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; istringstream is(data); return mydeserialize(is); &#125;private: void myserialize(TreeNode *root, ostringstream &amp;out) &#123; if(root) &#123; out &lt;&lt; root-&gt;val &lt;&lt; " "; myserialize(root-&gt;left, out); myserialize(root-&gt;right, out); &#125; else out &lt;&lt; "# "; &#125; TreeNode* mydeserialize(istringstream &amp;data) &#123; string val; data &gt;&gt; val; if(val == "#") return NULL; TreeNode *root = new TreeNode(stoi(val)); root-&gt;left = mydeserialize(data); root-&gt;right = mydeserialize(data); return root; &#125;&#125;; 337. House Robber III解题思路详细解析请看这个链接！！ 代码12345678910111213141516171819class Solution &#123;public: int rob(TreeNode* root) &#123; vector&lt;int&gt; res = robSub(root); return max(res[0], res[1]); &#125; vector&lt;int&gt; robSub(TreeNode* root) &#123; if(root == NULL) return vector&lt;int&gt;(2, 0); vector&lt;int&gt; left = robSub(root-&gt;left); vector&lt;int&gt; right = robSub(root-&gt;right); vector&lt;int&gt; res(2, 0); res[0] = max(left[0], left[1]) + max(right[0], right[1]); res[1] = root-&gt;val + left[0] + right[0]; return res; &#125;&#125;; 404. Sum of Left Leaves解题思路 递归方法：如果左子节点是左叶子节点，则加和保存，否则迭代计算左子节点的sumOfLeftLeaves，对于右子节点，直接迭代计算sumOfLeftLeaves； 非递归方法：使用一个stack对二叉树进行遍历，对于每个节点，判断其左子节点是否是叶子节点，如果是就加和保存，否则入栈，对于右子节点，只要不是叶子节点就统统入栈。 代码递归12345678910111213141516171819class Solution &#123;public: int res = 0; int sumOfLeftLeaves(TreeNode* root) &#123; if(root == NULL) return 0; int res = 0; if(root-&gt;left) &#123; if(!root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) res += root-&gt;left-&gt;val; else res += sumOfLeftLeaves(root-&gt;left); &#125; res += sumOfLeftLeaves(root-&gt;right); return res; &#125;&#125;; 非递归1234567891011121314151617181920212223242526272829class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; int res = 0; if(root == NULL) return res; stack&lt;TreeNode*&gt; s; s.push(root); while(!s.empty()) &#123; TreeNode* p = s.top(); s.pop(); if(p-&gt;left) &#123; if(!p-&gt;left-&gt;left &amp;&amp; !p-&gt;left-&gt;right) res += p-&gt;left-&gt;val; else s.push(p-&gt;left); &#125; if(p-&gt;right) &#123; if(p-&gt;right-&gt;left || p-&gt;right-&gt;right) s.push(p-&gt;right); &#125; &#125; return res; &#125;&#125;; 449. Serialize and Deserialize BST解题思路 因为是一个二叉搜索树，所以通过获取其前序遍历的数值组合就可以唯一的重新构建出原来的树结构，这里使用了iostringstream，方便进行序列化和反序列化。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; ostringstream out; mySerialize(root, out); return out.str(); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; if(data == "") return NULL; istringstream in(data); return myDeserialize(in); &#125;private: void mySerialize(TreeNode* root, ostringstream &amp;out) &#123; if(root == NULL) return; out &lt;&lt; root-&gt;val &lt;&lt; " "; mySerialize(root-&gt;left, out); mySerialize(root-&gt;right, out); &#125; TreeNode* myDeserialize(istringstream &amp;in) &#123; string val; in &gt;&gt; val; TreeNode *root = new TreeNode(stoi(val)); while(in &gt;&gt; val) buildTree(root, stoi(val)); return root; &#125; void buildTree(TreeNode* root, int n) &#123; if(root-&gt;val &gt; n) &#123; if(root-&gt;left == NULL) root-&gt;left = new TreeNode(n); else buildTree(root-&gt;left, n); &#125; else &#123; if(root-&gt;right == NULL) root-&gt;right = new TreeNode(n); else buildTree(root-&gt;right, n); &#125; &#125;&#125;; 450. Delete Node in a BST解题思路 只有当root-&gt;val == key的时候才执行删除操作，否则根据key的大小在左右子树中执行删除操作。 删除过程中，如果是叶子节点则直接返回NULL，否则取其左右子节点中不为NULL的作为新的根节点返回。 代码1234567891011121314151617181920212223242526272829class Solution &#123;public: TreeNode* deleteNode(TreeNode* root, int key) &#123; if(root == NULL) return NULL; if(root-&gt;val == key) &#123; if(root-&gt;right) &#123; TreeNode* p = root-&gt;right; while(p-&gt;left) p = p-&gt;left; p-&gt;left = root-&gt;left; return root-&gt;right; &#125; else if(root-&gt;left) return root-&gt;left; else return NULL; &#125; if(root-&gt;val &gt; key) root-&gt;left = deleteNode(root-&gt;left, key); if(root-&gt;val &lt; key) root-&gt;right = deleteNode(root-&gt;right, key); return root; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Tree I]]></title>
    <url>%2F2017%2F01%2F05%2FLeetCode-Tree-I%2F</url>
    <content type="text"><![CDATA[本文包含的题目有： 94. Binary Tree Inorder Traversal95. Unique Binary Search Trees II96. Unique Binary Search Trees98. Validate Binary Search Tree99. Recover Binary Search Tree100. Same Tree101. Symmetric Tree102. Binary Tree Level Order Traversal103. Binary Tree Zigzag Level Order Traversal104. Maximum Depth of Binary Tree105. Construct Binary Tree from Preorder and Inorder Traversal106. Construct Binary Tree from Inorder and Postorder Traversal107. Binary Tree Level Order Traversal II108. Convert Sorted Array to Binary Search Tree110. Balanced Binary Tree111. Minimum Depth of Binary Tree112. Path Sum113. Path Sum II437. Path Sum III 94. Binary Tree Inorder Traversal解题思路 二叉树的中序遍历； 代码1234567891011121314151617181920class Solution&#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; res; midOrder(res, root); return res; &#125; void midOrder(vector&lt;int&gt; &amp;res, TreeNode *root) &#123; if(root) &#123; midOrder(res, root-&gt;left); res.push_back(root-&gt;val); midOrder(res, root-&gt;right); &#125; &#125;&#125;; 95. Unique Binary Search Trees II解题思路 使用分治的方法解决； 代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution&#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; vector&lt;TreeNode*&gt; res; if(n == 0) return res; return getTree(1, n); &#125; vector&lt;TreeNode*&gt; getTree(int start, int end) &#123; vector&lt;TreeNode*&gt; res; if(start &gt; end) &#123; res.push_back(NULL); return res; &#125; if(start == end) &#123; res.push_back(new TreeNode(start)); return res; &#125; for(int i = start; i &lt;= end; ++i) &#123; vector&lt;TreeNode*&gt; left = getTree(start, i-1); vector&lt;TreeNode*&gt; right = getTree(i+1, end); for(const auto l : left) &#123; for(const auto r : right) &#123; TreeNode* root = new TreeNode(i); root-&gt;left = l; root-&gt;right = r; res.push_back(root); &#125; &#125; &#125; return res; &#125;&#125;; 96. Unique Binary Search Trees解题思路I 使用DP动态规划，每添加一个新节点，首先保持已有的树结构不变，则新节点只有两个位置可以放置，从而有：res[i] += res[i-1] * 2; 如果将已有的树结构拆开，则只能拆成两个部分，前一部分的右子节点为新节点，新节点的左子节点为右半部分，从而有：res[i] += res[j] * res[i-j-1]； 代码1234567891011121314151617181920class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; res(n+1, 0); res[0] = 1; res[1] = 1; res[2] = 2; for(int i = 3; i &lt;= n; ++i) &#123; res[i] += res[i-1] * 2; for(int j = 1; j &lt; i-1; ++j) &#123; res[i] += res[j] * res[i-j-1]; &#125; &#125; return res[n]; &#125;&#125;; 解题思路II 继续延续上述DP的思路，将res[i-1] * 2转变为res[0] * res[i-1] + res[i-1] * res[0]，然后更新原来的代码，更加简洁； 代码123456789101112131415161718class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; res(n+1, 0); res[0] = 1; res[1] = 1; for(int i = 2; i &lt;= n; ++i) &#123; for(int j = 0; j &lt; i; ++j) &#123; res[i] += res[j] * res[i-j-1]; &#125; &#125; return res[n]; &#125;&#125;; 98. Validate Binary Search Tree解题思路 仍然是使用中序遍历，维持一个pre变量，确保每一个cur &gt; pre即可； 代码1234567891011121314151617181920212223class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; TreeNode* pre = NULL; return midOrder(root, pre); &#125; bool midOrder(TreeNode* root, TreeNode* &amp;pre) &#123; if(root) &#123; if(!midOrder(root-&gt;left, pre)) return false; if(pre &amp;&amp; root-&gt;val &lt;= pre-&gt;val) return false; pre = root; if(!midOrder(root-&gt;right, pre)) return false; &#125; return true; &#125;&#125;; 99. Recover Binary Search Tree解题思路 仍然是中序遍历，遍历一遍，找出乱序的两个节点即可； 代码123456789101112131415161718192021222324252627class Solution &#123;public: TreeNode* left = NULL; TreeNode* right = NULL; TreeNode* pre = new TreeNode((1&lt;&lt;31)); void recoverTree(TreeNode* root) &#123; midOrder(root); swap(left-&gt;val, right-&gt;val); &#125; void midOrder(TreeNode* root) &#123; if(root) &#123; midOrder(root-&gt;left); if(!left &amp;&amp; pre-&gt;val &gt;= root-&gt;val) left = pre; if(left &amp;&amp; pre-&gt;val &gt;= root-&gt;val) right = root; pre = root; midOrder(root-&gt;right); &#125; &#125;&#125;; 100. Same Tree解题思路 这道题就迭代去比较就可以了， 注意两个都是NULL的情况； 代码12345678910111213class Solution &#123;public: bool isSameTree(TreeNode* p, TreeNode* q) &#123; if(p == q) return true; if(p &amp;&amp; q &amp;&amp; p-&gt;val == q-&gt;val) return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); else return false; &#125;&#125;; 101. Symmetric Tree解题思路 按照对称的位置去比较； 代码123456789101112131415161718class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(root == NULL) return true; return isTheSame(root-&gt;left, root-&gt;right); &#125; bool isTheSame(TreeNode* left, TreeNode* right) &#123; if(left == NULL || right == NULL) return left == right; if(left-&gt;val != right-&gt;val) return false; return isTheSame(left-&gt;left, right-&gt;right) &amp;&amp; isTheSame(left-&gt;right, right-&gt;left); &#125;&#125;; 102. Binary Tree Level Order Traversal解题思路 使用一个queue进行广度优先搜索； 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; if(root == NULL) return res; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty()) &#123; temp.clear(); int len = que.size(); for(int i = 0; i &lt; len; ++i) &#123; temp.push_back(que.front()-&gt;val); if(que.front()-&gt;left) que.push(que.front()-&gt;left); if(que.front()-&gt;right) que.push(que.front()-&gt;right); que.pop(); &#125; res.push_back(temp); &#125; return res; &#125;&#125;; 103. Binary Tree Zigzag Level Order Traversal解题思路 仍然按照上述思路进行，使用一个queue保存每一层的数据，这里注意在偶数层进行翻转即可； 代码1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; queue&lt;TreeNode*&gt; que; if(root == NULL) return res; int count = 0; que.push(root); while(!que.empty()) &#123; temp.clear(); int len = que.size(); for(int i = 0; i &lt; len; ++i) &#123; if(que.front()-&gt;left) que.push(que.front()-&gt;left); if(que.front()-&gt;right) que.push(que.front()-&gt;right); temp.push_back(que.front()-&gt;val); que.pop(); &#125; if((count++)&amp;1) reverse(temp.begin(), temp.end()); res.push_back(temp); &#125; return res; &#125;&#125;; 104. Maximum Depth of Binary Tree解题思路 使用一个递归来解决； 代码12345678910class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(root) return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)); return 0; &#125;&#125;; 105. Construct Binary Tree from Preorder and Inorder Traversal解题思路 由中序遍历和先序遍历来构建树结构； 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; TreeNode* root = solve(preorder, inorder, 0, preorder.size(), 0, preorder.size()); return root; &#125; TreeNode* solve(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder, int start, int end, int s, int e) &#123; if(end == start || end &lt; start) return NULL; if(end - start == 1) &#123; return new TreeNode(preorder[start]); &#125; else &#123; TreeNode* res = new TreeNode(preorder[start]); int mid; for(int i = s; i &lt; e; ++i) &#123; if(inorder[i] == preorder[start]) &#123; mid = i; break; &#125; &#125; res-&gt;left = solve(preorder, inorder, start+1, start+mid-s+1, s, mid); res-&gt;right = solve(preorder, inorder, start+mid-s+1, end, mid+1, e); return res; &#125; return NULL; &#125;&#125;; 106. Construct Binary Tree from Inorder and Postorder Traversal解题思路 中序遍历和后序遍历构建树结构，使用unordered_map进行辅助存储； 代码1234567891011121314151617181920212223class Solution &#123;public: unordered_map&lt;int, int&gt; m; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; for(int i = 0; i &lt; inorder.size(); ++i) m[inorder[i]] = i; return solve(inorder, postorder, 0, inorder.size(), 0, inorder.size()); &#125; TreeNode *solve(vector&lt;int&gt; &amp;inorder, vector&lt;int&gt;&amp; postorder, int s1, int e1, int s2, int e2) &#123; if(e1 == s1 || e1 &lt; s1) return NULL; if(e1 - s1 == 1) return new TreeNode(inorder[s1]); int mid = m[postorder[e2-1]]; TreeNode* root = new TreeNode(postorder[e2-1]); root-&gt;left = solve(inorder, postorder, s1, mid, s2, s2+mid-s1); root-&gt;right = solve(inorder, postorder, mid+1, e1, s2+mid-s1, e2-1); return root; &#125;&#125;; 107. Binary Tree Level Order Traversal II解题思路 跟之前的题目一样，最后进行一下翻转就可以了； 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; if(root == NULL) return res; queue&lt;TreeNode*&gt; que; que.push(root); while(!que.empty()) &#123; temp.clear(); int len = que.size(); for(int i = 0; i &lt; len; ++i) &#123; if(que.front()-&gt;left) que.push(que.front()-&gt;left); if(que.front()-&gt;right) que.push(que.front()-&gt;right); temp.push_back(que.front()-&gt;val); que.pop(); &#125; res.push_back(temp); &#125; reverse(res.begin(), res.end()); return res; &#125;&#125;; 108. Convert Sorted Array to Binary Search Tree解题思路 使用分治的思想去构建，每次首先构建中间节点即可； 代码12345678910111213141516171819class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return solve(nums, 0, nums.size()); &#125; TreeNode* solve(vector&lt;int&gt; &amp;nums, int start, int end) &#123; if(start == end || start &gt; end) return NULL; if(end - start == 1) return new TreeNode(nums[start]); int mid = (start + end) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&gt;left = solve(nums, start, mid); root-&gt;right = solve(nums, mid+1, end); return root; &#125;&#125;; 110. Balanced Binary Tree解题思路I 遍历每一个节点，检查是否平衡； 代码12345678910111213141516171819class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; if(root == NULL) return true; if(abs(getHeight(root-&gt;left) - getHeight(root-&gt;right)) &gt; 1) return false; else return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125; int getHeight(TreeNode* root) &#123; if(root == NULL) return 0; return 1 + max(getHeight(root-&gt;left), getHeight(root-&gt;right)); &#125;&#125;; 解题思路II 使用DFS进行深度搜索，每次搜索返回树的高度，如果平衡就返回实际高度值，否则返回-1，最后进行判断即可； 代码123456789101112131415161718192021class Solution &#123;public: bool isBalanced(TreeNode* root) &#123; return getHeight(root) != -1; &#125; int getHeight(TreeNode* root) &#123; if(root == NULL) return 0; int left = getHeight(root-&gt;left); if(left == -1) return -1; int right = getHeight(root-&gt;right); if(right == -1) return -1; if(abs(left - right) &gt; 1) return -1; return max(left, right) + 1; &#125;&#125;; 111. Minimum Depth of Binary Tree解题思路 简单题，但是有点小麻烦，弄清楚边界问题，只有!root-&gt;left &amp;&amp; !root-&gt;right才可以结束遍历，有一个子节点不为NULL就需要继续计算，两个均不为NULL则取较小的一个； 代码12345678910111213141516class Solution &#123;public: int minDepth(TreeNode* root) &#123; if(root == NULL) return 0; if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1; else if(root-&gt;left &amp;&amp; !root-&gt;right) return 1 + minDepth(root-&gt;left); else if(!root-&gt;left &amp;&amp; root-&gt;right) return 1 + minDepth(root-&gt;right); return 1 + min(minDepth(root-&gt;left), minDepth(root-&gt;right)); &#125;&#125;; 112. Path Sum解题思路 遍历每一条路径，检查是否有符合要求的结果； 注意这里需要判断左右子树是不是为NULL，即当前节点是不是叶子节点，然后分情况进行讨论； 代码1234567891011121314151617181920class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(root == NULL) return false; return solve(root, 0, sum); &#125; bool solve(TreeNode* root, int sum, int target) &#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) return sum+root-&gt;val == target; else if(root-&gt;left &amp;&amp; !root-&gt;right) return solve(root-&gt;left, sum+root-&gt;val, target); else if(!root-&gt;left &amp;&amp; root-&gt;right) return solve(root-&gt;right, sum+root-&gt;val, target); return solve(root-&gt;left, sum+root-&gt;val, target) || solve(root-&gt;right, sum+root-&gt;val, target); &#125;&#125;; 113. Path Sum II解题思路 采用递归和回溯的方式，遍历各个分支，如果符合要求就保存； 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp; if(root == NULL) return res; solve(res, temp, root, sum); return res; &#125; void solve(vector&lt;vector&lt;int&gt;&gt; &amp;res, vector&lt;int&gt; &amp;temp, TreeNode* root, int sum) &#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; if(root-&gt;val == sum) &#123; temp.push_back(root-&gt;val); res.push_back(temp); temp.erase(temp.end()-1); &#125; return; &#125; if(root-&gt;left) &#123; temp.push_back(root-&gt;val); solve(res, temp, root-&gt;left, sum-root-&gt;val); temp.erase(temp.end()-1); &#125; if(root-&gt;right) &#123; temp.push_back(root-&gt;val); solve(res, temp, root-&gt;right, sum-root-&gt;val); temp.erase(temp.end()-1); &#125; &#125;&#125;; 437. Path Sum III解题思路 确定一个起始点，然后检查以该起始点开始有多少个分支符合要求，最后进行累加； 确定起点之后，只能在后面一直追加，如果已经计算得到了所求的sum值，在其后继续追加节点，如果追加节点的和为0的话也满足要求，此时计数继续加一； 代码123456789101112131415161718class Solution&#123;public: int pathSum(TreeNode* root, int sum) &#123; if(root == NULL) return 0; return solve(root, sum, 0) + pathSum(root-&gt;left, sum) + pathSum(root-&gt;right, sum); &#125; int solve(TreeNode* root, int target, int sum) &#123; if(root == NULL) return 0; if(sum + root-&gt;val == target) return 1 + solve(root-&gt;left, 0, 0) + solve(root-&gt;right, 0, 0); return solve(root-&gt;left, target, sum+root-&gt;val) + solve(root-&gt;right, target, sum+root-&gt;val); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu14.04系统Chromium安装Adobe Flash插件]]></title>
    <url>%2F2017%2F01%2F04%2FUbuntu14-04%E7%B3%BB%E7%BB%9FChromium%E5%AE%89%E8%A3%85Adobe-Flash%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[经历了好几次重装Ubuntu系统，每次安装都需要配置一大堆东西，对于一个几乎放弃了windows系统的人来说，每次重装系统的第一件事就是安装一个Chromium浏览器，谁让我的所有收藏夹都在Chromium账号中。然而每次安装Chromium的Flash插件都需要去网上查找各种教程，每次都要搞好久才能弄好，这次专门记录一下，以便以后需要时用到。 下载插件首先是下载Adobe Flash插件，下载链接如下：下载Adobe Flash网页会自动检测你所用系统的信息，然后需要点选一下下载插件的压缩格式，一般.tar.gz格式的即可； 添加插件首先将压缩包解压：1tar -xvf xxx.tar.gz 然后将解压目录中的libpepflashplayer.so复制到/usr/lib/chromium-browser/plugins中去；1sudo cp libpepflashplayer.so /usr/lib/chromium-browser/plugins 更改配置修改/etc/chromium-browser/default文件中的配置：1234sudo gedit /etc/chromium-browser/default#在打开的文件中输入以下内容CHROMIUM_FLAGS="--ppapi-flash-path=/usr/lib/chromium-browser/plugins/libpepflashplayer.so --ppapi-flash-version= XXXX" 其中XXXX表示你所使用的Adobe Flash的插件版本，比如下图中的版本即为：24.0.0.186。 新版浏览器启动flash插件新版Chromium浏览器将flash和pdf等功能集成到了setting选项中，在setting栏目中搜索flash关键字，在content setting中的flash设置中选择Allow sites to run Flahs即可。如下图所示： 老版启动插件老版本的Chromium浏览器启动flash插件输入chrome://plugins/启动即可，如下：打开Chromium浏览器，地址栏输入：chrome://plugins/， 启用Adobe插件即可；如下图所示（图中显示的是我以前安装的老版本），这样在Ubuntu系统下也可以愉快的听音乐和看视频了！]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Adobe Flash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode LinkList]]></title>
    <url>%2F2016%2F12%2F31%2FLeetCode-LinkList%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：2. Add Two Numbers19. Remove Nth Node From End of List21. Merge Two Sorted Lists23. Merge k Sorted Lists24. Swap Nodes in Pairs25. Reverse Nodes in k-Group61. Rotate List82. Remove Duplicates from Sorted List II83. Remove Duplicates from Sorted List86. Partition List92. Reverse Linked List II109. Convert Sorted List to Binary Search Tree138. Copy List with Random Pointer141. Linked List Cycle142. Linked List Cycle II143. Reorder List160. Intersection of Two Linked Lists203. Remove Linked List Elements206. Reverse Linked List234. Palindrome Linked List237. Delete Node in a Linked List328. Odd Even Linked List445. Add Two Numbers II 2. Add Two Numbers解题思路 直接新建一个链表，然后进行加法运算即可； 代码12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *head = new ListNode(-1); ListNode *p = head; int carry = 0; int a, b, c; while(l1 || l2) &#123; a = b = c = 0; if(l1) &#123; a = l1-&gt;val; l1 = l1-&gt;next; &#125; if(l2) &#123; b = l2-&gt;val; l2 = l2-&gt;next; &#125; c = a + b + carry; p-&gt;next = new ListNode(c % 10); carry = c / 10; p = p-&gt;next; &#125; if(carry == 1) &#123; p-&gt;next = new ListNode(1); &#125; return head-&gt;next; &#125;&#125;; 19. Remove Nth Node From End of List解题思路 使用两个指针a, b，a先定位到从左边开始第n个，然后b在链表头部和a同时进行遍历，a到尾部的时候b也就正好取到了所求结果； 代码1234567891011121314151617181920class Solution&#123; public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *root = new ListNode(0); root-&gt;next = head; ListNode *p, *c; p = c = root; for(int i = 0; i &lt; n+1; ++i) c = c-&gt;next; while(c) &#123; p = p-&gt;next; c = c-&gt;next; &#125; p-&gt;next = p-&gt;next-&gt;next; return root-&gt;next; &#125;&#125;; 21. Merge Two Sorted Lists解题思路 归并排序的merge算法； 代码123456789101112131415161718192021222324252627282930class Solution&#123; public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* head = new ListNode(0); ListNode* p = head; while(l1 &amp;&amp; l2) &#123; if(l1-&gt;val &gt; l2-&gt;val) &#123; p-&gt;next = new ListNode(l2-&gt;val); p = p-&gt;next; l2 = l2-&gt;next; &#125; else &#123; p-&gt;next = new ListNode(l1-&gt;val); p = p-&gt;next; l1 = l1-&gt;next; &#125; &#125; if(l1) p-&gt;next = l1; if(l2) p-&gt;next = l2; return head-&gt;next; &#125;&#125;; 23. Merge k Sorted Lists解题思路 二分法进行排序； 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution&#123; public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; int len = lists.size(); if(len == 0) return NULL; else if(len == 1) return lists[0]; else if(len == 2) return mergeTwoLists(lists[0], lists[1]); vector&lt;ListNode*&gt; left(lists.begin(), lists.begin() + len/2); vector&lt;ListNode*&gt; right(lists.begin()+len/2, lists.end()); return mergeTwoLists(mergeKLists(left), mergeKLists(right)); &#125; ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* head = new ListNode(0); ListNode* p = head; while(l1 &amp;&amp; l2) &#123; if(l1-&gt;val &gt; l2-&gt;val) &#123; p-&gt;next = new ListNode(l2-&gt;val); p = p-&gt;next; l2 = l2-&gt;next; &#125; else &#123; p-&gt;next = new ListNode(l1-&gt;val); p = p-&gt;next; l1 = l1-&gt;next; &#125; &#125; if(l1) p-&gt;next = l1; if(l2) p-&gt;next = l2; return head-&gt;next; &#125;&#125;; 24. Swap Nodes in Pairs解题思路 这个考的链表的基本操作吧； 代码1234567891011121314151617181920212223242526class Solution&#123; public: ListNode* swapPairs(ListNode* head) &#123; if(!head &amp;&amp; !head-&gt;next) return head; ListNode* root = new ListNode(0); root-&gt;next = head; ListNode *p, *c; p = root; c = root-&gt;next-&gt;next; while(c) &#123; p-&gt;next-&gt;next = c-&gt;next; c-&gt;next = p-&gt;next; p-&gt;next = c; p = p-&gt;next-&gt;next; if(p-&gt;next) c = p-&gt;next-&gt;next; else break; &#125; return root-&gt;next; &#125;&#125;; 25. Reverse Nodes in k-Group解题思路 首先维持一个len数值，通过len与k的比较判断是否需要reverse； reverse就和上一题一样了，基本操作； 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution&#123; public: ListNode* reverseKGroup(ListNode* head, int k) &#123; int len = getLen(head); if(len &lt; k || k == 1) return head; ListNode *root = new ListNode(-1); ListNode *p = root; ListNode *p1 = head; ListNode *p2 = head; while(len &gt;= k) &#123; for(int i = 0; i &lt; k; ++i) &#123; p2 = p1-&gt;next; p1-&gt;next = p-&gt;next; p-&gt;next = p1; p1 = p2; &#125; while(p-&gt;next) p = p-&gt;next; len -= k; if(len &lt; k) &#123; p-&gt;next = p1; return root-&gt;next; &#125; &#125; return root-&gt;next; &#125; int getLen(ListNode *head) &#123; ListNode *p = head; int count = 0; while(p) &#123; count++; p = p-&gt;next; &#125; return count; &#125;&#125;; 61. Rotate List解题思路 构建循环链表，然后rotate再断开，这里注意使用%求余进行计算； 代码1234567891011121314151617181920212223242526272829303132333435class Solution&#123; public: ListNode* rotateRight(ListNode *head, int k) &#123; if(head == NULL) return NULL; ListNode *res; ListNode *p = head; int len = 1; while(p-&gt;next) &#123; len++; p = p-&gt;next; &#125; k %= len; if(k == 0) return head; p-&gt;next = head; while(p) &#123; p = p-&gt;next; len--; if(len == k) &#123; res = p-&gt;next; p-&gt;next = NULL; break; &#125; &#125; return res; &#125;&#125;; 82. Remove Duplicates from Sorted List II解题思路 第一次检测得到的节点cur可以保证其与前置节点不重复，此时将其设为待选节点置为pre-&gt;next = cur，再次循环，如果位置仍不改变pre-&gt;next == cur，则其后也没有重复节点，执行pre = pre-&gt;next即可； 代码123456789101112131415161718192021222324class Solution&#123; public: ListNode *deleteDuplicates(ListNode* head) &#123; if(head == NULL) return head; ListNode *root = new ListNode((1&lt;&lt;31)); root-&gt;next = head; ListNode *cur = head; ListNode *pre = root; while(cur) &#123; while(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) cur = cur-&gt;next; if(pre-&gt;next == cur) pre = pre-&gt;next; else pre-&gt;next = cur-&gt;next; cur = cur-&gt;next; &#125; return root-&gt;next; &#125;&#125;; 83. Remove Duplicates from Sorted List解题思路 简单题 代码12345678910111213141516171819202122class Solution&#123; public: ListNode *deleteDuplicates(ListNode *head) &#123; if(head == NULL) return head; ListNode * root = new ListNode(0); root-&gt;next = head; ListNode *pre = root; ListNode *cur = head; while(cur) &#123; while(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val) cur = cur-&gt;next; pre-&gt;next = cur; pre = pre-&gt;next; cur = cur-&gt;next; &#125; return root-&gt;next; &#125;&#125;; 86. Partition List解题思路 建立左右两个链表，将小于x的数全部放入到左链表中，其他的都放到右链表中，最后连接起来就好； 代码12345678910111213141516171819202122232425262728293031class Solution&#123; public: ListNode* partition(ListNode* head, int x) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *left = new ListNode(0); ListNode *right = new ListNode(0); ListNode *l = left; ListNode *r = right; ListNode *p = head; while(p) &#123; if(p-&gt;val &lt; x) &#123; l-&gt;next = p; l = l-&gt;next; &#125; else &#123; r-&gt;next = p; r = r-&gt;next; &#125; p = p-&gt;next; &#125; r-&gt;next = NULL; l-&gt;next = right-&gt;next; return left-&gt;next; &#125;&#125;; 92. Reverse Linked List II解题思路 这里其实是应用了链表的逆序算法； 代码12345678910111213141516171819202122232425class Solution&#123; public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if(head == NULL || m == n) return head; ListNode *root = new ListNode(0); root-&gt;next = head; ListNode *pre, *cur, *left; left = root; for(int i = 1; i &lt; m; ++i) left = left-&gt;next; pre = left-&gt;next; cur = pre-&gt;next; for(int i = 0; i &lt; n - m; ++i) &#123; pre-&gt;next = cur-&gt;next; cur-&gt;next = left-&gt;next; left-&gt;next = cur; cur = pre-&gt;next; &#125; return root-&gt;next; &#125;&#125;; 109. Convert Sorted List to Binary Search Tree解题思路 由于链表是有序的，需要先从中间开始插入，从而来保证树结构的平衡； 这里用到了slow和fast两个指针来快速求取链表中点； 代码1234567891011121314151617181920212223242526class Solution&#123; public: TreeNode *sortedListToBST(ListNode *head) &#123; if(head == NULL) return NULL; return toTree(head, NULL); &#125; TreeNode *toTree(ListNode *head, ListNode *tail) &#123; if(head == tail) return NULL; ListNode *slow = head; ListNode *fast = head; while(fast != tail &amp;&amp; fast-&gt;next != tail) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; TreeNode *res = new TreeNode(slow-&gt;val); res-&gt;left = toTree(head, slow); res-&gt;right = toTree(slow-&gt;next, tail); return res; &#125;&#125;; 138. Copy List with Random Pointer解题思路 首先在每个链表节点后面复制一个该节点，加入到链表中； 此时复制节点的random取值就变成：cp-&gt;random = p-&gt;random-&gt;next； 然后再将两个链表区分开来就可以了； 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: RandomListNode *copyRandomList(RandomListNode *head) &#123; if(head == NULL) return NULL; RandomListNode *p = head; RandomListNode *cp; RandomListNode *res; while(p) &#123; cp = new RandomListNode(p-&gt;label); cp-&gt;next = p-&gt;next; p-&gt;next = cp; p = cp-&gt;next; &#125; p = head; while(p) &#123; cp = p-&gt;next; if(p-&gt;random) cp-&gt;random = p-&gt;random-&gt;next; p = cp-&gt;next; &#125; res = head-&gt;next; p = head; while(p) &#123; cp = p-&gt;next; p-&gt;next = cp-&gt;next; p = p-&gt;next; if(p) cp-&gt;next = p-&gt;next; &#125; return res; &#125;&#125;; 141. Linked List Cycle解题思路 简单题，使用快慢指针解决，如果有循环则快慢指针会相遇； 代码1234567891011121314151617181920class Solution&#123; public: bool hasCycle(ListNode *head) &#123; ListNode *slow = head; ListNode *fast = head; while(slow &amp;&amp; fast) &#123; slow = slow-&gt;next; if(fast-&gt;next) fast = fast-&gt;next-&gt;next; else return false; if(slow == fast) return true; &#125; return false; &#125;&#125;; 142. Linked List Cycle II解题思路 使用快慢指针，第一次相遇时结束；快指针比慢指针多走了一倍的距离； 快指针多走了一个循环，通过画图分析，从相遇节点到cycle begin的距离正好等于从起始节点到cycle begin的距离； 代码123456789101112131415161718192021222324252627282930313233class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL) return NULL; ListNode *slow = head; ListNode *fast = head; bool isCycle = false; while(slow &amp;&amp; fast) &#123; slow = slow-&gt;next; if(fast-&gt;next == NULL) return NULL; fast = fast-&gt;next-&gt;next; if(slow == fast) &#123; isCycle = true; break; &#125; &#125; if(!isCycle) return NULL; slow = head; while(slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow; &#125;&#125;; 143. Reorder List解题思路 使用快慢指针将链表从中间分成两部分，将后半部分进行逆序处理最后merge合并即可； 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: void reorderList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return; ListNode *p1 = head; ListNode *p2 = head-&gt;next; while(p2 &amp;&amp; p2-&gt;next) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; &#125; ListNode *head2 = p1-&gt;next; p1-&gt;next = NULL; p2 = head2-&gt;next; head2-&gt;next = NULL; while(p2) &#123; p1 = p2-&gt;next; p2-&gt;next = head2; head2 = p2; p2 = p1; &#125; for(p1 = head, p2 = head2; p1; ) &#123; auto temp = p1-&gt;next; p1 = p1-&gt;next = p2; p2 = temp; &#125; &#125;&#125;; 160. Intersection of Two Linked Lists解题思路 如果两个链表有重复的部分，则A+B和B+A对齐就可以直接找到重复的部分； 代码1234567891011121314151617181920212223class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; ListNode *p = headA; ListNode *q = headB; if(p == NULL || p == NULL) return NULL; while(p &amp;&amp; q &amp;&amp; p != q) &#123; p = p-&gt;next; q = q-&gt;next; if(p == q) return p; if(p == NULL) p = headB; if(q == NULL) q = headA; &#125; return p; &#125;&#125;; 203. Remove Linked List Elements解题思路 * 简单题，不多说了； 代码1234567891011121314151617181920class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode *root = new ListNode(0); root-&gt;next = head; ListNode *cur = root; while(cur-&gt;next) &#123; if(cur-&gt;next-&gt;val == val) &#123; cur-&gt;next = cur-&gt;next-&gt;next; &#125; else cur = cur-&gt;next; &#125; return root-&gt;next; &#125;&#125;; 206. Reverse Linked List解题思路 链表的逆序处理； 代码123456789101112131415161718192021class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *pre = head; ListNode *cur = head-&gt;next; ListNode *temp; pre-&gt;next = NULL; while(cur-&gt;next) &#123; temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; &#125; cur-&gt;next = pre; return cur; &#125;&#125;; 234. Palindrome Linked List解题思路 使用快慢指针将链表分成两个部分，将后半部分进行逆序处理然后进行比较是否为回文； 代码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return true; ListNode *slow = head; ListNode *fast = head; while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; ListNode *pre = slow-&gt;next; ListNode *cur = pre-&gt;next; slow-&gt;next = NULL; pre-&gt;next = NULL; while(cur) &#123; ListNode *temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; &#125; ListNode *p = head; while(pre &amp;&amp; p) &#123; if(pre-&gt;val != p-&gt;val) return false; pre = pre-&gt;next; p = p-&gt;next; &#125; return true; &#125;&#125;; 237. Delete Node in a Linked List解题思路 这个题，搞明白题意就可以，将要删除的节点数据替换成下一节点的数据； 代码12345678class Solution &#123;public: void deleteNode(ListNode* node) &#123; *node = *node-&gt;next; &#125;&#125;; 328. Odd Even Linked List解题思路 两个两个向后扫描即可，得到奇偶两条链表链接到一块； 代码123456789101112131415161718192021class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; if(head == NULL || head-&gt;next == NULL) return head; ListNode *odd = head; ListNode *even = head-&gt;next; ListNode *evenStart = even; while(even &amp;&amp; even-&gt;next) &#123; odd-&gt;next = odd-&gt;next-&gt;next; even-&gt;next = even-&gt;next-&gt;next; odd = odd-&gt;next; even = even-&gt;next; &#125; odd-&gt;next = evenStart; return head; &#125;&#125;; 445. Add Two Numbers II解题思路 利用l1+l2和l2+l1实现对齐，利用两个bool标记何时数值有效； 将结果保存到一个vector中，最后求取进位后构建链表； 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; bool f1 = false; bool f2 = false; vector&lt;int&gt; sum; ListNode *res = new ListNode(0); ListNode *p = l1; ListNode *q = l2; while(p &amp;&amp; q) &#123; if(f1 || f2) &#123; int temp = (f1 ? p-&gt;val : 0) + (f2 ? q-&gt;val : 0); sum.push_back(temp); &#125; p = p-&gt;next; q = q-&gt;next; if(f1 &amp;&amp; f2 &amp;&amp; p == q) break; if(p == NULL)&#123; p = l2; f1 = true; &#125; if(q == NULL)&#123; q = l1; f2 = true; &#125; &#125; int carry = 0; for(int i = sum.size()-1; i &gt;= 0; --i) &#123; sum[i] = sum[i] + carry; carry = sum[i] / 10; sum[i] %= 10; &#125; if(carry) sum.insert(sum.begin(), carry); ListNode *cur = res; for(int i = 0; i &lt; sum.size(); ++i) &#123; cur-&gt;next = new ListNode(sum[i]); cur = cur-&gt;next; &#125; return res-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序的实现与深入应用分析]]></title>
    <url>%2F2016%2F12%2F28%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%B7%B1%E5%85%A5%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[归并排序是我们经常使用的一种排序方法，其特性为：最差时间复杂度：O(nlogn)平均时间复杂度：O(nlogn)最差空间复杂度：O(n)稳定性：稳定本文主要介绍在LeetCode中用到归并排序的两道例题，详细展示一下归并排序的强大应用； 归并排序下面的代码是使用c++的vector编写的归并排序，方便读者阅读理解归并排序：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void MergeSort(vector&lt;int&gt; &amp;nums, int left, int right)&#123; if(right - left &lt;= 1) return; int mid = (left + right) / 2; MergeSort(nums, left, mid); MergeSort(nums, mid, right); vector&lt;int&gt; temp(right - left, 0); int l = left; int r = mid; int s = 0; while(l &lt; mid &amp;&amp; r &lt; right) &#123; if(nums[l] &lt; nums[r]) temp[s++] = nums[l++]; else temp[s++] = nums[r++]; &#125; while(l &lt; mid) temp[s++] = nums[l++]; while(r &lt; right) temp[s++] = nums[r++]; for(int i = left; i &lt; right; ++i) nums[i] = temp[i-left];&#125;int main()&#123; vector&lt;int&gt; nums; int num; while(cin &gt;&gt; num) nums.push_back(num); for(const auto x : nums) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; MergeSort(nums, 0, nums.size()); for(const auto x : nums) cout &lt;&lt; x &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 归并排序应用315. Count of Smaller Numbers After SelfYou are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example: Given nums = [5, 2, 6, 1] To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1). To the right of 6 there is 1 smaller element (1). To the right of 1 there is 0 smaller element. Return the array [2, 1, 1, 0]. 解题思路以[5, 2, 6, 1]为例，我们使用归并排序解决这个问题：首先归并排序将[5, 2, 6, 1]分为 [5, 2], [6, 1] 然后因为再归并的话可以得到 [[5], [2]], [[6], [1]] 在[[6], [1]]中，[1]位于整个区间的右部，所以结果为0；[6]位于左边，使[6]中每个元素都与右边[1]比较，可以得到6的count值为1；比较完成后对[[6], [1]]进行排序，得到： [[5], [2]], [[1], [6(1)]] 然后在[[5], [2]]中执行相同的操作，2的count值为0， 5的count值为1，得到： [[2], [5(1)]], [[1], [6(1)]] 然后在[[[2], [5(1)]], [[1], [6(1)]]]中进行比较，左边[[2], [5(1)]]中每个数值都在[[1], [6(1)]]进行遍历计数，由于[[1], [6(1)]]和[[2], [5(1)]]都已经排好序了，所以只需要遍历一遍就可以得到结果： [[2(1)], [5(2)]], [[1], [6(1)]] 每次通过辅助的拷贝数组将计数信息保存到正确的位置即可；由于使用了归并排序，所以每次进行比较的时候都是比较的有序队列，这样可以很好地提高效率，同时也保证了每一轮次左右相对位置的稳定； 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution&#123; public: vector&lt;int&gt; countSmaller(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); vector&lt;int&gt; res(len, 0); vector&lt;int&gt; index; for(int i = 0; i &lt; len; ++i) index.push_back(i); vector&lt;int&gt; numUpdate = nums; vector&lt;int&gt; indexUpdate = index; solve(res, nums, index, 0, len, numUpdate, indexUpdate); return res; &#125; void solve(vector&lt;int&gt; &amp;res, vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;index, int start, int end, vector&lt;int&gt; &amp;numUpdate, vector&lt;int&gt; &amp;indexUpdate) &#123; if(end - start &lt;= 1) return; int mid = (start + end) / 2; solve(res, nums, index, mid, end, numUpdate, indexUpdate); solve(res, nums, index, start, mid, numUpdate, indexUpdate); int r = mid; int t = mid; int s = start; for(int l = start; l &lt; mid; ++l) &#123; while(nums[l] &gt; nums[r] &amp;&amp; r &lt; end) r++; while(t &lt; end &amp;&amp; nums[t] &lt;= nums[l]) &#123; numUpdate[s] = nums[t]; indexUpdate[s++] = index[t++]; &#125; numUpdate[s] = nums[l]; indexUpdate[s++] = index[l]; res[index[l]] += r - mid; &#125; for(int i = start; i &lt; end; ++i) &#123; nums[i] = numUpdate[i]; index[i] = indexUpdate[i]; &#125; &#125;&#125;; 327. Count of Range SumGiven an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive. Note:A naive algorithm of O(n2) is trivial. You MUST do better than that. Example:Given nums = [-2, 5, -1], lower = -2, upper = 2,Return 3.The three ranges are : [0, 0], [2, 2], [0, 2] and their respective sums are: -2, -1, 2. 解题思路这一题跟上面一题类似，都要使用归并排序进行分段求解；首先构建一个sum的数组，sum[i]表示从0～i的子区间的元素之和，这样sum[i][j]就表示从i～j的子区间的元素之和，从而问题也就转化为求取sum数组中sum[i]之后的sum[j]满足lower &lt;= sum[j] - sum[i] &lt;= upper的个数，其中i&lt;=j，就相当于上面那个题加了一个上下界；则仍然使用上面归并排序的思路，在归并排序的过程中进行计数计算，对于左边的每个元素，都在右边的元素中去找两个参数: left：第一个满足 sum[j] - sum[i] &gt;= lower，即为左边界；right：第一个满足 sum[j] - sum[i] &gt; upper，即为右边界； 则right-left即为所求的计数个数，不断叠加即可； 因为每一次归并之后左右两个部分都是有序的序列，所以这里left和right同样只需要扫描一遍即可； 代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution&#123; public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int len = nums.size(); if(len == 0) return 0; vector&lt;long&gt; sums(len+1, 0); for(int i = 0; i &lt; len; ++i) sums[i+1] = sums[i] + nums[i]; vector&lt;long&gt; sumUpdate = sums; return solve(sums, sumUpdate, 0, len+1, lower, upper); &#125; int solve(vector&lt;long&gt; &amp;sums, vector&lt;long&gt; &amp;sumUpdate, int start, int end, int lower, int upper) &#123; if(end - start &lt;= 1) return 0; int mid = (end + start) / 2; int count = solve(sums, sumUpdate, start, mid, lower, upper) + solve(sums, sumUpdate, mid, end, lower, upper); int l = mid; int r = mid; int t = mid; int s = start; for(int i = start; i &lt; mid; ++i) &#123; while(sums[l] - sums[i] &lt; lower &amp;&amp; l &lt; end) l++; while(sums[r] - sums[i] &lt;= upper &amp;&amp; r &lt; end) r++; while(sums[i] &gt; sums[t] &amp;&amp; t &lt; end) sumUpdate[s++] = sums[t++]; sumUpdate[s++] = sums[i]; count += r - l; &#125; for(int i = start; i &lt; end; ++i) sums[i] = sumUpdate[i]; return count; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>MergeSort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Divide and Conquer]]></title>
    <url>%2F2016%2F12%2F27%2FLeetCode-Divide-and-Conquer%2F</url>
    <content type="text"><![CDATA[本文包含如下题目： 218. The Skyline Problem241. Different Ways to Add Parentheses282. Expression Add Operators312. Burst Balloons315. Count of Smaller Numbers After Self327. Count of Range Sum 218. The Skyline Problem解题思路 强烈推荐看这个分析，文章链接！！！！！！！ 只有矩阵的左右边界会对最后的结果产生影响，使用vector保存全部边界并进行排序； 使用priority_queue的heap结构维持一个存储高度的堆，如果是左边界，则其高度数据push进去，如果是右边界，则将该高度标记为废弃，在后面访问到的时候删除； 如果改边界获取的最大高度值与之前一样，则不操作，否则，将边界值和高度信息push进答案中去； 这里使用了priority_queue的堆结构特性，可以很快的访问到最大值； 使用unordered_map比map要快很多，因为它不排序； 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bool cmp(const pair&lt;int, int&gt; a, const pair&lt;int, int&gt; b)&#123; return a.first != b.first ? a.first &lt; b.first : a.second &lt; b.second;&#125;class Solution &#123; public: vector&lt;pair&lt;int, int&gt;&gt; getSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; buildings) &#123; vector&lt;pair&lt;int, int&gt;&gt; res; vector&lt;pair&lt;int, int&gt;&gt; heights; for(const auto build : buildings) &#123; heights.push_back(make_pair(build[0], -build[2])); heights.push_back(make_pair(build[1], build[2])); &#125; sort(heights.begin(), heights.end(), cmp); unordered_map&lt;int, int&gt; isEnd; priority_queue&lt;int&gt; que; int pre = 0; que.push(0); int cur; for(const auto height : heights) &#123; if(height.second &lt; 0) &#123; que.push(-height.second); &#125; else &#123; ++isEnd[height.second]; while(!que.empty() &amp;&amp; isEnd[que.top()] &gt; 0) &#123; --isEnd[que.top()]; que.pop(); &#125; &#125; cur = que.top(); if(cur != pre) &#123; pre = cur; res.push_back(make_pair(height.first, cur)); &#125; &#125; return res; &#125;&#125;; 241. Different Ways to Add Parentheses解题思路 每个运算选项都有可能是最后一个运算，由此展开进行求算； 使用递归来求解，要注意仔细观察原函数的输入和输出来确定递归的调用方式； 代码123456789101112131415161718192021222324252627282930313233343536373839class Solution&#123; public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; res; int len = input.size(); for(int i = 0; i &lt; len; ++i) &#123; if(input[i] == '+' || input[i] == '-' || input[i] == '*') &#123; vector&lt;int&gt; r1 = diffWaysToCompute(input.substr(0, i)); vector&lt;int&gt; r2 = diffWaysToCompute(input.substr(i+1)); for(const auto a : r1) &#123; for(const auto b : r2) &#123; if(input[i] == '+') res.push_back(a + b); else if(input[i] == '-') res.push_back(a - b); else if(input[i] == '*') res.push_back(a * b); &#125; &#125; &#125; &#125; if(res.empty()) &#123; int temp = 0; for(const auto ch : input) &#123; temp = temp * 10 + ch - '0'; &#125; res.push_back(temp); &#125; return res; &#125;&#125;; 282. Expression Add Operators结题思路 使用dfs进行深度搜索，用两个参数pre和val保持计算优先级； pre表示已经计算的出的结果，val表示先阶段计算得出的结果但是不确定后面的运算符是+还是×，如果是×就需要考虑优先级； +： pre = pre + val; val = temp; -: pre = pre + val; val = -temp; : pre = pre; val = val temp; 代码123456789101112131415161718192021222324252627282930313233343536typedef long long ll;class Solution&#123; public: vector&lt;string&gt; addOperators(string num, int target) &#123; vector&lt;string&gt; res; dfs(res, num.size(), num, target, 0, 0, 0, ""); return res; &#125; void dfs(vector&lt;string&gt; &amp;res, int len, string num, ll target, int cur, ll pre, ll val, string path) &#123; if(cur == len &amp;&amp; pre + val == target) &#123; res.push_back(path); return; &#125; ll temp = 0; for(int i = cur; i &lt; len; ++i) &#123; temp = temp * 10 + num[i] - '0'; string s = to_string(temp); if(cur != 0) &#123; dfs(res, len, num, target, i+1, pre+val, temp, path + '+' + s); dfs(res, len, num, target, i+1, pre+val, -temp, path + '-' + s); dfs(res, len, num, target, i+1, pre, temp * val, path + '*' + s); &#125; else dfs(res, len, num, target, i+1, 0, temp, s); if(num[cur] == '0') break; &#125; &#125;&#125;; 312. Burst Balloons解题思路 在nums两端各添加一个1； 设DP[i][j]表示从i~j的计算结果，则整个计算结果为DP[1][N]，N表示nums添加1之前的长度； 如果x是i~j中最后一个气球，则其结果为：nums[i-1]*nums[x]*nums[j+1]; 则使用DP可以得到状态公式：dp[i][j] = max(dp[i][j], dp[i][x-1] + nums[i-1]*nums[x]*nums[j+1] + dp[x+1][j]); 代码12345678910111213141516171819202122class Solution&#123; public: int maxCoins(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); nums.insert(nums.begin(), 1); nums.insert(nums.end(), 1); vector&lt;vector&lt;int&gt;&gt; dp(len+2, vector&lt;int&gt;(len+2, 0)); for(int k = 1; k &lt;= len; ++k) &#123; for(int i = 1; i &lt;= len-k+1; ++i) &#123; for(int j = i; j &lt; i+k; ++j) &#123; dp[i][i+k-1] = max(dp[i][i+k-1], dp[i][j-1] + nums[i-1]*nums[j]*nums[i+k] + dp[j+1][i+k-1]); &#125; &#125; &#125; return dp[1][len]; &#125;&#125;; 315. Count of Smaller Numbers After Self解题思路I 使用归并排序，在归并排序的过程中一段一段地去计算结果； 对于每一阶段归并排序的左右两部分，左半部分每个元素都去右半部分中找Smaller Number，由于是在归并排序之后再去找，所以只需要扫描一遍； 具体分析可以看这里！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution&#123; public: vector&lt;int&gt; countSmaller(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); vector&lt;int&gt; res(len, 0); vector&lt;int&gt; index; for(int i = 0; i &lt; len; ++i) index.push_back(i); vector&lt;int&gt; numUpdate = nums; vector&lt;int&gt; indexUpdate = index; solve(res, nums, index, 0, len, numUpdate, indexUpdate); return res; &#125; void solve(vector&lt;int&gt; &amp;res, vector&lt;int&gt; &amp;nums, vector&lt;int&gt; &amp;index, int start, int end, vector&lt;int&gt; &amp;numUpdate, vector&lt;int&gt; &amp;indexUpdate) &#123; if(end - start &lt;= 1) return; int mid = (start + end) / 2; solve(res, nums, index, mid, end, numUpdate, indexUpdate); solve(res, nums, index, start, mid, numUpdate, indexUpdate); int r = mid; int t = mid; int s = start; for(int l = start; l &lt; mid; ++l) &#123; while(nums[l] &gt; nums[r] &amp;&amp; r &lt; end) r++; while(t &lt; end &amp;&amp; nums[t] &lt;= nums[l]) &#123; numUpdate[s] = nums[t]; indexUpdate[s++] = index[t++]; &#125; numUpdate[s] = nums[l]; indexUpdate[s++] = index[l]; res[index[l]] += r - mid; &#125; for(int i = start; i &lt; end; ++i) &#123; nums[i] = numUpdate[i]; index[i] = indexUpdate[i]; &#125; &#125;&#125;; 解题思路II 首先对数据进行拷贝排序，使用map保存其序列号值； 使用了Fenwick树结构，保存数据的大小个数等信息； 遍历数组结构，每次获得当前数值的结果后，将当前数值添加进树结构中，并进行树结构更新； 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class FenwickTree&#123; vector&lt;int&gt; sumArray; int n; inline int lowBit(int x) &#123; return x &amp; -x; &#125;public: FenwickTree(int n) : n(n), sumArray(n+1, 0) &#123;&#125; void add(int x, int d) &#123; while(x &lt;= n) &#123; sumArray[x] += d; x += lowBit(x); &#125; &#125; int sum(int x) &#123; int res = 0; while(x &gt; 0) &#123; res += sumArray[x]; x -= lowBit(x); &#125; return res; &#125;&#125;;class Solution&#123; public: vector&lt;int&gt; countSmaller(vector&lt;int&gt; &amp;nums) &#123; vector&lt;int&gt; temp = nums; sort(temp.begin(), temp.end()); unordered_map&lt;int, int&gt; dic; for(int i = 0; i &lt; temp.size(); ++i) dic[temp[i]] = i+1; FenwickTree tree(nums.size()); vector&lt;int&gt; res(nums.size(), 0); for(int i = nums.size()-1; i &gt;= 0; --i) &#123; res[i] = tree.sum(dic[nums[i]] - 1); tree.add(dic[nums[i]], 1); &#125; return res; &#125;&#125;; 327. Count of Range Sum解题思路 详细讲解看这里！ 代码123456789101112131415161718192021222324252627282930313233343536373839class Solution&#123;public: int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int size=nums.size(); if(size==0) return 0; vector&lt;long&gt; sums(size+1, 0); for(int i=0; i&lt;size; i++) sums[i+1]=sums[i]+nums[i]; return solve(sums, 0, size+1, lower, upper); &#125; int solve(vector&lt;long&gt;&amp; sums, int start, int end, int lower, int upper) &#123; if(end-start&lt;=1) return 0; int mid=(start+end)/2; int count=solve(sums, start, mid, lower, upper) + solve(sums, mid, end, lower, upper); int m=mid, n=mid, t=mid, len=0; vector&lt;long&gt; cache(end-start, 0); for(int i=start, s=0; i&lt;mid; i++, s++) &#123; while(m&lt;end &amp;&amp; sums[m]-sums[i]&lt;lower) m++; while(n&lt;end &amp;&amp; sums[n]-sums[i]&lt;=upper) n++; count+=n-m; while(t&lt;end &amp;&amp; sums[t]&lt;sums[i]) cache[s++]=sums[t++]; cache[s]=sums[i]; len=s; &#125; for(int i=0; i&lt;=len; i++) sums[start+i]=cache[i]; return count; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Bit Manipulation II]]></title>
    <url>%2F2016%2F12%2F25%2FLeetCode-Bit-Manipulation-II%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：342. Power of Four371. Sum of Two Integers389. Find the Difference393. UTF-8 Validation397. Integer Replacement401. Binary Watch405. Convert a Number to Hexadecimal421. Maximum XOR of Two Numbers in an Array461. Hamming Distance477. Total Hamming Distance 342. Power of Four解题思路 简单题，不多说了； 代码1234567891011121314151617class Solution&#123; public: bool isPowerOfFour(int num) &#123; int temp = 1; if(num == 0 || num &lt; 0) return false; for(int i = 0; i &lt; 16; ++i) &#123; if((num&amp;temp) == num) return true; temp &lt;&lt;= 2; &#125; return false; &#125;&#125;; 371. Sum of Two Integers解题思路 使用^运算求取加和结果，使用&amp;运算求取进位结果，循环调用即可； 代码123456789101112131415161718class Solution&#123; public: int getSum(int a, int b) &#123; int carry = a&amp;b; int res = a ^ b; int temp; while(carry) &#123; carry &lt;&lt;= 1; temp = res &amp; carry; res = res ^ carry; carry = temp; &#125; return res; &#125;&#125;; 389. Find the Difference解题思路 简单题，不多说了； 代码1234567891011121314151617181920class Solution&#123; public: char findTheDifference(string s, string t) &#123; char res; vector&lt;int&gt; c1(26, 0); vector&lt;int&gt; c2(26, 0); for(auto const c : s) c1[c - 'a']++; for(auto const c : t) &#123; if(++c2[c - 'a'] &gt; c1[c - 'a']) &#123; res = c; &#125; &#125; return res; &#125;&#125;; 393. UTF-8 Validation解题思路 这个题目的难点在于理解题目。。。 代码123456789101112131415161718192021222324252627282930class Solution&#123; public: bool validUtf8(vector&lt;int&gt; &amp;data) &#123; int len = data.size(); int count = 0; for(int i = 0; i &lt; len; ++i) &#123; if(count == 0) &#123; if(data[i]&gt;&gt;5 == 0b110) count = 1; else if(data[i]&gt;&gt;4 == 0b1110) count = 2; else if(data[i]&gt;&gt;3 == 0b11110) count = 3; else if(data[i]&gt;&gt;7) return false; &#125; else &#123; if(data[i]&gt;&gt;6 != 0b10) return false; count--; &#125; &#125; return count == 0; &#125;&#125;; 397. Integer Replacement解题思路 如果最后两位是11，则加法操作比较好；反之则减法操作比较好； 3是一个特例，如果是3的话，需要减法操作； 如果是最大整数，则因为无法加法操作，所以需要在最前边进行设置判断； 代码123456789101112131415161718192021222324class Solution&#123; public: int integerReplacement(int n) &#123; if(n == 0x7fffffff) return 32; int count = 0; while(n &gt; 1) &#123; count++; if(n &amp; 1) &#123; if(n == 3 || (n&amp;2) == 0) n--; else n++; &#125; else n &gt;&gt;= 1; &#125; return count; &#125;&#125;; 401. Binary Watch结题思路 这道题主要是一道递归的题目，递归解决即可； 需要注意的是hours和minutes本身的范围，以及输出的格式； 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution&#123; public: vector&lt;string&gt; readBinaryWatch(int num) &#123; vector&lt;string&gt; res; int hours = 0; int minutes = 0; solve(res, num, hours, minutes, 0); return res; &#125; void solve(vector&lt;string&gt; &amp;res, int count, int &amp;hours, int &amp;minutes, int cur) &#123; if(hours &gt; 11 || minutes &gt; 59) return; if(count == 0) &#123; string temp = ""; if(hours &lt; 10) &#123; temp += hours - 0 + '0'; &#125; else &#123; temp += hours / 10 + '0'; temp += hours % 10 + '0'; &#125; temp += ":"; temp += minutes / 10 + '0'; temp += minutes % 10 + '0'; res.push_back(temp); &#125; else &#123; for(int i = cur; i &lt; 10; ++i) &#123; if(i &lt; 6 &amp;&amp; (minutes&amp;(1&lt;&lt;i)) == 0) &#123; minutes += (1&lt;&lt;i); solve(res, count-1, hours, minutes, i+1); minutes -= (1&lt;&lt;i); &#125; if(i &gt;= 6 &amp;&amp; (hours&amp;(1&lt;&lt;(i-6))) == 0) &#123; hours += (1&lt;&lt;(i-6)); solve(res, count-1, hours, minutes, i+1); hours -= (1&lt;&lt;(i-6)); &#125; &#125; &#125; &#125;&#125;; 405. Convert a Number to Hexadecimal解题思路 四位四位地去转换就可以了，注意(-1&gt;&gt;4)一直都是-1； 代码12345678910111213141516class Solution &#123;public: string toHex(int num) &#123; if(num == 0) return "0"; string res = ""; vector&lt;char&gt; hex= &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; while(num != 0 &amp;&amp; res.size() &lt; 8) &#123; res = hex[num&amp;15] + res; num &gt;&gt;= 4; &#125; return res; &#125;&#125;; 421. Maximum XOR of Two Numbers in an Array解题思路 计算最大异或值，从最高位开始计算，使用set保存从高位开始前1,2,3…位的数据； 每次使用左移&lt;&lt;更新res，使用^判断最后一位是0还是1； 代码12345678910111213141516171819202122232425class Solution&#123; public: int findMaximumXOR(vector&lt;int&gt; &amp;nums) &#123; int res = 0; unordered_set&lt;int&gt; pre; for(int i = 31; i &gt;= 0; --i) &#123; res &lt;&lt;= 1; pre.clear(); for(auto const num : nums) pre.insert(num&gt;&gt;i); for(auto const p : pre) &#123; if(pre.find((res^1)^p) != pre.end()) &#123; res++; break; &#125; &#125; &#125; return res; &#125;&#125;; 461. Hamming Distance解题思路 简单题，用到了temp&amp;(temp-1)； 代码123456789101112131415class Solution&#123; public: int hammingDistance(int x, int y) &#123; int res = 0; int temp = x^y; while(temp) &#123; temp = temp&amp;(temp-1); res++; &#125; return res; &#125;&#125;; 477. Total Hamming Distance解题思路 每一位只有为1才会产生汉明距离，总的汉明距离和为1的个数×0的个数； 代码123456789101112131415161718192021class Solution&#123; public: int totalHammingDistance(vector&lt;int&gt; &amp;nums) &#123; int res = 0; int len = nums.size(); int count = 0; for(int i = 0; i &lt; 32; ++i) &#123; count = 0; for(int j = 0; j &lt; nums.size(); ++i) &#123; if((nums[j]&gt;&gt;i)&amp;1) count++; &#125; res += (len - count) * count; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Bit Manipulation I]]></title>
    <url>%2F2016%2F12%2F24%2FLeetCode-Bit-Manipulation-I%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：78. Subsets136. Single Number137. Single Number II169. Majority Element187. Repeated DNA Sequences190. Reverse Bits191. Number of 1 Bits201. Bitwise AND of Numbers Range231. Power of Two260. Single Number III268. Missing Number318. Maximum Product of Word Lengths338. Counting Bits 78. Subsets解题思路 使用bitmap表示：000-&gt;[], 001-&gt;[1], 010-&gt;[2], 011-&gt;[1, 2], 100-&gt;[3], 101-&gt;[1, 3], 110-&gt;[2, 3], 111-&gt;[1, 2, 3] 代码1234567891011121314151617181920212223class Solution&#123; public: vector&lt;vector&lt;int&gt; &gt; subsets(vector&lt;int&gt; &amp;nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; temp; int len = nums.size(); for(int i = 0; i &lt; (1&lt;&lt;len); ++i) &#123; temp.clear(); int index = 0; while(i &gt;= (1&lt;&lt;index)) &#123; if(i &amp; (1&lt;&lt;index)) temp.push_back(nums[index]); index++; &#125; res.push_back(temp); &#125; return res; &#125;&#125;; 136. Single Number解题思路 这道题用bitmap，使用异或操作，相同的数都会消去，最后只剩下Single Number； 代码12345678910111213class Solution&#123; public: int singleNumber(vector&lt;int&gt; &amp;nums) &#123; int res = 0; for(int i = 0; i &lt; nums.size(); i++) &#123; res ^= nums[i]; &#125; return res; &#125;&#125;; 137. Single Number II解题思路 仍然使用位运算，使用ones、twos两位表示每一位的累加和； 对应循环关系为：00-&gt;01-&gt;10-&gt;00 即 0-&gt;1-&gt;2-&gt;0; 最后返回ones中的结果即可； 如果重复的个数是5的话，就需要三位数来表示：000-&gt;001-&gt;010-&gt;011-&gt;100-&gt;000; 代码1234567891011121314class Solution&#123; public: int singleNumber(vector&lt;int&gt; &amp;nums) &#123; int ones = 0, twos = 0; for(int i = 0; i &lt; nums.size(); ++i) &#123; ones = (ones ^ nums[i]) &amp; ~twos; twos = (twos ^ nums[i]) &amp; ~ones; &#125; return ones; &#125;&#125;; 169. Majority Element解题思路 思路I：对数组进行排序，然后取中位数就可以了； 思路II：遍历数组，初始化一个res，维持一个count计数变量，只有count减为零的时候才更新res，因为众数超过总数的一半，所以最后必然能够转换到res中； 代码12345678910class Solution&#123; public: int majorityElement(vector&lt;int&gt; &amp;nums) &#123; sort(nums.begin(), nums.end()); int len = nums.size(); return nums[len/2]; &#125;&#125;; 12345678910111213141516171819202122class Solution&#123; public: int majorityElement(vector&lt;int&gt; &amp;nums) &#123; int res = nums[0]; int count = 1; for(int i = 1; i &lt; nums.size(); ++i) &#123; if(count == 0) &#123; count++; res = nums[i]; &#125; else if(nums[i] == res) count++; else count--; &#125; return res; &#125;&#125;; 187. Repeated DNA Sequences解题思路 字符串中只包含了A, C, G, T四种字符，这四种字符的不同进制表示如下所示：16进制：0X41, 0X43, 0X47, 0X5410进制：65， 67， 71， 848进制：0101, 0103, 0107, 0124; 观察上述进制规律，可以发现如果用二进制进行表示，其最后三位分别为001， 011， 111， 100； 所以我们可以使用一个int类型整数保存包含10个字符的子串，一共需要30位，int有32位，正好满足要求； 然后使用一个map进行映射保存，遍历所有的子串有重复的就进行保存即可； 这里推荐使用unordered_map而不是map，unordered_map不会进行排序，效率更高； 代码12345678910111213141516class Solution&#123; public: vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123; unordered_map&lt;int, int&gt; m; vector&lt;string&gt; res; int temp = 0; for(int i = 0; i &lt; s.size(); ++i) &#123; if(m[temp = temp &lt;&lt; 3 &amp; 0x3FFFFFFF | s[i] &amp; 7]++ == 1) res.push_back(s.substr(i-9, 10)); &#125; return res; &#125;&#125;; 190. Reverse Bits解题思路 这道题就简单了，移位操作32次就可以了； 代码12345678910111213141516class Solution&#123; public: uint32_t reverseBits(uint32_t n) &#123; uint32_t res = 0; for(int i = 0; i &lt; 32; ++i) &#123; res &lt;&lt;= 1; int temp = n &amp; 1; res = res | temp; n &gt;&gt;= 1; &#125; return res; &#125;&#125;; 191. Number of 1 Bits解题思路 这道题不多说了； 代码123456789101112131415class Solution&#123; public: int hammingWeight(uint32_t n) &#123; int res = 0; while(n) &#123; if(n &amp; 1) res++; n &gt;&gt;= 1; &#125; return res; &#125;&#125;; 201. Bitwise AND of Numbers Range解题思路 首先如果n &gt; m，则最后一位必定是0，取fun(m&gt;&gt;1, n&gt;&gt;1)&lt;&lt;1作为最终结果； 沿用这种思路，迭代去求取即可； 代码12345678class Solution&#123; public: int rangeBitwiseAnd(int m, int n) &#123; return n &gt; m ? rangeBitwiseAnd(m&gt;&gt;1, n&gt;&gt;1) &lt;&lt; 1 : m; &#125;&#125;; 231. Power of Two解题思路 这里注意负数和零都返回false； 代码12345678910111213class Solution&#123; public: bool isPowerOfTwo(int n) &#123; if(n == 0 || n&amp;(1&lt;&lt;31)) return false; for(int i = 0; i &lt; 32; ++i) if((n &amp; (1&lt;&lt;i)) == n) return true; return false; &#125;&#125;; 260. Single Number III解题思路I 首先对数组执行sort，然后两个两个地去找； 代码1234567891011121314151617181920212223class Solution&#123; public: vector&lt;int&gt; singleNumber(vector&lt;int&gt; &amp;nums) &#123; vector&lt;int&gt; res; if(nums.size() == 2) &#123; res.push_back(nums[0]); res.push_back(nums[1]); return res; &#125; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); i++) &#123; if(nums[i] == nums[i+1]) i++; else res.push_back(nums[i]); &#125; return res; &#125;&#125;; 解题思路II 假设结果所求为a和b两个数，对数组中所有的数据执行异或操作，则可以得到所求两个数的异或结果，假设为a^b； 利用位运算获取a^b中为1的设置位，表示a和b在这一设置位上一个是1，一个是0，可以把a和b区分开来，这里我们选择最右边为1的那位； 再次对数组进行遍历异或，使用设置为进行区分，则可以得到所求结果； 使用diff &amp;= -diff可以获取diff中最右边为零的设置位，diff &amp;= ~(diff - 1)同样也可以，这里mark学习一下！ 代码1234567891011121314151617181920class Solution&#123; public: vector&lt;int&gt; singleNumber(vector&lt;int&gt; &amp;nums) &#123; vector&lt;int&gt; res(2, 0); int temp = 0; for(int i = 0; i &lt; nums.size(); ++i) temp ^= nums[i]; temp &amp;= -temp; for(int i = 0; i &lt; nums.size(); ++i) &#123; if(temp &amp; nums[i]) res[0] ^= nums[i]; else res[1] ^= nums[i]; &#125; return res; &#125;&#125;; 268. Missing Number解题思路 方法一：先sort然后用二分法去找； 方法二：使用异或，同时异或下标和数组值，存在的就会消去； 方法三：使用sum求和，然后作减法即可； 代码123456789101112131415161718192021//方法一class Solution&#123; public: int missingNumber(vector&lt;int&gt; &amp;nums) &#123; sort(nums.begin(), nums.end()); int left = 0; int right = nums.size(); int mid = (left + right) / 2; while(left &lt; right) &#123; mid = (left + right) / 2; if(mid &lt; nums[mid]) right = mid; else left = mid+1; &#125; return left; &#125;&#125;; 123456789101112131415//方法二class Solution&#123; public: int missingNumber(vector&lt;int&gt; &amp;nums) &#123; int res = nums.size(); for(int i = 0; i &lt; nums.size(); ++i) &#123; res ^= nums[i]; res ^= i; &#125; return res; &#125;&#125;; 1234567891011121314//方法三class Solution&#123; public: int missingNumber(vector&lt;int&gt; &amp;nums) &#123; int res = 0; int len = nums.size(); res = len * (len + 1) / 2; for(int i = 0; i &lt; len; ++i) res -= nums[i]; return res; &#125;&#125;; 318. Maximum Product of Word Lengths解题思路 对于每一个string，使用int的后26为记录string中字符的存在与否； 建立一个vector保存所有字符串的字符信息，使用&amp;判断是否有重复的字符； 代码12345678910111213141516171819202122232425262728class Solution&#123; public: int maxProduct(vector&lt;string&gt; &amp;words) &#123; int res = 0; int len = words.size(); vector&lt;int&gt; nums(len, 0); for(int i = 0; i &lt; len; ++i) &#123; for(int j = 0; j &lt; words[i].size(); ++j) &#123; nums[i] |= 1&lt;&lt;(words[i][j] - 'a'); &#125; &#125; for(int i = 0; i &lt; len; ++i) &#123; for(int j = i+1; j &lt; len; ++j) &#123; if(nums[i] &amp; nums[j]) continue; else res = max(res, int(words[i].size() * words[j].size())); &#125; &#125; return res; &#125;&#125;; 338. Counting Bits解题思路 Bit Counts: 0-&gt;01, 01-&gt;0112, 0112-&gt;01121223, 01121223-&gt;0112122312232334; 参照上述规律使用DP进行求解即可； 代码1234567891011121314151617181920class Solution&#123; public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; res(num+1, 0); int start = 0; int end = 0; for(int i = 1; i &lt; num+1; ++i) &#123; if(start &gt; end) &#123; start = 0; end = i-1; &#125; res[i] = res[start++] + 1; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Combinations]]></title>
    <url>%2F2016%2F12%2F22%2FLeetCode-Combinations%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：17. Letter Combinations of a Phone Number31. Next Permutation39. Combination Sum40. Combination Sum II46. Permutations47. Permutations II60. Permutation Sequence77. Combinations216. Combination Sum III377. Combination Sum IV 17. Letter Combinations of a Phone Number解题思路 加入现在输入是23，则首先把2对应的字符放到结果res中，结果res为[a, b, c]; 3所包含的字符有d, e, f则首先把res的首项取出来，分别和d, e, f组合之后再次放进res中，此时为[b, c, ad, ae, af]; 不断地完成如上操作即可； 代码123456789101112131415161718192021222324252627class Solution&#123; public: vector&lt;string&gt; letterCombinations(string digits) &#123; string str[10] = &#123;" ", " ", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"&#125;; int len[10] = &#123;1, 1, 3, 3, 3, 3, 3, 4, 3, 4&#125;; vector&lt;string&gt; res; if(digits.size() == 0) return res; res.push_back(""); for(int i = 0; i &lt; digits.size(); ++i) &#123; int sz = res.size();//注意这里要保存res的大小，以便下面循环的进行 for(int j = 0; j &lt; sz; ++j) &#123; string temp = res[0]; res.erase(res.begin()); for(int k = 0; k &lt; len[digits[i] - '0']; ++k) &#123; res.push_back(temp + str[digits[i] - '0'][k]); &#125; &#125; &#125; return res; &#125;&#125;; 31. Next Permutation解题思路 终极状态是321这种呈递减顺序排布的，也是数字组合的最大值； 首先找到第一个破坏上述规则的数，其位置记为start； 将start对应元素与从尾部开始第一个大于它的元素交换； 对于start后面的元素进行一个逆序处理即可； 详细分析可以参考LeetCode的官方Solution； 代码123456789101112131415161718192021222324252627282930class Solution&#123; public: void nextPermutation(vector&lt;int&gt; &amp;nums) &#123; int start = -1; for(int i = nums.size() - 2; i &gt;= 0; --i) &#123; if(nums[i] &lt; nums[i+1]) &#123; start = i; break; &#125; &#125; if(start == -1) &#123; reverse(nums.begin(), nums.end()); return; &#125; for(int i = nums.size()-1; i &gt; start; --i) &#123; if(nums[start] &lt; nums[i]) &#123; swap(nums[start], nums[i]); break; &#125; &#125; reverse(nums.begin()+start+1, nums.end()); &#125;&#125;; 39. Combination Sum解题思路 使用回溯和递归，不断地去找就好； 注意给出的数据均为正数，且没有重复的数值； 代码1234567891011121314151617181920212223242526272829class Solution&#123; public: vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; temp; sort(candidates.begin(), candidates.end()); solve(res, temp, candidates, 0, target, 0); return res; &#125; void solve(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;temp, vector&lt;int&gt; candidates, int cur, int target, int sum) &#123; if(sum == target) &#123; res.push_back(temp); return; &#125; for(int i = cur; i &lt; candidates.size(); ++i) &#123; if(sum + candidates[i] &lt;= target) &#123; temp.push_back(candidates[i]); solve(res, temp, candidates, i, target, sum+candidates[i]); temp.pop_back(); &#125; &#125; &#125;&#125;; 40. Combination Sum II解题思路 这一题跟上面39题类似，注意这里给出的数据中包含重复的数值； 为了避免重复解，对candidates进行排序，重复数值只对第一个进行迭代求解，其余的跳过； 代码12345678910111213141516171819202122232425262728293031class Solution&#123; public: vector&lt;vector&lt;int&gt; &gt; combinationSum2(vector&lt;int&gt; &amp;candidates, int target) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; temp; sort(candidates.begin(), candidates.end()); solve(res, temp, candidates, target, 0, 0, candidates.size()); return res; &#125; void solve(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;temp, vector&lt;int&gt; candidates, int target, int cur, int sum, int len) &#123; if(sum == target) &#123; res.push_back(temp); return; &#125; for(int i = cur; i &lt; len; ++i) &#123; if(sum + candidates[i] &lt;= target) &#123; temp.push_back(candidates[i]); solve(res, temp, candidates, target, i+1, sum+candidates[i], len); temp.pop_back(); while(i+1 &lt; len &amp;&amp; candidates[i] == candidates[i+1]) //如果下一个值等于当前值，则跳过， i++; &#125; &#125; &#125;&#125;; 46. Permutations解题思路I 这一题仍然是排列组合，但是不同的是这一次不看数值的大小，直接按照排列组合的顺序输出； 代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution&#123; public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; temp; int size = 1; int i, j; res.push_back(nums); int len = nums.size(); if(len == 1) return res; for(int i = 0; i &lt; len; ++i) &#123; size = size * (i+1); temp.push_back(i+1); &#125; size = size-1; while(size--) &#123; i = j = len - 1; while(temp[i-1] &gt;= temp[i]) i--; while(temp[j] &lt;= temp[i-1]) j--; swap(temp[i-1], temp[j]); swap(nums[i-1], nums[j]); j = len - 1; while(i &lt; j) &#123; swap(temp[i], temp[j]); swap(nums[i++], nums[j--]); &#125; res.push_back(nums); &#125; return res; &#125;&#125;; 解题思路II 也可以使用dfs进行求解，遍历每一种不同的组合方式； 代码123456789101112131415161718192021222324class Solution&#123; public: vector&lt;vector&lt;int&gt; &gt; permute(vector&lt;int&gt; &amp;nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; dfs(res, nums, 0); return res; &#125; void dfs(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;nums, int cur) &#123; if(cur &gt;= nums.size()) &#123; res.push_back(nums); return; &#125; for(int i = cur; i &lt; nums.size(); ++i) &#123; swap(nums[cur], nums[i]); dfs(res, nums, cur+1); swap(nums[cur], nums[i]); &#125; &#125;&#125;; 47. Permutations II解题思路I 首先使用sort函数整理数据，然后按照next premutation的算法不断进行求取； 这里需要注意的是，交换过程中，如果相等则不进行交换，使用&lt;=过滤掉重复的答案； 代码123456789101112131415161718192021222324252627282930class Solution&#123; public: vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; sort(nums.begin(), nums.end()); res.push_back(nums); int len = nums.size(); int i, j; if(len == 1) return res; while(1) &#123; i = j = len - 1; while(nums[i] &lt;= nums[i-1] &amp;&amp; i &gt;= 0) i--; if(i == -1 || i == 0) break; while(nums[j] &lt;= nums[i-1]) j--; swap(nums[i-1], nums[j]); j = len - 1; while(i &lt; j) swap(nums[i++], nums[j--]); res.push_back(nums); &#125; return res; &#125;&#125;; 解题思路II 这里借鉴了LeetCode Discuss中的思路，仍然采用的是dfs搜索的方式去遍历每一种可能的结果； 不同的是，针对本题没有回溯操作，nums作为参数前面并没有加&amp;号； 这个思路搞了好久没有弄清楚，有大神懂的求告知； 代码1234567891011121314151617181920212223242526class Solution&#123; public: vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp; nums) &#123; vector&lt;vector&lt;int&gt; &gt; res; sort(nums.begin(), nums.end()); dfs(res, nums, 0); return res; &#125; void dfs(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; nums, int cur) &#123; if(cur == nums.size()-1) &#123; res.push_back(nums); return; &#125; for(int i = cur; i &lt; nums.size(); ++i) &#123; if(i != cur &amp;&amp; nums[cur] == nums[i]) continue; swap(nums[cur], nums[i]); dfs(res, nums, cur+1); &#125; &#125;&#125;; 60. Permutation Sequence解题思路 如果不断调用next permutation算法，则肯定会超时； 我们一位一位的计算，一共有n!种序列，第一位有n中选择，每种都对应(n-1)!种序列，利用这种关系不断计算每一位的选择即可； 代码123456789101112131415161718192021222324class Solution&#123; public: string getPermutation(int n, int k) &#123; string res = ""; int nums[n]; nums[0] = 1; for(int i = 1; i &lt; n; ++i) nums[i] = i * nums[i-1]; vector&lt;int&gt; index; for(int i = 1; i &lt;= n; ++i) index.push_back(i); k = k - 1; for(int i = n-1; i &gt;= 0; --i) &#123; int temp = k / nums[i]; res += *(index.begin() + temp) + '0'; index.erase(index.begin() + temp); k = k % nums[i]; &#125; return res; &#125;&#125;; 77. Combinations解题思路 这个题直接用递归和回溯就解决了； 代码1234567891011121314151617181920212223class Solution&#123; public: vector&lt;vector&lt;int&gt; &gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; temp; pushBack(res, temp, 1, k, n, 0); return res; &#125; void pushBack(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;temp, int next, int k, int n, int count) &#123; if(count == k) res.push_back(temp); for(int i = next; i &lt;= n; ++i) &#123; temp.push_back(i); pushBack(res, temp, i+1, k, n, count+1); temp.erase(temp.end()-1); &#125; &#125;&#125;; 216. Combination Sum III解题思路 这道题也是使用递归和回溯就可以解决了； 代码12345678910111213141516171819202122232425262728293031323334class Solution&#123; public: vector&lt;vector&lt;int&gt; &gt; combinationSum3(int k, int n) &#123; vector&lt;vector&lt;int&gt; &gt; res; vector&lt;int&gt; temp; dfs(res, temp, k, n, 1, 0, 0); return res; &#125; void dfs(vector&lt;vector&lt;int&gt; &gt; &amp;res, vector&lt;int&gt; &amp;temp, int k, int n, int cur, int count, int sum) &#123; if(count == k) &#123; if(sum == n) &#123; res.push_back(temp); return; &#125; else return; &#125; if(cur &gt; 9) return; for(int i = cur; i &lt; 10; ++i) &#123; temp.push_back(i); dfs(res, temp, k, n, i+1, count+1, sum+i); temp.erase(temp.end()-1); &#125; &#125;&#125;; 377. Combination Sum IV解题思路I 使用搜索算法进行迭代，TLE超时！ 代码1234567891011121314151617181920212223class Solution&#123; public: int combinationSum4(vector&lt;int&gt; &amp;nums, int target) &#123; int res = 0; dfs(res, nums, target, 0); return res; &#125; void dfs(int &amp;res, vector&lt;int&gt; &amp;nums, int target, int sum) &#123; if(sum == target) &#123; res++; return; &#125; for(int i = 0; i &lt; nums.size(); ++i) &#123; if(sum + nums[i] &lt;= target) dfs(res, nums, target, sum+nums[i]); &#125; &#125;&#125;; 解题思路II 如果nums包含1， 2， 3三个数字，Sum(nums, 4) = Sum(nums, 4-1) + Sum(nums, 4-2) + Sum(nums, 4-3); 如果根据上述等式进行递归迭代求解的话，超时TLE！ 根据公式的特性，使用DP进行求解，dp[i] = Sum(nums, i)，dp[0]=1初始化即可； 代码I12345678910111213141516171819202122class Solution&#123; public: int combinationSum4(vector&lt;int&gt; &amp;nums, int target) &#123; vector&lt;int&gt; dp(target+1, -1); dp[0] = 1; return solve(dp, nums, target); &#125; int solve(vector&lt;int&gt; &amp;dp, vector&lt;int&gt; &amp;nums, int target) &#123; if(dp[target] != -1) return dp[target]; int res = 0; for(int i = 0; i &lt; nums.size(); ++i) &#123; if(target &gt;= nums[i]) res += solve(dp, nums, target - nums[i]); &#125; return dp[target] = res; &#125;&#125;; 代码II123456789101112131415161718class Solution&#123; public: int combinationSum4(vector&lt;int&gt; &amp;nums, int target) &#123; vector&lt;int&gt; dp(target+1, 0); dp[0] = 1; for(int i = 1; i &lt;= target; ++i) &#123; for(int j = 0; j &lt; nums.size(); ++j) &#123; if(i &gt;= nums[j]) dp[i] += dp[i - nums[j]]; &#125; &#125; return dp[target]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Combination</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Substring and Subarray]]></title>
    <url>%2F2016%2F12%2F20%2FLeetCode-Substring-and-Subarray%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：30. Substring with Concatenation of All Words76. Minimum Window Substring209. Minimum Size Subarray Sum239. Sliding Window Maximum 30. Substring with Concatenation of All Words解题思路 首先构建一个map&lt;string, int&gt;保存words中字符串，每个对应int值为1； 然后对搜索字符串进行遍历，将等长的子字符串保存在map&lt;string, int&gt;中； 如果有新的子字符串或者相同的子字符串数量超过words所给出的数量，则判定失败。 代码123456789101112131415161718192021222324252627282930class Solution&#123; public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt; &amp;words) &#123; int i, j; int wordNum = words.size(); int wordLen = words[0].size(); int startLen = s.size() - wordLen * wordNum; map&lt;string, int&gt; word; for(int i = 0; i &lt; wordNum; ++i) ++word[words[i]]; map&lt;string, int&gt; count; vector&lt;int&gt; res; string temp; for(i = 0; i &lt;= startLen; ++i) &#123; count.clear(); for(j = 0; j &lt; wordNum; ++j) &#123; temp = s.substr(i + wordLen * j, wordLen); if(word.find(temp) == word.end() || ++count[temp] &gt; word[temp]) break; &#125; if(j == wordNum) res.push_back(i); &#125; return res; &#125;&#125;; 76. Minimum Window Substring解题思路 使用一个vector&lt;int&gt; ch(128, 0)保存字符的数据信息； 正如题目描述，需要维持一个窗口，该窗口能够覆盖t中的字符； 计算过程就是窗口的移动过程，需要不断地从窗口头部去掉字符元素，然后在尾部添加新的字符，迭代计算窗口的宽度等数值特征； 代码123456789101112131415161718192021222324252627282930class Solution&#123; public: string minWindow(string s, string t) &#123; vector&lt;int&gt; ch(128, 0); for(int i = 0; i &lt; t.size(); ++i) ch[t[i]]++; int count = t.size(); int begin, end, head, resLen; begin = end = head = 0; resLen = s.size() + 1; while(end &lt; s.size()) &#123; if(ch[s[end++]]-- &gt; 0) count--; while(count == 0) &#123; if(end - begin &lt; resLen) &#123; resLen = end - begin; head = begin; &#125; if(ch[s[begin++]]++ == 0) count++; &#125; &#125; return resLen==s.size()+1 ? "" : s.substr(head, resLen); &#125;&#125;; 209. Minimum Size Subarray Sum解题思路 维持一个窗口，不断更新子数组的长度； 代码1234567891011121314151617181920212223class Solution&#123; public: int minSubArrayLen(int s, vector&lt;int&gt; &amp;nums) &#123; int res, count, begin, end; count = begin = end = 0; res = nums.size() + 1; while(end &lt; nums.size()) &#123; count += nums[end++]; while(count &gt;= s) &#123; if(end - begin &lt; res) &#123; res = end - begin; &#125; count -= nums[begin++]; &#125; &#125; return res == nums.size()+1 ? 0 : res; &#125;&#125;; 239. Sliding Window Maximum解题思路I 为了维持窗口，每次向左添加一位，更新最大值； temp[j] = max(nums[j-i], temp[j])其中i表示此时窗口的大小+1; 这种方法效率较低，勉强AC； 代码12345678910111213141516171819202122class Solution&#123; public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; if(k == 0) return nums; int len = nums.size(); vector&lt;int&gt; temp = nums; for(int i = 1; i &lt; k; ++i) &#123; for(int j = i; j &lt; len; ++j) &#123; temp[j] = max(nums[j-i], temp[j]); &#125; &#125; vector&lt;int&gt; res; for(int i = k-1; i &lt; len; ++i) res.push_back(temp[i]); return res; &#125;&#125;; 解题思路II 使用deque维持一个双向队列，保存加入其中数据的下标； 对数组进行遍历，在deque不为空的情况下，当遍历到下标i的时候，删掉超出范围k的数据，即下标小于i-k+1的数据； 每次加入一个数据nums[i]的时候，删除比他还要小的数据，因为在整个作用范围内，小于nums[i]的数都不可能成为最大的数据； 上述操作维持deque是一个降序的队列，取窗口最大值只需要取deque的头部数据就可以了。 代码12345678910111213141516171819202122class Solution&#123; public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; res; if(k == 0) return res; deque&lt;int&gt; temp; for(int i = 0; i &lt; nums.size(); ++i) &#123; while(!temp.empty() &amp;&amp; temp.front() &lt; i-k+1) temp.pop_front(); while(!temp.empty() &amp;&amp; nums[temp.back()] &lt; nums[i]) temp.pop_back(); temp.push_back(i); if(i &gt;= k - 1) res.push_back(nums[temp.front()]); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Substring</tag>
        <tag>Subarray</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Partition算法剖析]]></title>
    <url>%2F2016%2F12%2F18%2FPartition%E7%AE%97%E6%B3%95%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[partition算法从字面上就非常好理解，就是分割算法嘛！简单讲就是可以把数组按照一定的分成几个部分，其中最常见的就是快速排序中使用的partition算法，这是一个二分partition算法，将整个数组分解为小于某个数和大于某个数的两个部分，然后递归进行排序算法。上述只是二分partition算法，我们还会使用三分partition算法，三分partition也有这非常重要的应用。往往我们更多的关注点是快速排序算法等各种算法，以及时间复杂度等这些东西，今天我们专门讨论一下partition分割算法的一些应用。 二分 Partition算法二分partition算法是我们最常使用的，尤其在快速排序中使用最为常见。常见的partition算法有如下两种实现思路： 思路I算法思路 使用第一个数组元素作为枢轴点，即为pivot； 使用一个指针去扫描整个数组，凡是小于pivot的全部放到数组左端； 最后讲pivot放到数组中间的位置，pivot左边全部都是小于他的数字，右边反之，最后返回pivot的位置信息； 代码123456789101112int partition(vector&lt;int&gt; &amp;nums, int begin, int end)&#123; int pivot = nums[begin]; int pos = begin; for(int i = begin+1; i &lt; end; ++i) &#123; if(nums[i] &lt;= pivot) swap(nums[++pos],nums[i]); &#125; swap(nums[pos], nums[begin]); return pos;&#125; 思路II算法思路 就如快速排序中最常使用的那样，使用两个指针分别从头部和尾部进行扫描，头部遇到大于pivot的数和尾部遇到小于pivot的数进行交换； 使用了两个指针，效率更高一点； 代码12345678910111213int partition(vector&lt;int&gt; &amp;nums, int begin, int end)&#123; int pivot = nums[begin]; while(begin &lt; end) &#123; while(begin &lt; end &amp;&amp; nums[--end] &gt;= pivot); nums[begin] = nums[end]; while(begin &lt; end &amp;&amp; nums[++begin] &lt;= pivot); nums[end] = nums[begin]; &#125; nums[begin] = pivot; return begin;&#125; 二分partition算法应用快速排序算法经典的快速排序算法，直接上代码： 代码123456789void quickSort(vector&lt;int&gt; &amp;nums, int begin, int end)&#123; if(end - begin &lt;= 1) return; int mid = partition(nums, begin, end); quickSort(nums, begin, mid); quickSort(nums, mid, end);&#125; 数组第K大数值查询这也是LeetCode中的一道例题，非常适合使用partition算法进行解决，问题链接215. Kth Largest Element in an Array！ 解题思路 首先可以通过排序进行求解，简单暴力； 不断使用partition算法进行迭代查找； 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution&#123; public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) &#123; int len = nums.size(); int res = 0; int left = 0; int right = len; while(left &lt; right) &#123; int pos = partition(nums, left, right); if(pos == len-k) &#123; res = nums[pos]; break; &#125; else if(pos &lt; len-k) left = pos+1; else right = pos; &#125; return res; &#125; int partition(vector&lt;int&gt; &amp;nums, int begin, int end) &#123; int pivot = nums[begin]; while(begin &lt; end) &#123; while(begin &lt; end &amp;&amp; nums[--end] &gt;= pivot); nums[begin] = nums[end]; while(begin &lt; end &amp;&amp; nums[++begin] &lt;= pivot); nums[end] = nums[begin]; &#125; nums[begin] = pivot; return begin; &#125;&#125;; 三分paitition算法三分partition算法，顾名思义，也就是将数组按照规则分为三个部分，比如非常经典的国旗问题Dutch national flag problem，就是要给定的红、白、蓝三色随机颜色小球按照红、白、蓝的顺序进行排序，利用partition算法，使用一个指针进行扫描，红色的小球就用swap()放到左边，白色的保持位置不变，蓝色的同样使用swap()放到右边，最后就得到要求的序列了。 Dutch National Flag ProblemLeetCode中有恰好有这么一个题：75. Sort Colors！ 解题思路 就使用三分partition算法进行求解就可以了！ 代码12345678910111213141516171819202122232425262728class Solution&#123; public: void sortColors(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); int left = 0; int right = len - 1; for(int i = 0; i &lt; len; ++i) &#123; if(i &gt; right) break; if(nums[i] == 1) continue; else if(nums[i] == 0) &#123; swap(nums[i], nums[left]); left++; &#125; else &#123; swap(nums[i], nums[right]); right--; i--; &#125; &#125; &#125;&#125;; 进阶应用LeetCode 324. Wiggle Sort IILeetCode中的第324题中也同样可以使用三分partition算法，该题的discuss中，StefanPochmann大神提出一种O(n)+O(1)复杂度的高效算法，原链接为：324. Wiggle Sort IIDiscuss！ 解题思路 使用partition算法获取数组的中位数，这个思路同找第k大的数，这里作者用了c++中的nth_element()函数； 使用宏定义的方式#define A(i) nums[(1+2*(i)) % (n|1)]，A()的前半部分对应nums中下标为奇数的元素，后半部分为偶数，即奇数 + 偶数； 使用三分partition算法对A()进行排序，使其前半部分大于后半部分，即在nums中奇数部分 &gt; 偶数部分； 最终达到的效果为 0 &lt; 1 &gt; 2 &lt; 3 &gt; 4 &lt; 5 … 注意这里需要的是奇数&gt;偶数，所以进行partition的时候大于pivot枢轴值的要放到前面； #define A(i) nums[(1+2*(i)) % (n|1)]的作用如下所示：假设有0, 1, 2, 3, 4, 5, 6, 7, 8, 9共10个数据，则使用A()进行映射之后的结果为：A(0) -&gt; nums[1].A(1) -&gt; nums[3].A(2) -&gt; nums[5].A(3) -&gt; nums[7].A(4) -&gt; nums[9].A(5) -&gt; nums[0].A(6) -&gt; nums[2].A(7) -&gt; nums[4].A(8) -&gt; nums[6].A(9) -&gt; nums[8]. 代码12345678910111213141516171819202122232425262728class Solution&#123; public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // Find a median. auto midptr = nums.begin() + n / 2; nth_element(nums.begin(), midptr, nums.end()); int mid = *midptr; // Index-rewiring. #define A(i) nums[(1+2*(i)) % (n|1)] // 3-way-partition-to-wiggly in O(n) time with O(1) space. int i = 0, j = 0, k = n - 1; while (j &lt;= k) &#123; if (A(j) &gt; mid) swap(A(i++), A(j++)); else if (A(j) &lt; mid) swap(A(j), A(k--)); else j++; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
        <tag>partition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode List Sort]]></title>
    <url>%2F2016%2F12%2F16%2FLeetCode-List-Sort%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：21. Merge Two Sorted Lists75. Sort Colors147. Insertion Sort List148. Sort List215. Kth Largest Element in an Array324. Wiggle Sort II 21. Merge Two Sorted Lists解题思路 简单题，不多说了； 代码123456789101112131415161718192021222324252627282930class Solution&#123; public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* head = new ListNode(0); ListNode* p = head; while(l1 &amp;&amp; l2) &#123; if(l1-&gt;val &gt; l2-&gt;val) &#123; p-&gt;next = new ListNode(l2-&gt;val); p = p-&gt;next; l2 = l2-&gt;next; &#125; else &#123; p-&gt;next = new ListNode(l1-&gt;val); p = p-&gt;next; l1 = l1-&gt;next; &#125; &#125; if(l1) p-&gt;next = l1; if(l2) p-&gt;next = l2; return head-&gt;next; &#125;&#125;; 75. Sort Colors解题思路 把0一次丢到数组左边，2丢到数组右边，1的话保持不动； 代码12345678910111213141516171819202122232425262728class Solution&#123; public: void sortColors(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); int left = 0; int right = len - 1; for(int i = 0; i &lt; len; ++i) &#123; if(i &gt; right) break; if(nums[i] == 1) continue; else if(nums[i] == 0) &#123; swap(nums[i], nums[left]); left++; &#125; else &#123; swap(nums[i], nums[right]); right--; i--; &#125; &#125; &#125;&#125;; 147. Insertion Sort List解题思路 需要新建一个链表头保存已排序的节点； 代码12345678910111213141516171819202122232425class Solution&#123; public: ListNode *insertionSortList(ListNode *head) &#123; if(head == NULL) return head; ListNode *root = new ListNode(0); ListNode *pre = root; ListNode *cur = head; ListNode *next = NULL; while(cur) &#123; next = cur-&gt;next; while(pre-&gt;next &amp;&amp; pre-&gt;next-&gt;val &lt; cur-&gt;val) pre = pre-&gt;next; cur-&gt;next = pre-&gt;next; pre-&gt;next = cur; cur = next; pre = root; &#125; return root-&gt;next; &#125;&#125;; 148. Sort List解题思路 符合要求的排序算法有快排、堆排和归并，归并更适合用在链表中； 使用一个单步遍历和一个两步遍历快速找到链表的中间结点； 使用归并排序，最后通过merge函数将链表链接起来。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution&#123; public: ListNode *sortList(ListNode *head) &#123; if(!head || !head-&gt;next) return head; ListNode *p = head; ListNode *p2 = head; while(p &amp;&amp; p2-&gt;next-&gt;next) &#123; p = p-&gt;next; p2 = p2-&gt;next-&gt;next; if(p2-&gt;next == NULL) break; &#125; ListNode *head2 = p-&gt;next; p-&gt;next = NULL; return merge(sortList(head), sortList(head2)); &#125; ListNode *merge(ListNode *a, ListNode *b) &#123; ListNode *root = new ListNode(1); ListNode *p = root; while(a &amp;&amp; b) &#123; if(a-&gt;val &gt; b-&gt;val) &#123; p-&gt;next = b; b = b-&gt;next; p = p-&gt;next; p-&gt;next = NULL; &#125; else &#123; p-&gt;next = a; a = a-&gt;next; p = p-&gt;next; p-&gt;next = NULL; &#125; &#125; if(a) p-&gt;next = a; if(b) p-&gt;next = b; return root-&gt;next; &#125;&#125;; 215. Kth Largest Element in an Array解题思路 各种排序算法的讨论比较才是这一题的关键； 代码123456789class Solution&#123; public: int findKthLargest(vector&lt;int&gt; &amp;nums, int k) &#123; sort(nums.begin(), nums.end()); return nums[nums.size() - k]; &#125;&#125;; 324. Wiggle Sort II解题思路 首先进行排序，然后从中间位置分为两个部分，都按照降序进行重组； 代码12345678910111213141516class Solution&#123; public: void wiggleSort(vector&lt;int&gt; &amp;nums) &#123; int len = nums.size(); vector&lt;int&gt; temp(len, 0); sort(nums.begin(), nums.end()); int mid = (len + 1) &gt;&gt; 1; int right = len; for(int i = 0; i &lt; len; ++i) temp[i] = (i&amp;1) ? nums[--right] : nums[--mid]; for(int i = 0; i &lt; len; ++i) nums[i] = temp[i]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
        <tag>LeetCode</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Search 2D Matrix]]></title>
    <url>%2F2016%2F12%2F16%2FLeetCode-Search-2D-Matrix%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：74. Search a 2D Matrix240. Search a 2D Matrix II 74. Search a 2D Matrix解题思路 先找到target所在的行，然后对所在行进行二分查找，结果超时； 将矩阵看做一个一维数组，然后整体使用二分查找； 代码123456789101112131415161718192021222324252627282930class Solution&#123; public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123; if(matrix[0][0] == target) return true; int m = matrix.size(); int n = m ? matrix[0].size() : 0; int total = n * m; int left = 0; int right = n * m - 1; int mid = 0; while(left &lt; right) &#123; if(matrix[left/n][left%n] == target) return true; if(matrix[right/n][right%n] == target) return true; mid = (left + right) / 2; if(matrix[mid/n][mid%n] == target) return true; else if(matrix[mid/n][mid%n] &lt; target) left = mid + 1; else right = mid - 1; &#125; return false; &#125;&#125;; 240. Search a 2D Matrix II解题思路 从右上角开始查找； 如果小于target，则这一行全部小于target； 如果大于target，则这一列全部大于target； 按照这个策略进行搜索即可； 代码123456789101112131415161718192021class Solution&#123; public: bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) &#123; int m = matrix.size(); int n = m ? matrix[0].size() : 0; int x = 0; int y = n - 1; while(x &lt; m &amp;&amp; y &gt;= 0) &#123; if(matrix[x][y] == target) return true; else if(matrix[x][y] &lt; target) x++; else y--; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Binary Search</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Matrix Setting]]></title>
    <url>%2F2016%2F12%2F16%2FLeetCode-Matrix-Setting%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：73. Set Matrix Zeroes289. Game of Life 73. Set Matrix Zeroes解题思路I 直接使用一个m长和n长的数组存储矩阵中0的位置； 空间复杂度（m+n）； 代码12345678910111213141516171819202122232425262728293031class Solution&#123; public: void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int m = matrix.size(); int n = matrix[0].size(); vector&lt;int&gt; row(m, 1); vector&lt;int&gt; col(n, 1); for(int i = 0; i &lt; m; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; if(matrix[i][j] == 0) &#123; row[i] = 0; col[j] = 0; &#125; &#125; &#125; for(int i = 0; i &lt; m; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; if(row[i] &amp;&amp; col[j]) continue; matrix[i][j] = 0; &#125; &#125; &#125;&#125;; 解题思路II 将矩阵中０所在的位置信息保存在首行和首列中； 空间复杂度为０； 代码12345678910111213141516171819202122232425262728293031class Solution&#123; public: void setZeroes(vector&lt;vector&lt;int&gt; &gt; &amp;matrix) &#123; int m = matrix.size(); int n = matrix[0].size(); bool flag = false; for(int i = 0; i &lt; m; ++i) &#123; if(matrix[i][0] == 0) flag = true; for(int j = 1; j &lt; n; ++j) &#123; if(matrix[i][j] == 0) matrix[i][0] = matrix[0][j] = 0; &#125; &#125; for(int i = m-1; i &gt;= 0; --i) &#123; for(int j = n-1; j &gt; 0; --j) &#123; if(!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0; &#125; if(flag) matrix[i][0] = 0; &#125; &#125;&#125;; 289. Game of Life解题思路 [2nd bit, 1st bit] = [next state, current state] 00 dead (current) -&gt; dead(next) 01 live (current) -&gt; dead(next) 10 dead (current) -&gt; live(next) 11 live (current) -&gt; live(next) discuss里面的思路，使用２bit的数据存储下一步和现在的状态，最后移位即可； 代码1234567891011121314151617181920212223242526272829303132class Solution&#123; public: void gameOfLife(vector&lt;vector&lt;int&gt; &gt; &amp;board) &#123; int m = board.size(); int n = m ? board[0].size() : 0; int count; for(int i = 0; i &lt; m; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; count = board[i][j] ? -1 : 0; for(int x = max(0, i-1); x &lt; min(i+2, m); ++x) &#123; for(int y = max(0, j-1); y &lt; min(j+2, n); ++y) &#123; if(board[x][y]&amp;1) count++; &#125; &#125; if(count == 2) board[i][j] += board[i][j]&lt;&lt;1; else if(count == 3) board[i][j] += 2; &#125; &#125; for(int i = 0; i &lt; m ; ++i) for(int j = 0; j &lt; n; ++j) board[i][j] &gt;&gt;= 1; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[72.Edit Distance]]></title>
    <url>%2F2016%2F12%2F15%2F72-Edit-Distance%2F</url>
    <content type="text"><![CDATA[题目链接！ 解题思路 使用DP动态规划，dp[i][j]表示word1中的前i个字符与word2中的前j个字符的距离； dp[i][j]的可能取值如下： word1插入一个字符：dp[i][j-1] + 1; word1删掉一个字符：dp[i-1][j] + 1; 两字符串最后一位不相同，则替换word1的最后一个：dp[i-1][j-1] + 1; 如果相同，则不需要操作：dp[i][j]; DP取上述情形的最小值。 代码1234567891011121314151617181920212223242526class Solution&#123; public: int minDistance(string word1, string word2) &#123; int m = word1.size(); int n = word2.size(); vector&lt;vector&lt;int&gt; &gt; dp(m+1, vector&lt;int&gt;(n+1, 0)); for(int i = 1; i &lt;= m; ++i) dp[i][0] = i; for(int j = 1; j &lt;= n; ++j) dp[0][j] = j; for(int i = 1; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1; if(word1[i-1] == word2[j-1]) dp[i][j] = min(dp[i-1][j-1], dp[i][j]); else dp[i][j] = min(dp[i-1][j-1]+1, dp[i][j]); &#125; &#125; return dp[m][n]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[71. Simplify Path]]></title>
    <url>%2F2016%2F12%2F15%2F71-Simplify-Path%2F</url>
    <content type="text"><![CDATA[题目链接！ 解题思路 使用一个栈去存储每一条路径，如果是..就pop()； 注意处理边界/， /.， /..； 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution&#123; public: string simplifyPath(string path) &#123; string res, temp; res = temp = ""; stack&lt;string&gt; st; int len = path.size(); for(int i = 0; i &lt; len; ++i) &#123; if(path[i] == '/') &#123; if(temp == "" || temp == ".") &#123; temp = ""; continue; &#125; else if(temp == "..") &#123; temp = ""; if(!st.empty()) st.pop(); &#125; else &#123; st.push(temp); temp = ""; &#125; &#125; else &#123; temp += path[i]; &#125; &#125; if(temp != "") &#123; if(temp == "..") &#123; if(!st.empty()) st.pop(); &#125; else if(temp != ".") st.push(temp); &#125; if(st.empty()) return "/"; while(!st.empty()) &#123; res = "/" + st.top() + res; st.pop(); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[70 Climbing Stairs]]></title>
    <url>%2F2016%2F12%2F14%2F70-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[题目链接：70. Climbing Stairs 解题思路 dp[i]表示从ｉ位置到达末尾的方法个数； 只剩最后一步就只有一种选择，两步则有两个选择； dp[m] = dp[m+1] + dp[m+2]; 代码12345678910111213141516171819202122class Solution&#123; public: int climbStairs(int n) &#123; if(n &lt;= 0) return 0; else if(n == 1) return 1; else if(n == 2) return 2; int dp[n]; dp[n-1] = 1; dp[n-2] = 2; for(int i = n-3; i &gt;= 0; --i) &#123; dp[i] = dp[i+1] + dp[i+2]; &#125; return dp[0]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Sqrt and Square]]></title>
    <url>%2F2016%2F12%2F14%2FLeetCode-Sqrt-and-Square%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：50. Pow(x, n)69. Sqrt(x)367. Valid Perfect Square372. Super Pow 50. Pow(x, n)阶梯思路 就直接算就好，考虑指数小于零就好； 代码12345678910111213141516171819202122class Solution&#123; public: double myPow(double x, int n) &#123; double res = 1; long long newn = n; if(newn &lt; 0) &#123; newn = -newn; x = 1.0 / x; &#125; while(newn &gt; 0) &#123; if(newn&amp;1) res = res * x; x = x * x; newn = newn&gt;&gt;1; &#125; return res; &#125;&#125;; 69. Sqrt(x)解题思路 二分查找去找就可以了，注意使用long long类型，防止溢出； 代码123456789101112131415161718192021222324252627282930class Solution&#123; public: int mySqrt(int x) &#123; if(x == 0) return 0; else if(x &lt; 0) return (1&lt;&lt;31); int res; long long left, right, mid; left = 1; right = x&gt;&gt;1; while(left &lt; right) &#123; if(left * left == x) return (int)left; if(right * right == x) return (int)right; mid = (left + right) / 2; if(mid * mid == x) return (int)mid; else if(mid * mid &lt; x) left = mid + 1; else right = mid - 1; &#125; return (left * left &gt; x) ? (left - 1) : left; &#125;&#125;; 367. Valid Perfect Square解题思路 二分法去找根，找到就为true，否则返回false； 如果是1，则直接判定为true； 代码123456789101112131415161718192021222324252627class Solution&#123; public: bool isPerfectSquare(int num) &#123; if(num == 1) return true; long long left, right, mid; left = 1; right = num&gt;&gt;1; while(left &lt; right) &#123; if(left * left == num) return true; if(right * right == num) return true; mid = (left + right) / 2; if(mid * mid == num) return true; else if(mid * mid &lt; num) left = mid+1; else right = mid - 1; &#125; return false; &#125;&#125;; 372. Super Pow解题思路 使用二进制进行快速求幂； a的52次幂，就等于((a^2)%mode * ((a^10)^5)%mode)%mode; 使用上述公式利用快速求幂不断求取((a^10)^10)…即可进行求解； 代码12345678910111213141516171819202122232425262728293031class Solution&#123; private: int mode = 1337; public: int superPow(int a, vector&lt;int&gt; &amp;b) &#123; int res = 1; if(a == 0) return 0; for(int i = b.size()-1; i &gt;= 0; --i) &#123; res = res * quickPow(a, b[i]) % mode; a = quickPow(a, 10); &#125; return res; &#125; inline int quickPow(int a, int n) &#123; int res = 1; a %= mode; while(n) &#123; if(n &amp; 1) res = res * a % mode; a = a * a % mode; n &gt;&gt;= 1; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode String Calculation]]></title>
    <url>%2F2016%2F12%2F14%2FLeetCode-String-Calculation%2F</url>
    <content type="text"><![CDATA[本文包含如下题目： 43. Multiply Strings66. Plus One67. Add Binary415. Add Strings 43. Multiply Strings解题思路 字符串乘法，大数乘法； 使用一个vector不断的累加每个位上的数值，最后统一进行进位操作； 代码1234567891011121314151617181920212223242526272829303132333435class Solution&#123; public: string multiply(string num1, string num2) &#123; int m = num1.size(); int n = num2.size(); if(num1 == "0" || num2 == "0") return "0"; reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); vector&lt;int&gt; res(m+n, 0); for(int i = 0; i &lt; m; ++i) for(int j = 0, id = i; j &lt; n; ++j) res[id++] += (num1[i] - '0') * (num2[j] - '0'); int carry = 0; for(int i = 0; i &lt; m+n; ++i) &#123; int temp = res[i]; res[i] = (temp + carry) % 10; carry = (temp + carry) / 10; &#125; string ans(m+n, '0'); for(int i = m+n-1, id = 0; i &gt;= 0; --i) ans[id++] = res[i] + '0'; int start; for(int i = 0; i &lt; m+n; ++i) if(ans[i] != '0') &#123; start = i; break; &#125; return ans.substr(start); &#125;&#125;; 66. Plus One解题思路 字符串加一，carry初始化为1就好；代码123456789101112131415161718192021class Solution&#123; public: vector&lt;int&gt; plusOne(vector&lt;int&gt; &amp; digits) &#123; int carry = 1; int len = digits.size(); reverse(digits.begin(), digits.end()); vector&lt;int&gt; res(len, 0); for(int i = 0; i &lt; len; ++i) &#123; res[i] = (carry + digits[i]) % 10; carry = (carry + digits[i]) / 10; &#125; if(carry) res.push_back(1); reverse(res.begin(), res.end()); return res; &#125;&#125;; 67. Add Binary解题思路 也就是mod2就好了； 代码12345678910111213141516171819202122232425262728293031class Solution&#123; public: string addBinary(string a, string b) &#123; int m = a.size(); int n = b.size(); reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int carry = 0; string res = ""; int x, y; for(int i = 0; i &lt; max(m, n); ++i) &#123; if(i &gt;= m) x = 0; else x = a[i] - '0'; if(i &gt;= n) y = 0; else y = b[i] - '0'; res += ((x + y + carry) % 2 + '0'); carry = (x + y + carry) / 2; &#125; if(carry) res += '1'; reverse(res.begin(), res.end()); return res; &#125;&#125;; 415. Add Strings解题思路 字符串相加，注意一下最后的进位就好； 代码123456789101112131415161718192021222324252627282930313233class Solution&#123; public: string addStrings(string num1, string num2) &#123; int m = num1.size(); int n = num2.size(); string res = ""; reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); int carry = 0; int a, b; for(int i = 0; i &lt; max(m, n); ++i) &#123; if(i &gt;= m) a = 0; else a = num1[i] - '0'; if(i &gt;= n) b = 0; else b = num2[i] - '0'; res += (a + b + carry) % 10 + '0'; carry = (a + b + carry) / 10; &#125; if(carry) res += '1'; reverse(res.begin(), res.end()); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[68 Text Justification]]></title>
    <url>%2F2016%2F12%2F14%2F68-Text-Justification%2F</url>
    <content type="text"><![CDATA[解题思路 将单词分组打出，每组长度为L； 除了最后一行，单词需要左右对齐，平铺效果，中间以空格均匀填充； 最后一行，总长度也是L，但是要求左对齐，以一个空格隔开即可； 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution&#123; public: vector&lt;string&gt; fullJustify(vector&lt;string&gt; &amp;words, int maxWidth) &#123; int len = words.size(); vector&lt;string&gt; res; vector&lt;string&gt; temp; string str; int count = 0; int totalLen = 0; for(int i = 0; i &lt; len; ++i) &#123; if(count + totalLen + words[i].size() &gt; maxWidth) &#123; str = ""; str += temp[0]; if(count == 1) &#123; str += string(maxWidth - totalLen, ' '); &#125; else if(count == 2) &#123; str += string(maxWidth - totalLen, ' '); str += temp[1]; &#125; else &#123; int block = (maxWidth - totalLen) / (count - 1); int last = maxWidth - totalLen - block * (count - 1); for(int j = 1; j &lt; count; ++j) &#123; str += string(block, ' '); if(last-- &gt; 0) str += ' '; str += temp[j]; &#125; &#125; res.push_back(str); temp.clear(); temp.push_back(words[i]); count = 1; totalLen = words[i].size(); &#125; else &#123; temp.push_back(words[i]); count++; totalLen += words[i].size(); &#125; &#125; if(count) &#123; str = ""; str += temp[0]; for(int j = 1; j &lt; temp.size(); ++j) &#123; str += ' '; str += temp[j]; &#125; str += string(maxWidth - totalLen - count + 1, ' '); res.push_back(str); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode String and Integer]]></title>
    <url>%2F2016%2F12%2F13%2FLeetCode-String-and-Integer%2F</url>
    <content type="text"><![CDATA[本文将包含如下题目：7. Reverse Integer8. String to Integer (atoi)65. Valid Number 7. Reverse Integer解题思路 这道题直接算就行； 代码1234567891011121314151617181920class Solution&#123; public: int reverse(int x) &#123; int p = x; int res = 0; int temp; while(p) &#123; if(res &gt; (0x7FFFFFFF)/10 || res &lt; (1&lt;&lt;31)/10) return 0; temp = p % 10; p = p / 10; res = res * 10 + temp; cout &lt;&lt; res &lt;&lt; endl; &#125; return res; &#125;&#125;; 8. String to Integer (atoi)解题思路 各种测试样例，通过就好，这种题好麻烦； 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Solution&#123; public: int myAtoi(string str) &#123; int len = str.length(); int res = 0; int temp = 0; bool neg = false; int count = 0; for(int i = 0; i &lt; len; ++i) &#123; if(res &gt; (0x7fffffff)/10) &#123; temp = str[i] - '0'; if(temp &gt;= 10 || temp &lt; 0) if(neg) return (-1)*res; else return res; else if(neg) return (1&lt;&lt;31); else return (0x7fffffff); &#125; else if(res == (0x7fffffff)/10) &#123; if(i != len -1) return 0; if(neg) &#123; if(str[i] - '0' == 8) return (1&lt;&lt;31); else if(str[i] - '0' &gt; 8) return (1&lt;&lt;31); else return (-1)*((0x7fffffff)/10*10 + str[i] - '0'); &#125; else &#123; if(str[i] - '0' &gt; 8) return (1&lt;&lt;31); else if(str[i] - '0' == 8) return (0x7fffffff); else return ((0x7fffffff)/10*10 + str[i] - '0'); &#125; &#125; if(str[i] == ' ' &amp;&amp; !res &amp;&amp; !count) continue; else if(str[i] == '+') &#123; if(count == 0) &#123; neg == false; count++; &#125; else return 0; &#125; else if(str[i] == '-') &#123; if(count == 0) &#123; neg = true; count++; &#125; else return 0; &#125; else &#123; temp = str[i] - '0'; if(temp &lt; 0 || temp &gt;= 10) &#123; break; &#125; res = res*10 + temp; &#125; &#125; if(neg) return (-1)*res; else return res; &#125;&#125;; 65. Valid Number解题思路 又是这种测试样例的题目，好无聊！（虽然我承认这个对于写代码尤其是测试工作非常重要！！） 详细思路请点击参考hrwhisper大神的博客！ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; public: bool isNumber(string s) &#123; int i = 0, n = s.length(); while (n &gt; 0 &amp;&amp; s[n - 1] == ' ') n--; if (!n) return false; while (i &lt; n &amp;&amp; s[i] == ' ') i++; if (s[i] == '-' || s[i] == '+') i++; bool e = false, point = false; bool numBeforeE = false, numAfterE = false; bool numBeforeP = false, numAfterP = false; for (; i &lt; n; i++) &#123; if (s[i] &gt; '9' || s[i] &lt; '0') &#123; if (s[i] == 'e' &amp;&amp; !e &amp;&amp; numBeforeE) &#123; e = true; if (i + 1 &lt; n &amp;&amp; (s[i + 1] == '-' || s[i + 1] == '+')) i++; continue; &#125; if (s[i] == '.' &amp;&amp; !point &amp;&amp;!e) &#123; point = true; continue; &#125; return false; &#125; numBeforeP = numBeforeE = true; if (e) numAfterE = true; if (point) numAfterP = true; &#125; if (e &amp;&amp; !numAfterE) return false; if (point &amp;&amp; !numAfterP &amp;&amp; !numBeforeP) return false; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Path Problems]]></title>
    <url>%2F2016%2F12%2F13%2FLeetCode-Path-Problems%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：62. Unique Paths63. Unique Paths II64. Minimum Path Sum174. Dungeon Game 62. Unique Paths解题思路 设m×n的表格有res[m][n]条路径； 所有的res[m][26] = res[1][n] = 1; 针对任意i×j有res[i][j] = res[i-1][j] + res[i][j-1]; 由状态公式可知，可以进行空间优化，使用两行数组即可DP完成。 如上，用DP就可以很快做出来。 代码1234567891011121314151617181920class Solution&#123; public: int uniquePaths(int m, int n) &#123; int res[101][101] = &#123;0&#125;; for(int i = 1; i &lt;= m; ++i) res[i][27] = 1; for(int j = 1; j &lt;= n; ++j) res[1][j] = 1; for(int i = 2; i &lt;= m; ++i) &#123; for(int j = 2; j &lt;= n; ++j) &#123; res[i][j] = res[i-1][j] + res[i][j-1]; &#125; &#125; return res[m][n]; &#125;&#125;; 进行空间优化之后的代码为：1234567891011121314151617181920class Solution&#123; public: int uniquePaths(int m, int n) &#123; int res[2][101] = &#123;0&#125;; for(int i = 1; i &lt;= n; ++i) res[0][i] = res[1][i] = 1; for(int i = 2; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; res[1][j] = res[0][j] + res[1][j-1]; &#125; for(int k = 0; k &lt;= n; ++k) res[0][k] = res[1][k]; &#125; return res[0][n]; &#125;&#125;; 63. Unique Paths II解题思路 设m×n的表格有res[m][n]条路径； 所有的res[m][28] = res[1][n] = 1; 如果(x, j)位置为1，则此时res[i][j] = 0; 此外，任意i×j有res[i][j] = res[i-1][j] + res[i][j-1]; 根据上述公式，进行空间优化，使用两行数组进行DP即可。 代码1234567891011121314151617181920212223242526272829303132class Solution&#123; public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt; &gt; &amp;obstacleGrid) &#123; int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); if(obstacleGrid[0][0] == 1 || obstacleGrid[m-1][n-1] == 1) return 0; int res[2][101] = &#123;0&#125;; for(int i = 1; i &lt;= n; ++i) &#123; if(obstacleGrid[0][i-1]) break; res[0][i] = res[1][i] = 1; &#125; for(int i = 2; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; if(obstacleGrid[i-1][j-1] == 0) res[1][j] = res[0][j] + res[1][j-1]; else res[1][j] = 0; &#125; for(int k = 0; k &lt;= n; ++k) res[0][k] = res[1][k]; &#125; return res[0][n]; &#125;&#125;; 64. Minimum Path Sum解题思路 grid[i][j]表示到(i, j)位置的最小距离； grid[i][j] = min(grid[i][j-1] + grid[i][j], grid[i-1][j] + grid[i][j])； 代码123456789101112131415161718192021class Solution&#123; public: int minPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;grid) &#123; int m = grid.size(); int n = grid[0].size(); for(int i = 1; i &lt; m; ++i) grid[i][0] = grid[i-1][0] + grid[i][0]; for(int j = 1; j &lt; n; ++j) grid[0][j] = grid[0][j-1] + grid[0][j]; for(int i = 1; i &lt; m; ++i) &#123; for(int j = 1; j &lt; n; ++j) &#123; grid[i][j] = min(grid[i][j-1] + grid[i][j], grid[i-1][j] + grid[i][j]); &#125; &#125; return grid[m-1][n-1]; &#125;&#125;; 174. Dungeon Game解题思路 设dp[i][j]表示到达(i, j)时的最小生命值； dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dp[i][j])； 减去dp[i][j]，如果为正，表示最小生命值可以少一点，但最小为1，为负，表示需要更多的生命值； 从右下角开始进行计算，右下角的最小生命值为1，然后从右下到左上进行计算； 如果从左上开始向右下计算，遇到一个很大的正数的时候就很难处理，会覆盖之前的信息； DP的问题，如果正序计算不好解决，试一试逆序DP。 代码123456789101112131415161718class Solution&#123; public: int calculateMinimumHP(vector&lt;vector&lt;int&gt; &gt; &amp;dumgeon) &#123; int m = dumgeon.size(); int n = dumgeon[0].size(); dumgeon[m-1][n-1] = max(1, 1 - dumgeon[m-1][n-1]); for(int j = n-2; j &gt;= 0; --j) dumgeon[m-1][j] = max(1, dumgeon[m-1][j+1] - dumgeon[m-1][j]); for(int i = m-2; i &gt;= 0; --i) dumgeon[i][n-1] = max(1, dumgeon[i+1][n-1] - dumgeon[i][n-1]); for(int i = m-2; i &gt;= 0; --i) for(int j = n-2; j &gt;= 0; --j) dumgeon[i][j] = max(1, min(dumgeon[i+1][j], dumgeon[i][j+1]) - dumgeon[i][j]); return dumgeon[0][0]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Rotate]]></title>
    <url>%2F2016%2F12%2F08%2FLeetCode-Rotate%2F</url>
    <content type="text"><![CDATA[本文包含如下题目：61. Rotate List189. Rotate Array 61. Rotate List解题思路本题目是链表的翻转，先求链表长度，然后构建循环链表，最后找到所求头节点断开循环返回即可。 代码1234567891011121314151617181920212223242526272829303132333435class Solution&#123; public: ListNode* rotateRight(ListNode *head, int k) &#123; if(head == NULL) return NULL; ListNode *res; ListNode *p = head; int len = 1; while(p-&gt;next) &#123; len++; p = p-&gt;next; &#125; k %= len; if(k == 0) return head; p-&gt;next = head; while(p) &#123; p = p-&gt;next; len--; if(len == k) &#123; res = p-&gt;next; p-&gt;next = NULL; break; &#125; &#125; return res; &#125;&#125;; 189. Rotate Array解题思路数组的翻转，类似于链表的翻转，c++的vector容器有很多直接可以调用的函数，可以参考官方的讲解。 代码Solution I1234567891011121314class Solution&#123; public: void rotate(vector&lt;int&gt; &amp;nums, int k) &#123; int len = nums.size(); k %= len; for(int i = 0; i &lt; k; ++i) &#123; nums.insert(nums.begin(), nums[len-1]); nums.pop_back(); &#125; &#125;&#125;; Solution II123456789101112class Solution&#123; public: void rotate(vector&lt;int&gt; &amp;nums, int k) &#123; int len = nums.size(); k %= len; reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin()+k); reverse(nums.begin()+k, nums.end()); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客多台电脑的同步与迁移]]></title>
    <url>%2F2016%2F11%2F21%2FHexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[使用Github Page + Hexo可以搭建出非常简洁和个性化的博客系统，本博客就是使用的Hexo的Next主题挂载在Github Page上的。现在的问题是，如果我想要在多台设备中进行博文的更新和推送，或者我重新安装系统，我原来的博客配置全部没有了如何进行数据和配置的恢复，今天我们就这介绍这么一种方法，我也刚刚成功的在一个新系统中配置好了博客环境。其核心就是在博客挂载的Github仓库中新建一个branch分支hexo，其中默认的master进行博文的deploy工作，hexo保存博客的源文件以及环境配置和主题配置文件（设置hexo为默认主分支），这样我们每次重新配置系统只需要从Github中clone一下，然后再进行几步简单环境安装配置操作就完成了。具体步骤如下：1.建立master和hexo两个分支2.安装Node.js3.安装git4.安装hexo5.git clone6.更新theme主题文件配置7.npm安装配置hexo下面我们一步一步来完成！ 建立master和hexo两个分支其中master分支是默认建立好的，我们在./_config.yml文件中配置deploy布置信息，设置布置生成的静态文件的分支为master，使用hexo deploy命令会自动的将这些静态文件push到Github中去；然后新建一个分支hexo，保存我们所有的源文件，这里需要手动git push，另外，由于hexo中.gitignore文件设置了忽略，所以./theme文件中的主题配置信息不会被push到Github中，所以这里新建一个setting文件夹保存./theme中的主题配置文件，进行备份更新。将hexo分支设置为默认主分支，我们之后只需要通过hexo分支进行博文的更新即可，hexo分支保存博文源文件（Markdown文件），通过hexo g -d命令会自动将生成的静态文件push到master分支上去。 安装Node.js对于一台新的电脑进行配置，我们首先需要按如下步骤进行环境的安装配置。 首先安装Node.js，最佳方法推荐nvm；cURL:1curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget:1wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。1nvm install stable 安装git1sudo apt-get install git-core 安装Hexo1npm install -g hexo-cli 如果这里报错的话可以尝试添加--unsafe1npm install -g hexo-cli --unsafe 然后安装要用到的一些插件123456789101112131415npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --savenpm install hexo-generator-search --savenpm install hexo-generator-searchdb --save git clonegit clone复制repo源文件，其中由于.gitignore文件，hexo目录中的theme主题文件不会被push到Github中，所以我采取的方法是新建一个setting文件夹，将theme文件复制到setting文件中进行备份保存。 更新theme文件配置所以这里git clone之后要进行theme主题配置的更新，执行如下命令：1cp -rf ./setting/next ./themes 主题与文件夹的名字大家按自己定义的就好。 npm安装配置Hexo执行如下几条命令：123npm install hexonpm installnpm install hexo-deployer-git 千万不要执行hexo init，这样会重置hexo的配置文件，配好的文件就丢失啦！ 测试使用这时就可以测试一下，使用hexo server、hexo g -d等命令测试一下同步的情况，然后不同的机器可以使用git pull进行数据的同步，每次更新博文就使用git push origin hexo更新到hexo分支上去即可！ PS：今天解决了Next博客主页空白的问题，由于Github Page更新了，所以将/theme/next/source/下的vendor文件夹改名为lib文件夹，并在/theme/next/source/_config.yml文件中进行了对应的替换，最后更新到setting文件夹中。]]></content>
      <categories>
        <category>GitHub Page</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>Github Page</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UNIX编程之冲洗内存流与null追加策略（APUE F5-15）]]></title>
    <url>%2F2016%2F11%2F17%2FUNIX%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%86%B2%E6%B4%97%E5%86%85%E5%AD%98%E6%B5%81%E4%B8%8Enull%E8%BF%BD%E5%8A%A0%E7%AD%96%E7%95%A5%EF%BC%88APUE-F5-15%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近一直在拜读APUE(Advanced Programming in the UNIX Environment)，在读到标准I/O库的时候，对于图 5-15的代码和内存流的写入方式发现冲洗内存流和null字节的追加策略书上没有说明白，到底是如何追加‘null字节的，调用fclose为什么没有追加null`字节等等，对于这一系列问题通过代码测试终于搞清楚整体的写入追加策略，特此记录一下。解决问题的关键在于书上这一句话： 任何时候需要增加流缓冲区中的数据量以及调用fclose、fflush、fseek、fseeko以及fsetpos时都会在当前位置写入一个null字节！ 看似是一旦调用fclose就要追加null，可以书上给的例子可不是这样哦，下面随着文章我们来一步一步地分析。 内存流写入代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include "apue.h"#define BSZ 48int main()&#123; FILE *fp; char buf[BSZ]; memset(buf, 'a', BSZ-2); buf[BSZ-2] = '\0'; buf[BSZ-1] = 'X'; if ((fp = fmemopen(buf, BSZ, "w+")) == NULL) err_sys("fmemopen failed"); printf("Initial buffer contents: %s\n", buf); fprintf(fp, "hello, world"); //写进缓存 printf("Before flush: %s\n\n", buf); fflush(fp); //调用fflush、fclose、、fseek、fseeko、fsetpos会在当前位置添加null printf("After fflush: %s\n", buf); printf("Len of string in buf = %ld\n\n", (long)strlen(buf)); memset(buf, 'b', BSZ-2); buf[BSZ-2] = '\0'; buf[BSZ-1] = 'X'; fprintf(fp, "hello, world"); fseek(fp, 0, SEEK_CUR); //保持偏移值冲洗之后的位置 printf("After fseek: %s\n", buf); printf("Len of string in buf = %ld\n\n", (long)strlen(buf)); memset(buf, 'c', BSZ-2); buf[BSZ-2] = '\0'; buf[BSZ-1] = 'X'; fprintf(fp, "hello, world"); //继续写进去 fseek(fp, 0, SEEK_SET); //偏移值设为缓冲区开始位置 printf("After fseek: %s\n", buf); printf("Len of string in buf = %ld\n\n", (long)strlen(buf)); memset(buf, 'd', BSZ-2); buf[BSZ-2] = '\0'; buf[BSZ-1] = 'X'; fprintf(fp, "hello, world"); //继续写进去 fclose(fp); //然后fclose在当前位置也就是数据尾端添加一个null printf("After close: %s\n", buf); printf("Len of string in buf = %ld\n", (long)strlen(buf)); return(0);&#125; 程序执行的结果为：1234567891011121314Initial buffer contents:Before flush:After fflush: hello, worldLen of string in buf = 12After fseek: bbbbbbbbbbbbhello, worldLen of string in buf = 24After fseek: cccccccccccccccccccccccchello, worldLen of string in buf = 36After close: hello, worldddddddddddddddddddddddddddddddddddLen of string in buf = 46 写入操作分析首先是使用a字符修改缓冲区：123memset(buf, 'a', BSZ-2);buf[BSZ-2] = '\0';buf[BSZ-1] = 'X'; 此时得到的buf应该是： aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa0X为了识别方便，这里每隔5个字符使用一个+隔开显示，如下所示： aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + a0X 此时偏移值指向数据末尾，即offset = 47 然后执行：12if ((fp = fmemopen(buf, BSZ, "w+")) == NULL) err_sys("fmemopen failed"); 流控制参数为w+，fmemopen函数在缓冲区开始处放置了null字节，此时的buf应该是： null+ aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + 0X 因为首字符即为null，此时打印结果为空； 此时偏移值指向缓冲区开始null字节处，即offset = 0 然后通过fprintf函数写入数据，并使用fflush函数冲洗缓冲区：12fprintf(fp, "hello, world"); //写进缓存fflush(fp); //调用fflush、fclose、、fseek、fseeko、fsetpos会在当前位置添加null 利用fflush函数引起缓冲区冲洗，并在当前位置设置null，此时的buf为： hello, world + null + aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + aaaaa + aaa0X 此时的打印结果为： “hello, world” 此时的偏移值指向null，即offset = 12 然后继续执行：123memset(buf, 'b', BSZ-2);buf[BSZ-2] = '\0';buf[BSZ-1] = 'X'; 用b字符改写缓冲区，此时的buf为： bbbbb + bbbbb + bbbbb + bbbbb + bbbbb + bbbbb + bbbbb + bbbbb + bbbbb + b0X 此时的偏移值仍旧指向原来的位置，即为offset = 12 然后继续想缓冲中写入数据：12fprintf(fp, "hello, world"); //继续写进fseek(fp, 0, SEEK_CUR); //保持偏移值在冲洗之后位置 利用fseek函数引起缓冲区冲洗，并在当前位置设置null，此时buf为： bbbbb + bbbbb + bb + hello, world + null + bbbbb + bbbbb + bbbbb + bbbbb + b0X 打印结果为： bbbbbbbbbbbbhello, world 偏移值位于null，即offset = 24 然后经过继续写入之后：12345memset(buf, 'c', BSZ-2);buf[BSZ-2] = '\0';buf[BSZ-1] = 'X';fprintf(fp, "hello, world"); //继续写进去fseek(fp, 0, SEEK_SET); //偏移值设为缓冲区开始位置 利用fseek函数引起缓冲区冲洗，并在当前位置设置null，此时的buf为： cccccccccccc + cccccccccccc + hello, world + null + ccccc + cccc0X 打印结果为：cccccccccccccccccccccccchello, world 此时由于fseek函数，偏移值设为了缓冲区的开始位置，即offset = 0 最后执行写入，注意此时的偏移值位于缓冲区开始：12345memset(buf, 'd', BSZ-2);buf[BSZ-2] = '\0';buf[BSZ-1] = 'X';fprintf(fp, "hello, world"); //继续写进去fclose(fp); //然后fclose在当前位置也就是数据尾端添加一个null 直接使用fclose函数关闭流，没有追加null，此时的buf为： hello, world + null + ddddd + ddddd + ddddd + ddddd + ddddd + ddddd + ddd0X 打印结果为 hello, worlddddddddddddddddddddddddddddddddddd 但是前面不是说了一旦调用fclose等函数，就会自动在当前位置写一个null字节嘛， 为什么这里没有追加呢？请看下面三个测试方案 null追加策略分析测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "apue.h"#define BSZ 48int main()&#123; FILE *fp1, *fp2, *fp3; char buf1[BSZ], buf2[BSZ], buf3[BSZ]; //方案一 memset(buf1, 'a', BSZ-2); buf1[BSZ-2] = '\0'; buf1[BSZ-1] = 'X'; if ((fp1 = fmemopen(buf1, BSZ, "w+")) == NULL) err_sys("fmemopen failed"); fprintf(fp1, "hello, world"); //调用fflush函数引起缓冲区冲洗 fflush(fp1); printf("1.After fflush: %s\n", buf1); printf("1.Len of string in buf = %ld\n", (long)strlen(buf1)); memset(buf1, 'b', BSZ-2); buf1[BSZ-2] = '\0'; buf1[BSZ-1] = 'X'; //二次输入数据为"nihao"，长度较短 fprintf(fp1, "nihao"); fclose(fp1); printf("1.After close: %s\n", buf1); printf("1.Len of string in buf = %ld\n\n", (long)strlen(buf1)); //方案二 memset(buf2, 'a', BSZ-2); buf2[BSZ-2] = '\0'; buf2[BSZ-1] = 'X'; if ((fp2 = fmemopen(buf2, BSZ, "w+")) == NULL) err_sys("fmemopen failed"); fprintf(fp2, "hello, world"); //调用fseek函数引起缓冲区冲洗，偏移值设为首部 fseek(fp2, 0, SEEK_SET); printf("2.After fseek: %s\n", buf2); printf("2.Len of string in buf = %ld\n", (long)strlen(buf2)); memset(buf2, 'b', BSZ-2); buf2[BSZ-2] = '\0'; buf2[BSZ-1] = 'X'; //二次输入数据为"nihao"，长度较短 fprintf(fp2, "nihao"); fclose(fp2); printf("2.After close: %s\n", buf2); printf("2.Len of string in buf = %ld\n\n", (long)strlen(buf2)); //方案三 memset(buf3, 'a', BSZ-2); buf3[BSZ-2] = '\0'; buf3[BSZ-1] = 'X'; if ((fp3 = fmemopen(buf3, BSZ, "w+")) == NULL) err_sys("fmemopen failed"); fprintf(fp3, "hello, world"); //调用fseek函数引起缓冲区冲洗，偏移值设为首部 fseek(fp3, 0, SEEK_SET); printf("3.After fseek: %s\n", buf3); printf("3.Len of string in buf = %ld\n", (long)strlen(buf3)); memset(buf2, 'b', BSZ-2); buf2[BSZ-2] = '\0'; buf2[BSZ-1] = 'X'; //二次输入数据为"hello, world! How are you?"，长度较长 fprintf(fp3, "hello, world! How are you?"); fclose(fp3); printf("3.After close: %s\n", buf3); printf("3.Len of string in buf = %ld\n\n", (long)strlen(buf3)); return(0);&#125; 最后的输出结果为：12345678910111213141.After fflush: hello, world1.Len of string in buf = 121.After close: bbbbbbbbbbbbnihao1.Len of string in buf = 172.After fseek: hello, world2.Len of string in buf = 122.After close: nihaobbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb2.Len of string in buf = 463.After fseek: hello, world3.Len of string in buf = 123.After close: hello, world! How are you?3.Len of string in buf = 26 结果分析 方案一：fclose函数冲洗内存流导致需要增加流缓冲区中数据量，在当前偏移值后面继续写入数据，由12增加到17，并且调用了fclose函数，所以追加null； 方案二：fclose函数冲洗内存流时，偏移值在流缓冲区首部，此时”nihao”的长度小于原本流缓冲区中”hello, world”的长度，只会覆盖流缓冲区的前一部分，流缓冲区数据量并没有增加，仍未12，所以不追加null； 方案三：同方案二，只是再次输入的数据”hello, world! How are you?”大于原本流缓冲区中的”hello, world”的长度，所以需要增加流缓冲区中数据量，调用了fclose函数，所以追加’null`； 总结由上述测试可以发现，追加null的策略机制是必须同时满足以下两个条件： 需要增加流缓冲区中的数据量 调用fclose、fflush、fseek、fseeko以及fsetpos时 书上的图5-15就是因为输入数据太短没有增加流缓冲区所以才没有追加null的，看到这里应该可以明白了吧。这一部分书上也没有讲得很清楚，我看到这里困惑了好久，终于通过自己的测试一点一点搞明白了。文章粗浅，有什么疏漏之处欢迎各位批评指正！]]></content>
      <categories>
        <category>UNIX/Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>APUE</tag>
        <tag>APUE 5-15</tag>
        <tag>UNIX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 14.04系统下配置shadowsocks]]></title>
    <url>%2F2016%2F10%2F31%2FUbuntu-14-04%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AEshadowsocks%2F</url>
    <content type="text"><![CDATA[shadowsocks是一种我们经常使用的科学上网的工具，是一种非常方便快捷的代理工具。目前的shadowsocks已经支持全平台的服务支持，这篇文章主要介绍一下Ubuntu 14.04系统平台中shadowsocks的安装配置。Ubuntu 14.04系统平台下的shadowsocks配置一共有两种方式，分别是安装shadowsocks-gui（Cross-platform GUI powered node and by Webkit）和在命令行中使用shadowsocks。 shadowsocks-qt5使用教程首先确保你的Ubuntu版本是&gt;=14.04的，然后通过添加PPA进行安装：123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 其他系统版本的安装过程见如下安装教程。 命令行配置shadowsocks首先确保你的python版本是2.6或者2.7。1python --version ##查看python的版本 然后直接安装shadowsocks。1pip install shadowsocks ##如果没有pip请执行 apt-get install python-pip进行安装 然后在/etc/shadowsocks目录下新建一个文件config.json，（如果没有对应文件/文件夹则新建一个），文件包含如下内容：12345678&#123; "server":"my_server_ip", "server_port":8388, "local_port":1080, "password":"barfoo!", "timeout":600, "method":"table"&#125; 其中各行的意义为：123456server your server IP (IPv4/IPv6), notice that your server will listen to this IPserver_port server portlocal_port local portpassword a password used to encrypt transfertimeout in secondsmethod encryption method, "bf-cfb", "aes-256-cfb", "des-cfb", "rc4", etc. Default is table, which is not secure. "aes-256-cfb" is recommended 如果是在服务器或者VPS中配置shadowsocks，则在config.json文件所在的目录下执行ssserver命令开启服务器端：1234cd /etc/shadowsocks/ssserver -c /etc/shadowsocks/config.json##此时已经开始运行，如果想在后台运行shadowsocks，则上一步应执行如下语句：nohup ssserver &gt; log &amp; 如果是在本机配置shadowsocks，如果执行上述代码则会报如下错误：12...socket.error: [Errno 99] Cannot assign requested address 此时应该执行如下命令：1sslocal -c /etc/shadowsocks/config.json -d start 此时shadowsocks应该就可以成功运行了。 使用代理直接在浏览器相应的插件（比如chrome浏览器中使用Proxy SwitchySharp）中配置如下信息就可以使用shadowsocks代理上网啦！123protocol: socks5hostname: 127.0.0.1port: your local_port]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu 14.04</tag>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Halloween!]]></title>
    <url>%2F2016%2F10%2F31%2FHello-Halloween%2F</url>
    <content type="text"><![CDATA[今天的GitHub为了庆祝万圣节，小小很惊喜！这个配色的GitHub太喜欢了！另附上一首特别喜欢的歌——《南下》，路还很长，且行且努力着！]]></content>
      <categories>
        <category>心迹</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>halloween</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 14.04登陆界面无限循环的解决办法]]></title>
    <url>%2F2016%2F09%2F13%2FUbuntu-14-04%E7%99%BB%E9%99%86%E7%95%8C%E9%9D%A2%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[问题描述：Ubuntu 14.04突然不能登录，输入密码一直返回登录界面这里直接告诉大家我的解决方法。通过在网上各种查找，我的问题既不是/etc/profile文件中保存的环境变量问题，也不是.Xauthority文件的权限问题，我也奇怪我并没有进行什么非法操作，怎么会更改这两个选项的内容。最后终于发现，是因为我的/home空间满了，导致/home无法成功挂载，从而导致的一直在登陆界面循环。 问题描述Ubuntu 14.04系统开机后一切顺利，进入到登陆界面之后，输入密码-&gt;黑屏-&gt;返回登陆界面；然后就出现了一直这样的死循环。 原因一：/etc/profile环境变量的问题解决办法： 在登陆界面，按Ctrl+Alt+F1(F1~F6)都可以，进入到命令行模式； 首先输入用户名，接着按照提示输入对应密码； 输入一下代码：123sudo cp /etc/profile /etc/profile_bac ##对profile进行备份sudo rm /etc/profile ##这里选择将profile直接删除，也可以通过删除多余的语句进行修改sudo reboot ##重新启动，尝试再次登陆 原因二：Xauthority文件权限问题解决方法： 在登陆界面，按Ctrl+Alt+F1(F1~F6)都可以，进入到命令行模式； 首先输入用户名，接着按照提示输入对应密码； 输入如下代码：1234cd ~sudo chown name : name .Xauthority ##将Xauthority的拥有权限设置为用户##或者直接删掉`.Xauthority`文件也可以sudo rm .Xauthority ##这一句跟上一句任选一句 原因三：/home目录空间满，无法正常挂载解决办法： 在登陆界面，按Ctrl+Alt+F1(F1~F6)都可以，进入到命令行模式； 首先输入用户名，接着按照提示输入对应密码； 输入如下代码：123cd /home/name ##name是你的用户名ls -a ##查看用户名目录下的文件内容rm -rf XXXXX ## 删除不需要的文件即可 总结遇到问题还是不要着急，冷静地分析，耐心的查看各种状态信息，再加上无所不能的互联网，问题总能得到解决的！PS:查出是因为/home内存不够时，想到是因为之前用python复制了好几份数据文件进行处理，我真的是不知道该开心呢还是该开心呢，，，]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法]]></title>
    <url>%2F2016%2F08%2F16%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最短路径问题是图论研究中的一个经典的算法问题，旨在寻找图（由结点和路径组成的）中两个结点之间的最短路径。我们经常使用的最短路径算法有Dijkstra算法，Floyd算法和SPFA算法。 Dijkstra算法算法思想 Dijkstra算法适合计算给定起点的最短路径问题； 总是寻找距离目前结点集合最近的结点，加入到集合后更新集合外结点到集合的距离进行循环求解； Dijkstra同样适合应用于最短路由算法等应用领域。 题目描述本题目描述引自hihocoder第二十三周hiho一下hiho1081。【输入】每个测试点（输入文件）有且仅有一组测试数据。在一组测试数据中：第1行为4个整数N、M、S、T，分别表示鬼屋中地点的个数和道路的条数，入口（也是一个地点）的编号，出口（同样也是一个地点）的编号。接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编号为v_i的地点之间有一条长度为length_i的道路。对于100%的数据，满足N&lt;=10^3，M&lt;=10^4, 1 &lt;= length_i &lt;= 10^3, 1 &lt;= S, T &lt;= N, 且S不等于T。【输出】对于每组测试数据，输出一个整数Ans，表示从S到T至少要走的路程。【样例输入】 5 23 5 4 1 2 708 2 3 112 3 4 721 4 5 339 5 4 960 1 5 849 2 5 98 1 4 99 2 4 25 2 1 200 3 1 146 3 2 106 1 4 860 4 1 795 5 4 479 5 4 280 3 4 341 1 4 622 4 2 362 2 3 415 4 1 904 2 1 716 2 5 575 【样例输出】 123 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;string.h&gt;#define N 1005using namespace std;int main()&#123; unsigned len[N][N]; memset(len, -1, sizeof(len)); int n, m, s, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; int from, to; unsigned length; for(int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; from &gt;&gt; to &gt;&gt; length; length = min(length, len[from][to]); len[from][to] = len[to][from] = length; &#125; int index; int value; while(1) &#123; index = 1; value = len[s][6]; for(int i = 2; i &lt;= n; ++i) &#123; if(value &gt; len[s][i]) &#123; value = len[s][i]; index = i; &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; if(len[index][i] != (unsigned)-1) &#123; len[s][i] = min(len[s][index] + len[index][i], len[s][i]); &#125; &#125; if(index == t) &#123; break; &#125; else &#123; len[s][index] = -1; &#125; &#125; cout &lt;&lt; len[s][t] &lt;&lt; endl; return 0;&#125; Floyd算法算法思想 Floyd算法实质上是一种动态规划的思想； 设D[i,j,k]表示从结点i到结点j的只经过(1..k)集合中的结点的最短路径长度，则1.若最短路径经过点ｋ，则D[i,j,k] = D[i,k,k-1] + D[k,j,k-1];2.若最短路径不经过点ｋ，则D[i,j,k] = D[i,j,k-1]；因此，Ｄ[i,j,k] = min(D[i,j,k-1], D[i,k,k-1] + D[k,j,k-1]); 实际操作过程中，我们只需要从(1..n)遍历结点k，不断更新求取每两个结点之间的最短距离即可，最后得到的包含所有结点信息的距离矩阵。 题目描述本题目描述引自hihocoder第二十四周hihocoder1089。【输入】每个测试点（输入文件）有且仅有一组测试数据。在一组测试数据中：第1行为2个整数N、M，分别表示鬼屋中地点的个数和道路的条数。接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编号为v_i的地点之间有一条长度为length_i的道路。对于100%的数据，满足N&lt;=10^2，M&lt;=10^3, 1 &lt;= length_i &lt;= 10^3。对于100%的数据，满足迷宫中任意两个地点都可以互相到达。【输出】对于每组测试数据，输出一个NN的矩阵A，其中第i行第j列表示，从第i个地点到达第j个地点的最短路径的长度，当i=j时这个距离应当为0。*【样例输入】 5 12 1 2 967 2 3 900 3 4 771 4 5 196 2 4 788 3 1 637 1 4 883 2 4 82 5 2 647 1 4 198 2 4 181 5 2 665 【样例输出】 0 280 637 198 394 280 0 853 82 278 637 853 0 771 967 198 82 771 0 196 394 278 967 196 0 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;string.h&gt;#define N 105using namespace std;unsigned len[N][N];int main()&#123; int n, m; int from, to; unsigned length; memset(len, -1, sizeof(len)); cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) len[i][i] = 0; for(int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; from &gt;&gt; to &gt;&gt; length; len[from][to] = len[to][from] = min(length, len[from][to]); &#125; for(int k = 1; k &lt;= n; ++k) &#123; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; if(len[i][k] != (unsigned)-1 &amp;&amp; len[k][j] != (unsigned)-1) &#123; len[i][j] = len[j][i] = min(len[i][j], len[i][k] + len[k][j]); &#125; &#125; &#125; &#125; for(int i = 1; i &lt;= n; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; cout &lt;&lt; len[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; SPFA算法SPFA(Shortest Path Faster Algorithm)算法是求单源最短路径的一种算法，通过添加一个队列对Bellman-Ford算法进行优化。 算法思想 设立一个先进先出的队列用于保存待优化的结点； 每次取出队首结点进行计算，使用队首结点的最短路径估计值对其他结点进行松弛操作，并将进行了松弛的结点放入队列中； 算法描述本算法描述引自hihocoder第二十五周hiho1093。【输入】每个测试点（输入文件）有且仅有一组测试数据。在一组测试数据中：第1行为4个整数N、M、S、T，分别表示鬼屋中地点的个数和道路的条数，入口（也是一个地点）的编号，出口（同样也是一个地点）的编号。接下来的M行，每行描述一条道路：其中的第i行为三个整数u_i, v_i, length_i，表明在编号为u_i的地点和编号为v_i的地点之间有一条长度为length_i的道路。对于100%的数据，满足N&lt;=10^5，M&lt;=10^6, 1 &lt;= length_i &lt;= 10^3, 1 &lt;= S, T &lt;= N, 且S不等于T。对于100%的数据，满足小Hi和小Ho总是有办法从入口通过地图上标注出来的道路到达出口。【输出】对于每组测试数据，输出一个整数Ans，表示那么小Hi和小Ho为了走出鬼屋至少要走的路程。【样例输入】 5 10 3 5 1 2 997 2 3 505 3 4 118 4 5 54 3 5 480 3 4 796 5 2 794 2 5 146 5 4 604 2 5 63 【样例输出】 172 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;string.h&gt;#define N 100010using namespace std;vector&lt;pair&lt;int, int&gt; &gt; len[N];bool source[N] = &#123;false&#125;;//判定结点是否已经在队列中unsigned state[N];//s源节点到各节点的距离状态queue&lt;int&gt; que;int main()&#123; memset(state, -1, sizeof(state)); int n, m, s, t; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; int from, to, length; while(m--) &#123; cin &gt;&gt; from &gt;&gt; to &gt;&gt; length; len[from].push_back(make_pair(to, length)); len[to].push_back(make_pair(from, length)); &#125; state[s] = 0; que.push(s); while(!que.empty()) &#123; for(const auto x : len[que.front()]) &#123; if(state[que.front()] != (unsigned)-1) &#123; if(state[que.front()] + x.second &lt; state[x.first]) &#123; state[x.first] = state[que.front()] + x.second; if(source[x.first]) &#123; continue; &#125; else &#123; que.push(x.first); source[x.first] = true; &#125; &#125; &#125; &#125; source[que.front()] = false; que.pop(); &#125; cout &lt;&lt; state[t] &lt;&lt; endl; return 0;&#125; 总结 最短路径算法既是图论的常用算法，同时也在路由算法中有着重要的应用。 万变不离其宗的经典算法思想动态规划和贪心算法。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>最短路径</tag>
        <tag>Dijkstra</tag>
        <tag>Floyd</tag>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态RMQ问题解决办法与算法分析]]></title>
    <url>%2F2016%2F07%2F29%2F%E5%8A%A8%E6%80%81RMQ%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在之前的一篇博文中，我们介绍了使用Sparse Table（ST稀疏表）解决RMQ问题的方法。使用ST稀疏表对已知数据进行预处理，对于任意的询问请求都可以以O(1)的效率进行解答，作为一种离线算法，非常高效快速，特别适合用于进行RMQ问题的求解。现在让我们考虑一种动态的RMQ问题，动态是指在我们询问的过程中，区间内某一位置的值会受到外界干预而发生改变，我们需要做的就是在每次改变的基础上对收到的询问给出正确的结果。对于动态RMQ问题我们有如下三种思路： 使用朴素算法进行遍历查找； 使用SparseTable稀疏表进行求解，每次变化更新稀疏表； 使用二分线段树进行求解，每次变化进行相应的信息修改。下面我们在一个较小数据量(10^4)的条件下对上述三种算法进行分析实现。 题目描述【输入】每个测试点（输入文件）有且仅有一组测试数据。每组测试数据的第1行为一个整数N，意义如前文所述。每组测试数据的第2行为N个整数，分别描述每种商品的重量，其中第i个整数表示标号为i的商品的重量weight_i。每组测试数据的第3行为一个整数Q，表示小Hi总共询问的次数与商品的重量被更改的次数之和。每组测试数据的第N+4~N+Q+3行，每行分别描述一次操作，每行的开头均为一个属于0或1的数字，分别表示该行描述一个询问和描述一次商品的重量的更改两种情况。对于第N+i+3行，如果该行描述一个询问，则接下来为两个整数Li, Ri，表示小Hi询问的一个区间[Li, Ri]；如果该行描述一次商品的重量的更改，则接下来为两个整数Pi，Wi，表示位置编号为Pi的商品的重量变更为Wi对于100%的数据，满足N&lt;=10^4，Q&lt;=10^4, 1&lt;=Li&lt;=Ri&lt;=N，1&lt;=Pi&lt;=N, 0&lt;weight_i, Wi&lt;=10^4。 【输出】对于每组测试数据，对于每个询问，按照在输入中出现的顺序，各输出一行，表示查询的结果：标号在区间[Li, Ri]中的所有商品中重量最轻的商品的重量。 【样例输入】 10 618 5122 1923 8934 2518 6024 5406 1020 8291 2647 6 0 3 6 1 2 2009 0 2 2 0 2 10 1 1 5284 0 2 5 【样例输出】 1923 2009 1020 1923 朴素遍历解法算法分析朴素遍历算法也就是对于每个询问区间[l, r]，对区间中的数据进行遍历访问，最后求出其最小值即为所求。其算法复杂度为： 预处理 查询 修改 O(1) O(N) O(1) 预处理：因为是使用一个数组对数据进行存储，所以直接赋值建立数组即可，时间复杂度为O(1); 查询：因为是在一个数组中进行特定下标数据的访问查找，所以时间复杂度为O(N)； 修改：修改操作直接对特定数组下标元素进行赋值即可，所以时间复杂度为O(1)。 总体来说，使用朴素算法思路比较简单，构建也比较容易，只有查询的时候时间复杂度比较高，但对于10^4的数据量还是能够满足的。 最终代码1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#define N 10010using namespace std;int main()&#123; int n, m; int oper, res, a, b; int node[N]; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; node[i]; &#125; cin &gt;&gt; m; while(m--) &#123; cin &gt;&gt; oper &gt;&gt; a &gt;&gt; b; if(oper == 1) &#123; node[a] = b; &#125; else &#123; res = node[a]; for(int i = a; i &lt;= b; ++i) &#123; if(node[i] &lt; res) res = node[i]; &#125; cout &lt;&lt; res &lt;&lt; endl; &#125; &#125; return 0;&#125; SparseTable稀疏表解法算法分析稀疏表算法实质就是一种动态规划的思想，由于数据是动态的，所以每次变化都要修改相应的状态表，其时间复杂度为： 预处理 查询 修改 O(NlogN） O(1) O(N) 预处理：预处理就是生成稀疏表，分别以1、2、4、8 … 2^j为区间进行最小值比较计算，状态转移公式为：$$dp[i][j+1] = min(dp[i][j], dp[i + 2^j][j])$$即用相邻两个2^(j-1)的数据更新2^j，其时间复杂度为O(NlogN); 查询：使用稀疏表可以以O(1)的时间复杂度进行询问的解答； 修改：假设这个位置是a, 那么Len=1时，有1个dp包含a: dp[a, 1]Len=2时，有2个dp包含a: dp[a, 2] dp[a-1, 2]Len=4时，有4个dp包含a: dp[a, 4] dp[a-1, 4] dp[a-2, 4] dp[a-3, 4] …..直到Len=K(最接近N的2的整数幂)时, 有K个dp包含a: dp[a, k] dp[a-1, k] dp[a-2, k] … dp[a-k+1, k]所以总共就有1+2+4+…+K &lt;= 2N个区间即修改的时间复杂度为O(N) 使用SparseTable算法虽然查询的时候能够达到O(1)的时间复杂度，但是因为动态数据进行修改的时间复杂度为O(N)，所以其时间复杂度也比较高。 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#define N 10010using namespace std;int main()&#123; int n, m; int res, oper, a, b, k; int weight[N][15]; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; weight[i][0]; &#125; k = log2(n); for(int j = 1; j &lt;= k; ++j) &#123; for(int i = 1; i + (1&lt;&lt;j) - 1 &lt;= n; ++i) &#123; weight[i][j] = min(weight[i][j-1], weight[i + (1&lt;&lt;(j-1))][j-1]); &#125; &#125; cin &gt;&gt; m; while(m--) &#123; cin &gt;&gt; oper &gt;&gt; a &gt;&gt; b; if(oper == 0) &#123; k = log2(b - a + 1); cout &lt;&lt; min(weight[a][k], weight[b - (1&lt;&lt;k) + 1][k]) &lt;&lt; endl; &#125; else &#123; weight[a][0] = b; for(int j = 1; j &lt;= log2(n); ++j) &#123; for(int i = a; a - i &lt; (1&lt;&lt;j) &amp;&amp; i &gt; 0; --i) &#123; if(i + (1&lt;&lt;j) - 1 &lt;= n) weight[i][j] = min(b, weight[i][j]); else continue; &#125; &#125; &#125; &#125; return 0;&#125; 线段树解法算法分析线段树(Segment Tree)是一种二叉搜索树，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。对于线段树中的每个非叶子结点[a, b]，它的左子树代表的区间为[a,(a+b)/2]，右子树表示的区间为[(a+b)/2+1,b]。因此线段树是平衡二叉树。叶节点数目为N，即整个线段区间的长度。使用线段树算法的时间复杂度为： 预处理 查询 修改 O(N） O(logN) O(logN) 预处理：预处理即建树过程，使用DFS深度优先遍历构建树结构的时候每个结点都需要访问一次，更新每个结点的最小值的时候同样使用DFS对每个结点进行遍历，即每个结点访问两次执行操作，时间复杂度为O(N)； 查询：对于查询，最复杂的情况就是一直遍历到树的底部也就是叶子结点，即查询区间内某一端点遍历到叶子结点，除此结点外的区间均在此前获得结果，所以查询的时间复杂度就是树的高度，也就是O(logN); 修改：修改需要从树的底部，即从该叶子结点开始，更新修改其所有的祖先结点，即树的每一层修改一次，时间复杂度就是树的高度，即为O(logN)。 相对于朴素解法和SparseTable稀疏表解法修改和查询操作都有一个操作的时间复杂度为O(N)，我们使用线段树的方法得到了一个查询和修改时间复杂度均为O(logN)的算法，实现了两种操作时间复杂度的平衡。 最终代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//二分线段树#include &lt;iostream&gt;#include &lt;map&gt;#define N 10010using namespace std;typedef struct node&#123; int left, right, value; node *father, *lchild, *rchild; node() &#123; left = right = value = 0; father = lchild = rchild = NULL; &#125; node(int left_, int right_) : left(left_), right(right_) &#123; value = 0; father = NULL; lchild = NULL; rchild = NULL; &#125;&#125;*Node;int n, m;int weight[N];map&lt;int, Node&gt; findNode;Node root;void build(Node p)&#123; if(p-&gt;left == p-&gt;right) return; int mid = (p-&gt;left + p-&gt;right) / 2; p-&gt;lchild = new node(p-&gt;left, mid); p-&gt;lchild-&gt;father = p; p-&gt;rchild = new node(mid+1, p-&gt;right); p-&gt;rchild-&gt;father = p; build(p-&gt;lchild); build(p-&gt;rchild);&#125;void dfs(Node p)&#123; if(p-&gt;left == p-&gt;right) &#123; p-&gt;value = weight[p-&gt;left]; findNode[p-&gt;left] = p; return; &#125; dfs(p-&gt;lchild); dfs(p-&gt;rchild); p-&gt;value = min(p-&gt;lchild-&gt;value, p-&gt;rchild-&gt;value);&#125;void modify(Node p)&#123; p-&gt;value = min(p-&gt;lchild-&gt;value, p-&gt;rchild-&gt;value); if(p-&gt;father) modify(p-&gt;father);&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) cin &gt;&gt; weight[i]; root = new node(1, n); build(root); dfs(root); int a, b, oper; cin &gt;&gt; m; while(m--) &#123; cin &gt;&gt; oper &gt;&gt; a &gt;&gt; b; if(oper == 0) &#123; cout &lt;&lt; query(root, a, b) &lt;&lt; endl; &#125; else &#123; weight[a] = b; findNode[a]-&gt;value = b; modify(findNode[a]-&gt;father); &#125; &#125; return 0;&#125; 二分线段树在更大数据量下的使用正如我们上面所说的，我们使用线段树的方法得到了一个查询和修改时间复杂度均为O(logN)的算法，实现了两种操作时间复杂度的平衡。由于上面题目要求的是10^4较小的数据量，所以三种方法都可以满足要求，但是如果我们将上述题目的数据量提高到10^6，数据量扩大了100倍，此时只有使用二分线段树才能够在规定时间内完成运算，其他两种方法均会超时。 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//二分线段树#include &lt;iostream&gt;#include &lt;map&gt;#define N 1000010using namespace std;typedef struct node&#123; int left, right, value; node *father, *lchild, *rchild; node() &#123; left = right = value = 0; father = lchild = rchild = NULL; &#125; node(int left_, int right_) : left(left_), right(right_) &#123; value = 0; father = NULL; lchild = NULL; rchild = NULL; &#125;&#125;*Node;int n, m;int weight[N];Node findNode[N];Node root;void build(Node p)&#123; if(p-&gt;left == p-&gt;right) return; int mid = (p-&gt;left + p-&gt;right) / 2; p-&gt;lchild = new node(p-&gt;left, mid); p-&gt;lchild-&gt;father = p; p-&gt;rchild = new node(mid+1, p-&gt;right); p-&gt;rchild-&gt;father = p; build(p-&gt;lchild); build(p-&gt;rchild);&#125;void dfs(Node p)&#123; if(p-&gt;left == p-&gt;right) &#123; p-&gt;value = weight[p-&gt;left]; findNode[p-&gt;left] = p; return; &#125; dfs(p-&gt;lchild); dfs(p-&gt;rchild); p-&gt;value = min(p-&gt;lchild-&gt;value, p-&gt;rchild-&gt;value);&#125;int query(Node p, int l, int r)&#123; if(l &lt;= p-&gt;left &amp;&amp; r &gt;= p-&gt;right) return p-&gt;value; int mid = (p-&gt;left + p-&gt;right) / 2; if(r &lt;= mid) return query(p-&gt;lchild, l, r); else if(mid &lt; l) return query(p-&gt;rchild, l, r); else return min(query(p-&gt;lchild, l, mid), query(p-&gt;rchild, mid+1, r));&#125;void modify(Node p)&#123; p-&gt;value = min(p-&gt;lchild-&gt;value, p-&gt;rchild-&gt;value); if(p-&gt;father) modify(p-&gt;father);&#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;weight[i]); root = new node(1, n); build(root); dfs(root); int a, b, oper; scanf("%d", &amp;m); while(m--) &#123; scanf("%d%d%d", &amp;oper, &amp;a, &amp;b); if(oper == 0) &#123; printf("%d\n", query(root, a, b)); &#125; else &#123; weight[a] = b; findNode[a]-&gt;value = b; modify(findNode[a]-&gt;father); &#125; &#125; return 0;&#125; 注：这里为了提高算法效率将之前使用的cin和cout分别替换成scanf和printf。 平衡之于算法 方法 预处理 查询 修改 朴素算法 O(1) O(N) O(1) ST稀疏表 O(NlogN） O(1) O(N) 线段树 O(N） O(logN) O(logN) 平衡：无论是我们平时接触比较多的二叉平衡树，还是我们这次使用的二分线段树，都是通过一种平衡的方式实现了算法操作的优化升级； 对于算法，我们讲究时间复杂度和空间复杂度，而且我们有各种时间换取空间和空间换取时间的例子，最普遍的动态规划就是一种空间换取时间的方法，两者之间也存在一种相互转换的平衡； 针对上面的RMQ例题，如果我们99.9%的操作是进行修改，其余0.1%的操作是进行查询，则使用朴素算法最为适合，他的修改操作时间复杂度为O(1)；反之如果是99.9%的查询和0.1%的修改，则使用SparseTable稀疏表算法更为合适，查询操作时间复杂度为O(1)；然而对于比例相当或者不确定的请求就应该使用二分线段树这种平衡两种操作时间复杂度的算法了，这就是一种平衡、一种中庸的做法。 正所谓平衡之于算法之道！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>RMQ</tag>
        <tag>Alogrithm</tag>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用RMQ-ST算法解决最近公共祖先问题]]></title>
    <url>%2F2016%2F07%2F27%2F%E4%BD%BF%E7%94%A8RMQ-ST%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[之前我们曾介绍了两种求解最近公共祖先的方法【链接】，分别使用了并查集方法和DFS深度优先遍历的方法，其中并查集方法虽然思路简单，但是时间效率并不高，只适用于样本值较少的情况下，而对于深度优先遍历DFS这种离线算法我们很难决定是当有询问发生的时候旧进行遍历求解还是等待一定数量的请求之后再进行遍历求解，毕竟无论多次请求还是一次请求，我们的求解过程都是进行一趟遍历。所以我们希望只针对一个询问就可以开展计算，同时还要有着较高的时间效率，所以本文将介绍一种使用RMQ-ST算法的在线求解算法，关于RMQ-ST算法可以参考上篇博文【链接】。 题目描述【输入】每个测试点（输入文件）有且仅有一组测试数据。每组测试数据的第1行为一个整数N，意义如前文所述。每组测试数据的第2~N+1行，每行分别描述一对父子关系，其中第i+1行为两个由大小写字母组成的字符串Father_i, Son_i，分别表示父亲的名字和儿子的名字。每组测试数据的第N+2行为一个整数M，表示小Hi总共询问的次数。每组测试数据的第N+3~N+M+2行，每行分别描述一个询问，其中第N+i+2行为两个由大小写字母组成的字符串Name1_i, Name2_i，分别表示小Hi询问中的两个名字。对于100%的数据，满足N&lt;=10^5，M&lt;=10^5, 且数据中所有涉及的人物中不存在两个名字相同的人（即姓名唯一的确定了一个人），所有询问中出现过的名字均在之前所描述的N对父子关系中出现过，且每个输入文件中第一个出现的名字所确定的人是其他所有人的公共祖先。【输出】对于每组测试数据，对于每个询问，按照在输入中出现的顺序，各输出一行，表示查询的结果：他们的所有共同祖先中辈分最低的一个人的名字。【样例输入】 4 Adam Sam Sam Joey Sam Micheal Adam Kevin 3 Sam Sam Adam Sam Micheal Kevin 【样例输出】 Sam Adam Adam 解题思路 最近公共祖先其实就是树结构中两点连线的折点； 也就是说是两点路径中深度最小的那个点； 通过使用深度优先遍历，遍历整棵树，每当进入一个结点就将其记录下来，离开的时候即他所在的分支已遍历完成，则将其父亲结点记录下来，从而完成从树结构到数组的转换； 使用RMQ-ST算法对此数组进行求解，求出状态方程； 对于给定的询问，只需要计算其遍历区间，然后使用RMQ-ST算法取其中的深度最小值，最后将对应结点字符串打印出来即可。 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#define N 100010using namespace std;typedef struct node&#123; string name; int depth; int id; node* father; vector&lt;node*&gt; child; node(string name_) : name(name_) &#123; depth = 0; id = 0; father = NULL; &#125;&#125;*Node;int n, m;int cnt = 0;int num = 0;Node root = NULL;map&lt;string, Node&gt; tree;//储存树结构map&lt;string, int&gt; seq;//储存询问字符串与序号的映射map&lt;int, string&gt; seq2;//与seq相反的映射vector&lt;pair&lt;int, int&gt;&gt; dp[19];//储存RMQ-ST的状态信息void dfs(Node p, int d)&#123; p-&gt;depth = d; p-&gt;id = num++; seq[p-&gt;name] = cnt; seq2[cnt] = p-&gt;name; dp[0].push_back(make_pair(p-&gt;depth, cnt++)); for(int i = 0; i &lt; p-&gt;child.size(); ++i) &#123; dfs(p-&gt;child[i], d+1); &#125; if(p-&gt;father) &#123; seq[p-&gt;father-&gt;name] = cnt; seq2[cnt] = p-&gt;father-&gt;name; dp[0].push_back(make_pair(p-&gt;father-&gt;depth, cnt++)); &#125;&#125;void st()&#123; //因为是n行，对应n+1个结点，所以是2 × n + 1 int k = log2(2 * n + 1); for(int i = 1; i &lt;= k; ++i) &#123; for(int j = 0; j + (1&lt;&lt;i) - 1 &lt; 2 * n + 1; ++j) &#123; int next = j + (1&lt;&lt;(i-1)); if(dp[i-1][j].first &lt; dp[i-1][next].first) dp[i].push_back(dp[i-1][j]); else dp[i].push_back(dp[i-1][next]); &#125; &#125;&#125;int main()&#123; string s1, s2; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; s1 &gt;&gt; s2; if(tree.find(s1) == tree.end()) tree[s1] = new node(s1); if(tree.find(s2) == tree.end()) tree[s2] = new node(s2); tree[s1]-&gt;child.push_back(tree[s2]); tree[s2]-&gt;father = tree[s1]; if(i == 0) root = tree[s1]; &#125; dfs(root, 0); st(); cin &gt;&gt; m; while(m--) &#123; cin &gt;&gt; s1 &gt;&gt; s2; int l, r, res, temp; l = seq[s1]; r = seq[s2]; if(l &gt; r) //这里需要判断输入的字符串的顺序 swap(l, r); int k = log2(r - l + 1); if(dp[k][l].first &lt; dp[k][r - (1&lt;&lt;k) + 1].first) res = dp[k][l].second; else res = dp[k][r - (1&lt;&lt;k) + 1].second; cout &lt;&lt; seq2[res] &lt;&lt; endl; &#125; return 0;&#125; 总结 这道题目完全按照自己的思路一直写下去，写了一天，最后终于AC的时候激动的都要拍桌子了，太有成就感了！ 所有的问题只要肯下功夫，一点一点理清思路，都是可以做出来的，后面优化可以参考别人的代码。所以写代码一定要耐心，细心，按照思路一点一点抽丝剥茧。 写代码的时间不一定要很长，思考才是最重要的，思路清晰才是我们解决问题的根本！ 解决bug的时候一定要耐心，多顺几遍思路，不会GDB就多用打印cout，一点点排查错误。不能AC就一定有问题，有问题就一定有解决办法！ 写代码需要多写多练多读，需要的是时间的积累和经验的总结，所以要坚持、多写、多多总结！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>公共祖先</tag>
        <tag>RMQ-ST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RMQ问题的ST稀疏表解法]]></title>
    <url>%2F2016%2F07%2F26%2FRMQ%E9%97%AE%E9%A2%98%E7%9A%84ST%E7%A8%80%E7%96%8F%E6%A0%91%E8%A7%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[RMQ问题(Random Minimum/Maximum Query, 即区间最值问题)，指的是给定一个长度为n的数列A，对于A数列进行若干次询问，询问在闭区间[l, r]之中的最小/最大值是多少。RMQ问题有很多种解法，包括朴素算法、线段树、ST算法等，本文主要介绍使用ST稀疏表算法。 ST算法思想ST(Sparse Table, 稀疏表)可以以O(nlogn)的时间效率对RMQ问题进行预处理，然后以O(1)的时间效率回答每个问题。ST算法的实质是一种动态规划算法，我们定义了状态数组dp[i][j]表示从数组下标i开始包含$2^j$个数组元素在内的子数组中最小/大值。则此时，假设我们令$dp[1][0] = 2$, $dp[2][0] = 3$,则$dp[1][1] = min(dp[1][0], dp[2][0])$。即当我们需要求$dp[i][j+1]$的时候，我们可以将这一段子数组分成两段，分别求取两段的最值$dp[i][j]$和$dp[i+2^j][j]$，最后取这两个的最值的比较结果就可以得到结果。所以预处理的状态转移方程为$$dp[i][j+1] = min(dp[i][j], dp[i+2^j][j])$$只要初始化当$j==0$的时候，最值是本身就可以很轻松的完成预处理。针对题目要求，求取对任意给定的闭区间[l,r]中的最值，我只要找到小于这个区间长度的最大的2的非负整数次幂——T，分别求取前一段$dp[l][T]$和后一段$dp[r - s^T + 1][T]$最后进行比较就可以得出整个区间的结果，所以$$RMQ(l, r) = min(dp[l][T], dp[r - 2^T + 1][T])$$其中$T = log_2(r-l+1)$。 题目要求【输入】每个测试点（输入文件）有且仅有一组测试数据。每组测试数据的第1行为一个整数N，意义如前文所述。每组测试数据的第2行为N个整数，分别描述每种商品的重量，其中第i个整数表示标号为i的商品的重量weight_i。每组测试数据的第3行为一个整数Q，表示小Hi总共询问的次数。每组测试数据的第N+4~N+Q+3行，每行分别描述一个询问，其中第N+i+3行为两个整数Li, Ri，表示小Hi询问的一个区间[Li, Ri]。对于100%的数据，满足N&lt;=10^6，Q&lt;=10^6, 1&lt;=Li&lt;=Ri&lt;=N，0&lt;weight_i&lt;=10^4。【输出】对于每组测试数据，对于每个小Hi的询问，按照在输入中出现的顺序，各输出一行，表示查询的结果：标号在区间[Li, Ri]中的所有商品中重量最轻的商品的重量。【样例输入】 10 7334 1556 8286 1640 2699 4807 8068 981 4120 2179 5 3 4 2 8 2 4 6 8 7 10 【样例输出】 1640 981 1556 981 981 最终代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define N 1000010int dp[N][20];int main()&#123; int n, m, next; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) cin &gt;&gt; dp[i][0]; int k = log2(n); for(int j = 1; j &lt;= k; ++j) &#123; for(int i = 0; i+(1&lt;&lt;j)-1 &lt; n; ++i) &#123; next = i + (1&lt;&lt;(j-1)); dp[i][j] = min(dp[i][j-1], dp[next][j-1]); &#125; &#125; cin &gt;&gt; m; int l, r; while(m--) &#123; cin &gt;&gt; l &gt;&gt; r; l--; r--; k = log2(r - l + 1); cout &lt;&lt; min(dp[l][k], dp[r - (1&lt;&lt;k) + 1][k]) &lt;&lt; endl; &#125; return 0;&#125; 总结 位运算在算法中使用得当会有非常神奇的效果！！ 使用using namespace std之后可以直接调用min(),max()功能函数，同时也不可以再以“max”或者“min”为变量名或函数名声明新的变量、函数。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>RMQ</tag>
        <tag>ST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近公共祖先问题]]></title>
    <url>%2F2016%2F07%2F24%2F%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近公共祖先问题，即LCA（Lowest Common Ancestors）问题，是一个基于并查集和深度优先搜索的算法问题。题目假设我们已经知道了N个人的信息——他们的父亲是谁，然后对任意输入的两个人名，给出这两个人公共祖先中辈分最低的一个祖先。 并查集方法题目介绍输入输出介绍和样例如下，题目出自hihoCoder。（点击查看原题介绍讲述）【输入】每个测试点（输入文件）有且仅有一组测试数据。每组测试数据的第1行为一个整数N，意义如前文所述。每组测试数据的第2~N+1行，每行分别描述一对父子关系，其中第i+1行为两个由大小写字母组成的字符串Father_i, Son_i，分别表示父亲的名字和儿子的名字。每组测试数据的第N+2行为一个整数M，表示小Hi总共询问的次数。每组测试数据的第N+3~N+M+2行，每行分别描述一个询问，其中第N+i+2行为两个由大小写字母组成的字符串Name1_i, Name2_i，分别表示询问中的两个名字。对于100%的数据，满足N&lt;=10^2，M&lt;=10^2, 且数据中所有涉及的人物中不存在两个名字相同的人（即姓名唯一的确定了一个人）。【输出】对于每组测试数据，输出一行，表示查询的结果：如果根据已知信息，可以判定询问中的两个人存在共同的祖先，则输出他们的所有共同祖先中辈分最低的一个人的名字，否则输出-1。【样例输入】 11 JiaYan JiaDaihua JiaDaihua JiaFu JiaDaihua JiaJing JiaJing JiaZhen JiaZhen JiaRong JiaYuan JiaDaishan JiaDaishan JiaShe JiaDaishan JiaZheng JiaShe JiaLian JiaZheng JiaZhu JiaZheng JiaBaoyu 3 JiaBaoyu JiaLian JiaBaoyu JiaZheng JiaBaoyu LinDaiyu 【样例输出】 JiaDaishan JiaZheng -1 题目分析 使用map&lt;string, string&gt;存储两个名字之间的辈分关系； 使用map&lt;string, int&gt;存储其中一个人名的迭代查找结果，其中int只是为了创建map； 对第二个人名进行迭代查找，若查找结果在map&lt;string, int&gt;中，则直接打印即为最近公共祖先； 最终代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int main()&#123; int n, p; cin &gt;&gt; n; string fa, son, s1, s2; map&lt;string, string&gt; m; map&lt;string, string&gt;::iterator it; map&lt;string, int&gt; vec; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; fa &gt;&gt; son; m.insert(make_pair(son, fa)); &#125; cin &gt;&gt; p; while(p--) &#123; vec.clear(); cin &gt;&gt; s1 &gt;&gt; s2; vec.insert(make_pair(s1, 0)); it = m.find(s1); while(it != m.end()) &#123; vec.insert(make_pair((*it).second, 0)); it = m.find((*it).second); &#125; if(vec.find(s2) != vec.end()) &#123; cout &lt;&lt; s2 &lt;&lt; endl; continue; &#125; it = m.find(s2); while(it != m.end()) &#123; if(vec.find((*it).second) != vec.end()) &#123; cout &lt;&lt; (*it).second &lt;&lt; endl; break; &#125; else it = m.find((*it).second); &#125; if(it == m.end()) cout &lt;&lt; -1 &lt;&lt; endl; &#125; return 0;&#125; 总结 使用上述方法由于需要对数据进行遍历，所以时间效率很低，在用户样本信息较少的情况下比较适用。 深度优先搜索由于上述方法只使用与样本数量较少的情况下，所以接下来我们提出一种能够应用于大样本的深度优先搜索的算法。 题目描述题目描述与上一题目基本一致，同样来源hihoCoder，题目详情请点击查看。【输入】每个测试点（输入文件）有且仅有一组测试数据。每组测试数据的第1行为一个整数N，意义如前文所述。每组测试数据的第2~N+1行，每行分别描述一对父子关系，其中第i+1行为两个由大小写字母组成的字符串Father_i, Son_i，分别表示父亲的名字和儿子的名字。每组测试数据的第N+2行为一个整数M，表示小Hi总共询问的次数。每组测试数据的第N+3~N+M+2行，每行分别描述一个询问，其中第N+i+2行为两个由大小写字母组成的字符串Name1_i, Name2_i，分别表示小Hi询问中的两个名字。对于100%的数据，满足N&lt;=10^5，M&lt;=10^5, 且数据中所有涉及的人物中不存在两个名字相同的人（即姓名唯一的确定了一个人），所有询问中出现过的名字均在之前所描述的N对父子关系中出现过，第一个出现的名字所确定的人是其他所有人的公共祖先。【输出】对于每组测试数据，对于每个小Hi的询问，按照在输入中出现的顺序，各输出一行，表示查询的结果：他们的所有共同祖先中辈分最低的一个人的名字。【样例输入】 4 Adam Sam Sam Joey Sam Micheal Adam Kevin 3 Sam Sam Adam Sam Micheal Kevin 【样例输出】 Sam Adam Adam 题目分析 通过对家族树的各个结点进行深度优先遍历，没有遍历到的树的颜色为白色（0），第一次遍历之后为灰色（1），离开时置为黑色（2）； 遍历至一请求结点A，将其置为灰色，若其对应的询问结点B为白色，则未询问到次结点，继续深度遍历； 若对应询问结点B为灰色，则两个询问结点在同一分支上，则深度优先搜索尚未离开分支，取请求结点A的名字即为公共祖先； 若对应询问结点B为黑色，则深度优先搜索已经离开该询问结点B，取该黑色结点B的上一个结点名字即为公共祖先； 建立如下node结点： 123456789101112typedef struct node&#123; string name; node* father; int color; vector&lt;node*&gt; child; node(string name_) : name(name_) &#123; father = NULL; color = 0; &#125;&#125;*Node; 使用map&lt;string, Node&gt;存储名字与结点的映射关系；使用map&lt;string, vector&lt;pair&lt;Node, int&gt;&gt;&gt;存储询问结点姓名与结点、序号的映射关系。 最终代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;#define N 100010typedef struct node&#123; string name; node* father; int color; vector&lt;node*&gt; child; node(string name_) : name(name_) &#123; father = NULL; color = 0; &#125;&#125;*Node;string res[N];map&lt;string, Node&gt; tree;map&lt;string, Node&gt;::iterator it;typedef pair&lt;Node, int&gt; NodeNum;map&lt;string, vector&lt;NodeNum&gt;&gt; query;Node findRoot(Node p)&#123; if(p-&gt;color == 1) return p; else &#123; p-&gt;father = findRoot(p-&gt;father); return p-&gt;father; &#125;&#125;void dfs(Node p)&#123; p-&gt;color = 1; vector&lt;NodeNum&gt; &amp;pChild = query[p-&gt;name]; for(int i = 0; i &lt; pChild.size(); ++i) &#123; Node pQuery = pChild[i].first; int id = pChild[i].second; if(pQuery-&gt;color == 0) continue; res[id] = findRoot(pQuery)-&gt;name; &#125; for(int i = 0; i &lt; p-&gt;child.size(); ++i) &#123; dfs(p-&gt;child[i]); &#125; p-&gt;color = 2;&#125;int main()&#123; Node root = NULL; string s1, s2; int n, m; cin &gt;&gt; n; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; s1 &gt;&gt; s2; if(tree.find(s1) == tree.end()) tree[s1] = new node(s1); if(tree.find(s2) == tree.end()) tree[s2] = new node(s2); tree[s1]-&gt;child.push_back(tree[s2]); tree[s2]-&gt;father = tree[s1]; if(i ==0) root = tree[s1]; &#125; cin &gt;&gt; m; for(int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; s1 &gt;&gt; s2; if(query.find(s1) == query.end()) query[s1] = vector&lt;NodeNum&gt;(); if(query.find(s2) == query.end()) query[s2] = vector&lt;NodeNum&gt;(); Node p1 = tree[s1]; Node p2 = tree[s2]; query[s1].push_back(make_pair(p2, i)); if(s1 != s2) query[s2].push_back(make_pair(p1, i)); &#125; dfs(root); for(int i = 0; i &lt; m; ++i) cout &lt;&lt; res[i] &lt;&lt; endl; return 0;&#125; 总结 使用这种深度优先搜索的方法，同时兼顾使用了并查集的思想维护遍历过程中的辈分关系，能够高效地处理较大数据量的公共祖先问题； map实在是太好用了，可以建立各种类型之间的映射关系，使用map[key]还可以直接取出&lt;key, value&gt;中的value，即map[key] = value，大大方便了信息的存储与管理； 首次遍历到结点，将其置为灰色（1），离开该结点时将其置为黑色（2），这种分析问题的方法非常值得借鉴使用。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
        <tag>DFS</tag>
        <tag>公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划之二叉苹果树及其变形]]></title>
    <url>%2F2016%2F07%2F21%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91%E5%8F%8A%E5%85%B6%E5%8F%98%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[二叉苹果树作为树形规划的经典例题，对于我们学习动态规划有着很大的借鉴意义，本文通过介绍二叉苹果树的一种解法思路以及二叉苹果树的另一种变形，深入理解动态规划的思想和方式。 二叉苹果树题目要求有一棵苹果树，苹果树的是一棵完全二叉树，共N个节点，树节点编号为1~N，编号为1的节点为树根，边可理解为树的分枝，每个分支都长着若干个苹果（每条边有值对应树枝上的苹果数量），现在要要求减去若干个分支，保留M个分支，要求这M个分支的苹果数量最多。【输入格式】第 1 行 2 个数，N 和 Q(1&lt;=Q&lt;= N,1&lt;N&lt;=100)。N 表示树的结点数，Q 表示要保留的树枝数量。接下来 N-1 行描述树枝的信息。每行 3 个整数，前两个是它连接的结点的编号。第 3 个数是这根树枝上苹果的数量。每根树枝上的苹果不超过 30000 个。【输出格式】一个数，最多能留住的苹果的数量。【输入样例】 5 2 1 3 1 1 4 10 2 3 20 3 5 20 【输出样例】 21 解题思路 要求的结果是以1号根节点为根的M个分支所能具有的最多苹果数量 由于是完全二叉树，所以每个结点有且只有可能有两个儿子结点，否则就是叶子结点； 使用一个vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;存储树的结构，将每条分支的权值分配给儿子结点； 使用res[i][j]表示以i结点为根节点的j个分支能包含的最大苹果数量，使用tot[i]表示以i结点（包括i结点本身）为根节点的子树所包含的结点总数； 使用动态规划的思路来进行求解，状态转移方程为：res[i][j] = max{res[i][j], res[i][j-k] + res[i_child][k]}，其中1&lt;=k&lt;j。注意：这里j需要从大到小遍历，这样当j=4时求取res[i][4]时，k=1,2,3时读取的res[i][3], res[i][2], res[i][1]因为之前的计算结果所以不包含i_child子树中的结点，其他同理，从而避免了重复的结点选择。 使用深度优先搜索DFS来对树结构进行遍历，从下而上对各结点的状态方程进行求解； 最终代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, q;vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; tree(101);//存储树结构int res[101][101] = &#123;0&#125;;//存储DP结果int tot[101] = &#123;0&#125;;//存储每个结点子树的结点总数int dfs(int cur, int fa)&#123; tot[cur] = 1; for(int i = 0; i &lt; tree[cur].size(); ++i) &#123; int Child = tree[cur][i].first; if(Child == fa) continue; tot[cur] += dfs(Child, cur); &#125; //分别对每个子树进行遍历 for(int i = 0; i &lt; tree[cur].size(); ++i) &#123; int Child = tree[cur][i].first; int Value = tree[cur][i].second; if(Child == fa) continue; //j需要从大到小进行遍历 for(int j = tot[cur]; j&gt;1; --j) &#123; for(int k = 1; (k&lt;j)&amp;&amp;(k&lt;=tot[Child]); ++k) //此前的res[cur][j]并不包含Child子树中的结点 res[cur][j] = max(res[cur][j], res[cur][j-k] + res[Child][k] + Value); &#125; &#125; return tot[cur];&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; q; int a, b, v; for(int i = 1; i &lt; n; ++i) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; v; tree[a].push_back(make_pair(b, v)); tree[b].push_back(make_pair(a, v)); &#125; dfs(1, -1); cout &lt;&lt; res[1][q+1] &lt;&lt; endl; for(int i = 1; i &lt;= n; ++i) cout &lt;&lt; tot[i] &lt;&lt; " "; cout &lt;&lt; endl; return 0;&#125; 二叉苹果树变形题目描述相对于二叉苹果树设定两个结点之间的分支上含有苹果的数量，现在设定每个结点都有一个权值，代表该结点上的苹果数量，现在仍然以1号结点为根节点，一共包含N个结点，求取当我进行剪枝之后所剩的M个结点（包括根结点）所能获得的最大的数量。并且，本次树结构可以是以1号结点为根结点的各种形状。【输入】每个测试点（输入文件）有且仅有一组测试数据。每组测试数据的第一行为两个整数N、M，意义如前文所述。每组测试数据的第二行为N个整数，其中第i个整数Vi表示标号为i的结点的评分每组测试数据的第3~N+1行，每行分别描述一根木棍，其中第i+1行为两个整数Ai，Bi，表示第i根木棍连接的两个小球的编号。【输出】对于每组测试数据，输出一个整数Ans，表示使得涂漆结点的评分之和最高可能是多少。【样例输入】 10 4 370 328 750 930 604 732 159 167 945 210 1 2 2 3 1 4 1 5 4 6 4 7 4 8 6 9 5 10 【样例输出】 2977 解题思路 同上一题，使用vector]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树形规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划之加分二叉树]]></title>
    <url>%2F2016%2F07%2F19%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%A0%91%E5%BD%A2%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[动态规划是我们最常用的算法之一，在我看来动态规划就是利用额外内存空间将运算过程中所需要的重复变量进行记录，下次访问使用的时候直接进行读取从而减少了额外的重复计算，提高了算法的效率，从某种角度来说也算是空间换取时间的一种方式。道理很简单，动态规划的核心是我们对问题的分割和思考，如何构建状态转移方程、分割事件，如何分解一整个问题，这才是动态规划最核心的解决问题的核心思想。树归即树形动态规划，是在树形结构中使用动态规划的一类问题。因为树形结构没有环，进行深度优先遍历搜索的时候不会重复进行，再加上树形结构本身有着良好的性质和特点，树归的问题非常多，思路也特别有意思。下面将对我在学习过程中遇到的树归问题进行介绍和记录。 加分二叉树题目要求【问题描述】 设一个n个节点的二叉树tree的中序遍历为（l,2,3,…,n），其中数字1,2,3,…,n为节点编号。 每个节点都有一个分数（均为正整数），记第i个节点的分数为di，tree及它的每个子树都 有一个加分，任一棵子树subtree（也包含tree本身）的加分计算方法如下： subtree的左子树的加分× subtree的右子树的加分＋subtree的根的分数 若某个子树为空，规定其加分为1，叶子的加分就是叶节点本身的分数。不考虑它的空子树。 试求一棵符合中序遍历为（1,2,3,…,n）且加分最高的二叉树tree。要求输出； （1）tree的最高加分 （2）tree的前序遍历【输入格式】 第1行：一个整数n（n＜30），为节点个数。 第2行：n个用空格隔开的整数，为每个节点的分数（分数＜100）。【输出格式】 第1行：一个整数，为最高加分（结果不会超过4,000,000,000）。 第2行：n个用空格隔开的整数，为该树的前序遍历。【输入样例】 5 5 7 1 2 10 【输出样例】 145 3 1 2 4 5 解题思路首先分析题目，最直观的解决方法是对问题进行遍历求解，设置起始点i(1=&lt;i&lt;=n)、末结点j(1=&lt;j&lt;=n)和根节点k(i=&lt;k&lt;=j)，依次进行遍历求解，但是这种方法时间复杂度非常高达到了O(n^3)，同时我们发现在(i, k, j)分别取(1, 5, 9)和(2, 5, 9)的时候，由于两种情况下都包含了(k==5 &amp;&amp; j==9)这种情况，从而进行了不必要的重复运算，这时候就可以考虑使用动态规划来存储重复计算的结构变量，从而对问题解法进行优化。这里我们设置dp[i][j]用来表示从第i个结点到第j个结点的最大分数值，建立dp数组将其存储下来，就可以在之后的遍历过程中直接访问使用了，从而大大提高了运算的效率。由此我们也可以得到状态转移方程为：12345678dp[i][j] = max&#123; dp[i][i] + dp[i+1][j], //第i结点作根结点 dp[i+1][i+1] + dp[i][i] * dp[i+2][j], //第i+1结点作根结点 dp[i+2][i+2] + dp[i][i+1] * dp[i+3][j], //第i+2结点作根结点 ... dp[i][j-1] + dp[j][j]; //第j结点作根结点 &#125; 最终代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;using namespace std;int score[100];//存储每个结点分数int root[100][100];//存储根结点int dp[100][100];//存储加分结果int n;//结点数void DP()&#123; //只有一个结点加分树结构 for(int i = 1; i &lt;= n; ++i) &#123; dp[i][i] = score[i]; root[i][i] = i; &#125; //两个结点的加分树结构情况 for(int i = 1; i &lt; n; ++i) &#123; dp[i][i+1] = score[i] + score[i+1]; root[i][i+1] = i; &#125; //遍历区间为d的两个结点之间的最大分数 for(int d = 2; d &lt; n; ++d) &#123; for(int i = 1; i &lt;= n-d; ++i) &#123; int temp; dp[i][i+d] = dp[i][i] + dp[i+1][i+d]; root[i][i+d] = i; for(int j = i+1; j &lt; i+d; ++j) &#123; temp = dp[i][j-1] * dp[j+1][i+d] + dp[j][j]; if(temp &gt; dp[i][i+d]) &#123; dp[i][i+d] = temp; root[i][i+d] = j; &#125; &#125; if(dp[i][i+d-1] + dp[i+d][i+d] &gt; temp) &#123; dp[i][i+d] = dp[i][i+d-1] + dp[i+d][i+d]; root[i][i+d] = i+d; &#125; &#125; &#125;&#125;//前序遍历函数void preOrder(int x, int y)&#123; if(x &lt;= y) &#123; cout &lt;&lt; root[x][y] &lt;&lt; " "; preOrder(x, root[x][y] - 1); preOrder(root[x][y] +1, y); &#125;&#125;int main()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; score[i]; &#125; DP(); cout &lt;&lt; dp[1][n] &lt;&lt; endl; preOrder(1, n); cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>树归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树系列之——二叉树的递归遍历与非递归遍历]]></title>
    <url>%2F2016%2F07%2F12%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%E4%B9%8B%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树是一种非常重要的数据结构，由二叉树演变而来的树堆、红黑树、平衡树、SPlay伸展树等数据结构都在其各自适应领域有着广泛的应用。通过总结这一段时间对二叉树知识的学习，接下来将通过一系列二叉树专题的文章来进行归纳总结。首先让我们来了解一下二叉树的遍历，二叉树有着先序、中序和后序三种遍历顺序，其中中序遍历更是可以直接将二叉树中元素以有序序列输出。因为二叉树本身就是一个递归的结构实现，所以我们可以使用递归很轻松地实现二叉树的三种遍历，同时也可以利用数据栈实现非递归的二叉树三种遍历。 建立二叉树二叉树结构1234567891011typedef struct node&#123; int data; node *left, *right, *father; node(int data_) : data(data_) &#123; left = NULL; right = NULL; father = NULL; &#125;&#125;*Node; 这里定义了一个node结构表示二叉树中的一个结点，Node表示指向一个node结点的指针。 生成二叉树123456789101112131415161718192021222324252627282930Node insert(Node n, int data)&#123; if(root == NULL) &#123; root = new node(data); return root; &#125; else if(data &lt; n-&gt;data) &#123; if(n-&gt;left == NULL) &#123; n-&gt;left = new node(data); n-&gt;left-&gt;father = n; return n-&gt;left; &#125; else return insert(n-&gt;left, data); &#125; else &#123; if(n-&gt;right == NULL) &#123; n-&gt;right = new node(data); n-&gt;right-&gt;father = n; return n-&gt;right; &#125; else return insert(n-&gt;right, data); &#125;&#125; 二叉树递归遍历先序遍历123456789void PreOrder(Node n)&#123; if(n) &#123; cout &lt;&lt; n-&gt;data &lt;&lt; " "; PreOrder(n-&gt;left); PreOrder(n-&gt;right); &#125;&#125; 中序遍历123456789void MidOrder(Node n)&#123; if(n) &#123; MidOrder(n-&gt;left); cout &lt;&lt; n-&gt;data &lt;&lt; " "; MidOrder(n-&gt;right); &#125;&#125; 后序遍历123456789void PosrOrder(Node n)&#123; if(n) &#123; PosrOrder(n-&gt;left); PosrOrder(n-&gt;right); cout &lt;&lt; n-&gt;data &lt;&lt; " "; &#125;&#125; 由上述代码可以清楚看到，使用递归的方式进行二叉树的遍历是非常方便的，我们需要做的就是改变打印操作的位置。 二叉树非递归遍历先序遍历1234567891011121314151617181920void PreOrder2()&#123; stack&lt;Node&gt; s; Node p = root; while(p || !s.empty()) &#123; while(p) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; " "; s.push(p); p = p-&gt;left; &#125; if(!s.empty()) &#123; p = s.top(); s.pop(); p = p-&gt;right; &#125; &#125;&#125; 从根节点开始访问打印结点数据，并将结点入栈； 继续访问结点的左儿子结点，继续执行第一步打印入栈操作； 如果左儿子结点为空，则进行出栈操作，将出栈结点右儿子结点入栈； 直到当前结点为空并且栈为空的时候，结束遍历。 中序遍历1234567891011121314151617181920void MidOrder2()&#123; stack&lt;Node&gt; s; Node p = root; while(p || !s.empty()) &#123; while(p) &#123; s.push(p); p = p-&gt;left; &#125; if(!s.empty()) &#123; p = s.top(); s.pop(); cout &lt;&lt; p-&gt;data &lt;&lt; " "; p = p-&gt;right; &#125; &#125;&#125; 设置初始结点为根节点，依次访问其左儿子结点并依次入栈； 若左儿子结点为空，则进行出栈操作，访问打印该结点数据； 访问当前结点的右儿子结点，并进行第一步操作，继续访问其左儿子结点； 直到当前结点为空并且栈为空，结束遍历。 后序遍历1234567891011121314151617181920212223void PosrOrder2()&#123; stack&lt;Node&gt; s; Node pre, cur; s.push(root); while(!s.empty()) &#123; cur = s.top(); if((cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) || (pre &amp;&amp; (pre == cur-&gt;left || pre == cur-&gt;right))) &#123; cout &lt;&lt; cur-&gt;data &lt;&lt; " "; s.pop(); pre = cur; &#125; else &#123; if(cur-&gt;right) s.push(cur-&gt;right); if(cur-&gt;left) s.push(cur-&gt;left); &#125; &#125;&#125; 设置cur和pre两个结点指针，分别指向当前结点和前一个结点； 如果当前结点curr没有左右儿子结点，则直接执行打印操作； 或者前一结点pre是当前结点的左儿子或右儿子，也直接执行打印操作； 否则，依次将当前结点的右儿子、左儿子依次入栈，先右后左保证先左后右的遍历顺序； 如果栈为空则结束遍历操作； 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;typedef struct node&#123; int data; node *left, *right, *father; node(int data_) : data(data_) &#123; left = NULL; right = NULL; father = NULL; &#125;&#125;*Node;Node root = NULL;Node insert(Node n, int data)&#123; if(root == NULL) &#123; root = new node(data); return root; &#125; else if(data &lt; n-&gt;data) &#123; if(n-&gt;left == NULL) &#123; n-&gt;left = new node(data); n-&gt;left-&gt;father = n; return n-&gt;left; &#125; else return insert(n-&gt;left, data); &#125; else &#123; if(n-&gt;right == NULL) &#123; n-&gt;right = new node(data); n-&gt;right-&gt;father = n; return n-&gt;right; &#125; else return insert(n-&gt;right, data); &#125;&#125;void PreOrder(Node n)&#123; if(n) &#123; cout &lt;&lt; n-&gt;data &lt;&lt; " "; PreOrder(n-&gt;left); PreOrder(n-&gt;right); &#125;&#125;void MidOrder(Node n)&#123; if(n) &#123; MidOrder(n-&gt;left); cout &lt;&lt; n-&gt;data &lt;&lt; " "; MidOrder(n-&gt;right); &#125;&#125;void PosrOrder(Node n)&#123; if(n) &#123; PosrOrder(n-&gt;left); PosrOrder(n-&gt;right); cout &lt;&lt; n-&gt;data &lt;&lt; " "; &#125;&#125;void PreOrder2()&#123; stack&lt;Node&gt; s; Node p = root; while(p || !s.empty()) &#123; while(p) &#123; cout &lt;&lt; p-&gt;data &lt;&lt; " "; s.push(p); p = p-&gt;left; &#125; if(!s.empty()) &#123; p = s.top(); s.pop(); p = p-&gt;right; &#125; &#125;&#125;void MidOrder2()&#123; stack&lt;Node&gt; s; Node p = root; while(p || !s.empty()) &#123; while(p) &#123; s.push(p); p = p-&gt;left; &#125; if(!s.empty()) &#123; p = s.top(); s.pop(); cout &lt;&lt; p-&gt;data &lt;&lt; " "; p = p-&gt;right; &#125; &#125;&#125;void PosrOrder2()&#123; stack&lt;Node&gt; s; Node pre, cur; s.push(root); while(!s.empty()) &#123; cur = s.top(); if((cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL) || (pre &amp;&amp; (pre == cur-&gt;left || pre == cur-&gt;right))) &#123; cout &lt;&lt; cur-&gt;data &lt;&lt; " "; s.pop(); pre = cur; &#125; else &#123; if(cur-&gt;right) s.push(cur-&gt;right); if(cur-&gt;left) s.push(cur-&gt;left); &#125; &#125;&#125;int main()&#123; int num; while(cin &gt;&gt; num) &#123; insert(root, num); &#125; cout &lt;&lt; "前序遍历：" &lt;&lt; endl; PreOrder(root); cout &lt;&lt; endl; PreOrder2(); cout &lt;&lt; endl; cout &lt;&lt; "中续遍历：" &lt;&lt; endl; MidOrder(root); cout &lt;&lt; endl; MidOrder2(); cout &lt;&lt; endl; cout &lt;&lt; "后续遍历：" &lt;&lt; endl; PosrOrder(root); cout &lt;&lt; endl; PosrOrder2(); cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1000 Contributions]]></title>
    <url>%2F2016%2F06%2F16%2F1000-Contributions%2F</url>
    <content type="text"><![CDATA[突破1000 Cons了，小小mark一下！接下来还要继续努力！最近写代码的感悟： 再复杂的算法都是可以梳清理顺的，发明这个算法的人是有思路有其道理可言的，我们需要做的就是耐下心来，一点点抽丝剥茧，总会柳暗花明，水落石出。 先想后写，思路和思考才是算法的核心，停下来多想一想理理思路总是要强过闷头敲键盘的。 学习新的算法，要经常总结经常回顾，不只是算法的熟悉掌握，还会获得新的想法和体会。 一定要耐心，尤其是改Bug的时候，有错误肯定是自己在写代码的过程中粗心大意了呗，往往越是低级的错误越是难查，所以多理理代码流程还是好的。 不只是写代码，做算法还需要各种数学知识、数论基础，都需要我们在平时慢慢积累，在此膜拜一下高德纳Donald_Knuth老爷子，不多说了，我去读《计算机程序设计的艺术》去了。]]></content>
      <categories>
        <category>闲文</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>算法</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言库文件更新总结]]></title>
    <url>%2F2016%2F05%2F30%2FC%E8%AF%AD%E8%A8%80%E5%BA%93%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[使用C语言进行网络编程的过程中会调用各种库文件，对于这些经常用到的库文件，现在分类记录如下，并会随着今后的学习不断进行更新。 C语言库文件包含关系12345678&lt;netinet/in.h&gt; htons htonl&lt;bits/socket.h&gt; sockaddr&lt;arpa/inet.h&gt; inet_addr sockaddr_in(字符串IP转换到网络序IP)&lt;sys/socket.h&gt; socket bind listen send recv&lt;sys/types.h&gt; accept connect&lt;unistd.h&gt; fork close&lt;string.h&gt; memset memcpy&lt;stdlib.h&gt; exit]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>库文件</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文字符串]]></title>
    <url>%2F2016%2F05%2F29%2F%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[一个字符串中连续的一段就是这个字符串的子串，而回文串指的是12421这种从前往后读和从后往前读一模一样的字符串，所以最长回文子串的意思就是这个字符串中最长的身为回文串的子串啦！ 求解思路对于最长回文字符串的求解，有如下要点： 以字符串中每个结点为中心结点，向左向右进行回文字符串的判定求解，遍历字符串得出结果； 在左右判定之前，首先判断中心结点是否处于连续的相同字符子串中，比如abbbab进行判定的时候，应该将中间bbb看做一个整体作为一个结点进行计算； 为了便于判定遍历的结束，在字符串开始添加一个&amp;符号作为结束标志，即将字符串由abbbabba转换成&amp;abbbabba； 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int find(char *ch)&#123; int ans = 1; int i, p, n; for(i = 0; ch[i]; ++i) &#123; p = i; n = i； while(ch[n + 1] == ch[i]) //重复字符子串判定 n++; i = n; //跳过重复字符子串 while(ch[p - 1] == ch[n + 1]) //左右回文字符判定，'&amp;'给出判定的结束标志 &#123; p--; n++; &#125; if(ans &lt; (n - p + 1)) ans = n - p + 1; &#125; return ans;&#125;int main()&#123; int num; char temp[1000002]; temp[0] = '&amp;'; cin &gt;&gt; num; for(int i = 0; i &lt; num; ++i) &#123; cin &gt;&gt; temp + 1; cout &lt;&lt; find(temp) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>String</tag>
        <tag>回文字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EightQueen]]></title>
    <url>%2F2016%2F05%2F24%2FEightQueen%2F</url>
    <content type="text"><![CDATA[八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后。为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解。 解题思路 首先观察可以发现，每一行或者每一列都有且只有一个皇后； 使用一个数组x[8]存储每一行皇后位置所对应的列数。例如：a[2] = 5就表示第二行的皇后位于第五列； 皇后不在一条直线上可以表示为条件x[i] != x[j]； 皇后不在一条斜线上可以表示为条件abs(x[i] - x[j]) != abs(i - j)； 代码思路如上分析，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;int sum = 0;int x[8] = &#123;0&#125;;bool place(int k)&#123; for(int i = 0; i &lt; k; ++i) if(abs(x[k] - x[i]) == abs(k - i) || x[k] == x[i]) return false; return true;&#125;void put_queen(int n)&#123; if( n &gt;= 8) &#123; sum++; cout &lt;&lt; "This is the " &lt;&lt; sum &lt;&lt; "th time!" &lt;&lt; endl; for(int i = 0; i &lt; 8; ++i) &#123; for(int j = 0; j &lt; 8; ++j) &#123; if(j == x[i]) cout &lt;&lt; "* "; //"*" 表示皇后 else cout &lt;&lt; "^ "; //"^" 表示空位 &#125; cout &lt;&lt; endl; &#125; //通过键盘控制每五个一组进行打印 if(sum % 5 == 0) &#123; getchar(); &#125; &#125; else &#123; for(int i = 0; i &lt; 8; ++i) &#123; x[n] = i; if(place(n)) put_queen(n + 1); &#125; &#125;&#125;int main()&#123; put_queen(0); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Algorithm</tag>
        <tag>Eightqueen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统下MySQL读取文件数据ERROR解决]]></title>
    <url>%2F2016%2F04%2F29%2Fmysql%2F</url>
    <content type="text"><![CDATA[在使用MySQL进行文件数据读取的时候，在终端敲入命令行1mysql&gt; LOAD DATA INFILE 'home/pinseng/mysql_learn/shiyanlou/sql6/in.txt' INTO TABLE employee; 会出现如下错误：1ERROR 13 (HY000): Can't get stat of '/var/lib/mysql/home/pinseng/mysql_learn/shiyanlou/sql6/in.txt' (Errcode: 2) 正如下图所示： 数据读取Bug解决方法解决方法如下：仔细观察报错信息发现MySQL的默认路径应该是/var/lib/mysql，如果我们使用home/pinseng/mysql_learn/shiyanlou/sql6/in.txt进行数据的读取最终得到的路径组合为/var/lib/mysql/home/pinseng/mysql_learn/shiyanlou/sql6/in.txt显然MySQL是没有办法读出来的。通过在终端内输入：1mv /home/pinseng/mysql_learn/shiyanlou/sql6/in.txt /var/lib/mysql/mysql_shiyan/ 也就是将in.txt文件移动到MySQL的默认路径下，这时候再进行数据读入工作就可以正常进行了。在MySQL中输入命令如下：1mysql&gt; LOAD DATA INFILE 'in.txt' INTO TABLE employee; 代码流程如下图： 附带输入文件的数据库DROP（删除）方法此时如果想要删除mysql_shiyan这个数据库，因为我们之前在/var/lib/mysql/mysql_shiyan/路径下添加了一个文件，所以将导致数据库删除失败，如下图所示： 错误代码如下：1ERROR 1010 (HY000): Error dropping database (can't rmdir './mysql_shiyan/', errno: 17) 此时，只要移除我们添加的in.txt文件就可以成功完成数据库的删除了，结果如下： 原谅我截图粗糙了一点。。。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Birthday!]]></title>
    <url>%2F2016%2F04%2F21%2Fbirthday%2F</url>
    <content type="text"><![CDATA[今天过生日，也是23岁老大不小了，希望在接下来的日子里，继续沿着心中既定的目标，在码农的道路上撒丫子颠儿着跑！附上今天的Github Contributions： 附上最近最喜欢的一首歌，为自己小小庆生一下： 接下来的日子里继续努力啦啦啦！！！]]></content>
      <categories>
        <category>心迹</category>
      </categories>
      <tags>
        <tag>Birthday</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫问题(Josephus Problem)的两种快速递归算法]]></title>
    <url>%2F2016%2F04%2F18%2FJosephus%2F</url>
    <content type="text"><![CDATA[约瑟夫问题（Josephus Problem）也称“丢手绢问题”，是一道非常经典的算法问题，其解法涉及了链表、递归等算法和数据结构，本文主要分为如下三个内容： 使用C语言定义循环链表，通过遍历链表模拟事件处理过程； 使用数学方法，找出第n - 1步与第n步的关系，通过递归解决问题； 对第二种方法进行优化，加速递归过程，提高算法效率 循环链表（C语言）代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//定义循环链表typedef struct node//定义node结构体&#123; int data; struct node* next;&#125;cLinkList;//typedef struct node* cLinkList;定义一个struct node类型的循环链表//主函数int main()&#123; cLinkList *head, *p, *s, *temp; int n, k; int i = 1; printf("Please enter the total number n:\n"); scanf("%d", &amp;n); printf("Please enter the key value:\n"); scanf("%d", &amp;k); k %= n; head = (cLinkList *)malloc(sizeof(cLinkList)); p = head; p-&gt;next = p;//这里要赋值为p，不能赋值为head，要保持head的位置不变 p-&gt;data = i; for(i = 2; i &lt;= n; i++) &#123; s = (cLinkList *)malloc(sizeof(cLinkList)); s-&gt;data = i; s-&gt;next = p-&gt;next; p-&gt;next = s; p = s; &#125; p = head; int total = n; while(n--) &#123; for(i = 1; i &lt; k - 1; i++) &#123; p = p-&gt;next; &#125; printf("%d-&gt;", p-&gt;next-&gt;data); temp = p-&gt;next;//temp为要删除的元素 p-&gt;next = temp-&gt;next;//链表中跳过temp free(temp);//释放temp p = p-&gt;next;//p向前移动继续寻找 &#125; printf("Done！\n"); return 0;&#125; 运行过程如下： 程序分析这段代码主要使用了循环链表的数据特性和结构特性，非常适合用来进行Josephus问题的模拟，但是相对来说处理问题的复杂度较高，下面将介绍两种更加高效的算法。 第一种递归原理 令f[n]表示当有n个候选人时，最后当选者的编号。则：f[1] = 0f[n] = (f[n - 1] + K) mod n 方法证明上述公式可以用数据归纳法简单证明其正确性： f[1] = 0当只有一个候选人的时候，显然结果应该是0 f[n] = (f[n - 1] + K) mod nf[n - 1]为第n - 1次数到的id序列，则第n次就是再往下数k个，最后进行取模运算即可得到结果序列 这种算法的时间复杂度为O(N)，空间复杂度为O(1)，效率有所提高！ 代码123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int num, n, k; cin &gt;&gt; num; while(num--) &#123; int ret = 0; cin &gt;&gt; n &gt;&gt; k; for(int i = 2; i &lt;= n; ++i) &#123; ret = (ret + k) % i;//ret记录每一次数到的序列号 &#125; cout &lt;&lt; ret &lt;&lt; endl;//输出最终序列结果 &#125; return 0;&#125; 第二种递归原理 在每一轮报数过程中，都有N/K个人退出了队伍，比如N = 10， K = 3，第一轮有N / K = 3三个人退出； 上述第一种方法每次递归的步长为1，这里我们利用上述关系，建立一个步长为N / K的递归过程； 需要注意的是，当N减少到N = K的时候就需要使用第一种递归进行计算； N &gt; K时的递归公式为：ret &lt; N mod K: ret = ret - (N mod K) + Nret &gt;= N mod K: ret = ret - (N mod K) + (ret - N mod K) / (K - 1) 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int josephus(int n, int k)&#123; int ret; if(n == 1) return 0; //n &lt; k的时候使用第一种递归算法 if(n &lt; k) &#123; int ret = 0; for(int i = 2; i &lt;= n; ++i) ret = (ret + k) % i; return ret; &#125; //执行递归过程 ret = josephus(n-n/k,k); if(ret &lt; n % k) &#123; ret = ret - n % k + n; &#125; else &#123; ret = ret - n % k + (ret - n % k ) / (k - 1); &#125; return ret;&#125;int main()&#123; int num; cin &gt;&gt; num; while(num--) &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; cout &lt;&lt; josephus(n, k) &lt;&lt; endl; &#125; return 0;&#125; 代码分析这个算法加快了递归算法的迭代速度，当所求N比较大K比较小的时候比较适用，能够以更快的速度进行求解。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Josephus Problem</tag>
        <tag>约瑟夫问题</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表之循环链表]]></title>
    <url>%2F2016%2F04%2F16%2FcLinkList%2F</url>
    <content type="text"><![CDATA[上期文章介绍了单链表的一些基本功能函数，本次主要介绍循环链表的一些基本功能函数。循环链表其实就是将单链表的最后一个结点指向单链表的头结点，从而构成一个循环结构。本次函数功能主要包括链表创建函数（头插法和尾插法）、链表打印函数和两种链表是否有环的判定函数，以及最后的一个链表清除函数。函数运行如下图所示： 功能函数链表创建函数（头插法）12345678910111213141516//定义循环链表生成函数（头插法）void cListCreatHead(cLinkList *L, int n)&#123; int i; cLinkList *p, *r; p = L; p-&gt;data = rand() % 100 + 1; for(i = 1; i &lt; n; ++i) &#123; r = (cLinkList *)malloc(sizeof(cLinkList)); r-&gt;data = rand() % 100 + 1; r-&gt;next = p; p = r; &#125; L-&gt;next = p;&#125; 这里使用了头插法对链表进行生成操作，L作为cLinkList的一个指针，指向链表的最后一个结点，这里注意最后要将L指向p构建循环。 链表创建函数（尾插法）12345678910111213141516//定义循环链表生成函数（尾插法）void cListCreatTail(cLinkList *L, int n)&#123; int i; cLinkList *head, *p; head = L; L-&gt;data = rand() % 100 + 1; for(i = 1; i &lt; n; i++) &#123; p = (cLinkList *)malloc(sizeof(cLinkList)); p-&gt;data = rand() % 100 + 1; L-&gt;next = p; L = p; &#125; L-&gt;next = head;&#125; 这里使用了尾插法对链表进行生成操作，L作为cLinkList的一个指针，在创建过程中不断向后移动，最后指向链表的最后一个结点，这里注意最后要将L指向头结点指针head构建循环。 链表打印函数123456789101112131415void cListPrint(cLinkList *L)&#123; cLinkList *head, *p; head = L; p = L; int count = 1; while(p-&gt;next != head) &#123; printf("%d\t", p-&gt;data); p = p-&gt;next; count++; &#125; printf("%d\n", p-&gt;data); printf("The length of this LinkList is: %d\n", count);&#125; 通过判定p-&gt;next ！= head为条件对链表进行遍历打印，在遍历过程中计算链表的长度并打印输出。 检测是否有环（方法一）123456789101112131415161718192021222324252627282930//检查是否有环（方法一）int cListCheckLoop1(cLinkList *L)&#123; cLinkList *head, *p, *q; head = p = q = L; int countp, countq; countp = 1; while(1) &#123; p=p-&gt;next; countp++; countq = 1; q = head; while(q != p) &#123; q = q-&gt;next; countq++; &#125; if(++countq != countp) &#123; printf("YES!\nThere is a loop in the LinkList!\n"); return 1; &#125; if(p-&gt;next == NULL) &#123; printf("NO!\nThere is no loop in the LinkLis!\n"); return 0; &#125; &#125;&#125; 设置指针变量p对链表进行遍历，同时使用q对p之前的结点进行遍历，如果发现到达p所在结点的更短路径，则判定链表存在环。比如，p走了6步到达结点A，而q只需要3步即可到达结点A，则此时链表中必定存在环，换言之，此前p已经经过结点A了。 检测是否有环（方法二）123456789101112131415161718//检测链表是否有环（方法二）int cListCheckLoop2(cLinkList *L)&#123; cLinkList *p, *q; p = q = L; while(p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;next != NULL) &#123; p = p-&gt;next-&gt;next; q = q-&gt;next; if(p == q) &#123; printf("YES!\nThere is a loop in this LinkList\n"); return 1; &#125; &#125; printf("NO!\nThere is no loop in the LinkList\n"); return 0;&#125; 设置p的步长为2，q的步长为1，同时对链表进行遍历，如果在某个时刻p == q，则就可以断定链表中存在环。 链表清除123456789101112//链表清除函数void cListClear(cLinkList *L)&#123; cLinkList *p, *temp; p = L-&gt;next; while(p != L) &#123; temp = p; p = p-&gt;next; free(temp); &#125;&#125; 使用free()函数对我们生成的链表空间进行遍历删除。 总体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//定义循环链表结构typedef struct node&#123; int data; struct node *next;&#125;cLinkList;//定义循环链表生成函数（头插法）void cListCreatHead(cLinkList *L, int n)&#123; int i; cLinkList *p, *r; p = L; p-&gt;data = rand() % 100 + 1; for(i = 1; i &lt; n; ++i) &#123; r = (cLinkList *)malloc(sizeof(cLinkList)); r-&gt;data = rand() % 100 + 1; r-&gt;next = p; p = r; &#125; L-&gt;next = p;&#125;//定义循环链表生成函数（尾插法）void cListCreatTail(cLinkList *L, int n)&#123; int i; cLinkList *head, *p; head = L; L-&gt;data = rand() % 100 + 1; for(i = 1; i &lt; n; i++) &#123; p = (cLinkList *)malloc(sizeof(cLinkList)); p-&gt;data = rand() % 100 + 1; L-&gt;next = p; L = p; &#125; L-&gt;next = head;&#125;//打印链表void cListPrint(cLinkList *L)&#123; cLinkList *head, *p; head = L; p = L; int count = 1; while(p-&gt;next != head) &#123; printf("%d\t", p-&gt;data); p = p-&gt;next; count++; &#125; printf("%d\n", p-&gt;data); printf("The length of this LinkList is: %d\n", count);&#125;//检查是否有环（方法一）int cListCheckLoop1(cLinkList *L)&#123; cLinkList *head, *p, *q; head = p = q = L; int countp, countq; countp = 1; while(1) &#123; p=p-&gt;next; countp++; countq = 1; q = head; while(q != p) &#123; q = q-&gt;next; countq++; &#125; if(++countq != countp) &#123; printf("YES!\nThere is a loop in the LinkList!\n"); return 1; &#125; if(p-&gt;next == NULL) &#123; printf("NO!\nThere is no loop in the LinkLis!\n"); return 0; &#125; &#125;&#125;//检测链表是否有环（方法二）int cListCheckLoop2(cLinkList *L)&#123; cLinkList *p, *q; p = q = L; while(p-&gt;next != NULL &amp;&amp; p-&gt;next-&gt;next != NULL) &#123; p = p-&gt;next-&gt;next; q = q-&gt;next; if(p == q) &#123; printf("YES!\nThere is a loop in this LinkList\n"); return 1; &#125; &#125; printf("NO!\nThere is no loop in the LinkList\n"); return 0;&#125;//清除链表void cListClear(cLinkList *L)&#123; cLinkList *p, *temp; p = L-&gt;next; while(p != L) &#123; temp = p; p = p-&gt;next; free(temp); &#125;&#125;//主函数int main()&#123; int length = 10; cLinkList *L; L = (cLinkList *)malloc(sizeof(cLinkList)); char operator; printf("1.生成链表（头插法）\n"); printf("2.生成链表（尾插法）\n"); printf("3.打印链表\n"); printf("4.判断链表是否有环（方法一）\n"); printf("5.判断链表是否有环（方法二）\n"); printf("6.清除链表\n"); printf("0.退出\n"); while(1) &#123; scanf("%c", &amp;operator); switch(operator) &#123; case '1': cListCreatHead(L, length); printf("**********生成链表（头）！**********\n"); break; case '2': cListCreatTail(L, length); printf("**********生成链表（尾）！**********\n"); break; case '3': printf("*************打印链表！*************\n"); cListPrint(L); break; case '4': printf("***********是否有环（一）***********\n"); cListCheckLoop1(L); break; case '5': printf("***********是否有环（二）***********\n"); cListCheckLoop2(L); break; case '6': printf("*************清除链表！*************\n"); cListClear(L); break; case '0': printf("***************退出*****************\n"); free(L); return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>循环链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[永远的24号]]></title>
    <url>%2F2016%2F04%2F14%2Fkobe-curry%2F</url>
    <content type="text"><![CDATA[今天必定是一个篮球迷一生铭记的日子，就在今天，传奇的24号终于还是走到了告别的那一刻，虽然我们永远贪婪自私地认为他退得太早太快！还有年轻的金州勇士，一举打破沉寂了二十年的常规赛战绩记录，而库日天也达成了个人单赛季400+三分球的记录！ 总的来看，对于科比，用今天60分+大逆转+准绝杀成全了自己，也成全了世界上所有爱他的人！而库里和队友，真正做到了以摧枯拉朽之势横扫全联盟，他们以他们的年轻、活力、专注和令人艳羡到嫉妒生恨的天赋，已然告诉我们一个新的传奇早已开始！ Kobe科比一直是一个执拗的人，执拗到骨子里，正如他所说的：“总是有人要赢的，那为什么不能是我呢？”。联盟总是会有传奇诞生的，但是科比只有这一个！ Curry本赛季的库里，只能用疯狂和神奇来形容了，24号虽然退役了，但是还有库里和勇士的无限可能，对于一个球迷来说，总是幸福的！ Spurs最后还是忍不住聊一聊我刺，看了这么多年球，总有那么几个名字会让你潸然泪下，湖人的传奇24号，小牛的德国战车，还有圣城的永远年轻的21号新秀！如今GDP真的年事已高，而我们也一点点洒完了青春，在时光的日子里，总有那么一直球队，总有那么三个人！未来是属于你们的！ 彩蛋呆呆萌照！ 佛与魔！]]></content>
      <categories>
        <category>NBA</category>
      </categories>
      <tags>
        <tag>NBA</tag>
        <tag>Kobe Bryant</tag>
        <tag>Stephen Curry</tag>
        <tag>Tim Duncan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表功能函数总结]]></title>
    <url>%2F2016%2F04%2F14%2FLinkListApp%2F</url>
    <content type="text"><![CDATA[最近在学习数据结构的内容，链表（LinkList）就是数据结构中最基本的一种数据类型，链表本身的构造特性也特别有意思，这里就构造了一个链表的功能函数，包含了链表的创建初始化、打印输出、计算长度、查找中间结点和清除链表等功能，在今后的学习中会不断扩充添加不同的功能！函数运行如下图所示： 功能函数链表创建函数12345678910111213141516//声明链表创建函数（尾插法）void ListCreat(LinkList *L, int n)&#123; LinkList *p, *r; int i; srand(time(0)); p = L; for(i = 0; i &lt; n; i++) &#123; r = (LinkList *)malloc(sizeof(LinkList)); p-&gt;data = rand() % 100 + 1; p-&gt;next = r; p = r; &#125; p-&gt;next = NULL;&#125; 这里使用了尾插法对链表进行生成操作，使用rand()函数生成随机数对链表进行初始化。 链表打印函数123456789101112//打印链表函数ListPrint(LinkList *L)&#123; LinkList *p; p = L; while(p-&gt;next != NULL) &#123; printf("%d\t", p-&gt;data); p = p-&gt;next; &#125; printf("\n");&#125; 通过判定p-&gt;next是否为NULL为条件对链表进行遍历打印。 获取链表长度12345678910111213//声明一个函数，获取链表长度int ListLength(LinkList *L)&#123; LinkList *p; p = L; int count = 0; while(p-&gt;next != NULL) &#123; p = p-&gt;next; count++; &#125; return count;&#125; 同上，通过判定p-&gt;next是否为NULL为条件对链表进行遍历计算链表的长度。 获取中间结点12345678910111213141516171819//声明一个函数，获取链表中间结点int ListMid(LinkList *L)&#123; LinkList *cur, *mid; cur = mid = L; while(cur-&gt;next != NULL) &#123; if(cur-&gt;next-&gt;next != NULL) &#123; mid = mid-&gt;next; cur = cur-&gt;next-&gt;next; &#125; else &#123; cur = cur-&gt;next; &#125; &#125; return mid-&gt;data;&#125; 设置cur的步长为2，mid的步长为1，同时对链表进行遍历，以cur == NULL为结束条件，可以以较高的效率得到链表的中间结点。 链表清除12345678910111213//声明链表清理函数void ListClear(LinkList *L)&#123; LinkList *p; p = L; while(L-&gt;next != NULL) &#123; L = p-&gt;next; free(p); p = L; &#125; free(L);&#125; 使用free()函数对我们生成的链表空间进行遍历删除。 总体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//声明链表结构体typedef struct node&#123; int data; struct node *next;&#125;LinkList;//声明链表创建函数（尾插法）void ListCreat(LinkList *L, int n)&#123; LinkList *p, *r; int i; srand(time(0)); p = L; for(i = 0; i &lt; n; i++) &#123; r = (LinkList *)malloc(sizeof(LinkList)); p-&gt;data = rand() % 100 + 1; p-&gt;next = r; p = r; &#125; p-&gt;next = NULL;&#125;//打印链表函数ListPrint(LinkList *L)&#123; LinkList *p; p = L; while(p-&gt;next != NULL) &#123; printf("%d\t", p-&gt;data); p = p-&gt;next; &#125; printf("\n");&#125;//声明一个函数，获取链表长度int ListLength(LinkList *L)&#123; LinkList *p; p = L; int count = 0; while(p-&gt;next != NULL) &#123; p = p-&gt;next; count++; &#125; return count;&#125;//声明一个函数，获取链表中间结点int ListMid(LinkList *L)&#123; LinkList *cur, *mid; cur = mid = L; while(cur-&gt;next != NULL) &#123; if(cur-&gt;next-&gt;next != NULL) &#123; mid = mid-&gt;next; cur = cur-&gt;next-&gt;next; &#125; else &#123; cur = cur-&gt;next; &#125; &#125; return mid-&gt;data;&#125;//声明链表清理函数void ListClear(LinkList *L)&#123; LinkList *p; p = L; while(L-&gt;next != NULL) &#123; L = p-&gt;next; free(p); p = L; &#125; free(L);&#125;//主函数int main()&#123; printf("1.生成链表\n"); printf("2.打印链表\n"); printf("3.获取链表长度\n"); printf("4.获取中间结点\n"); printf("5.清楚链表\n"); printf("0.退出\n"); LinkList *L; L = (LinkList *)malloc(sizeof(LinkList)); int length = 10; char operator; while(1) &#123; scanf("%c", &amp;operator); switch(operator) &#123; case '1': printf("**********生成链表***********\n"); ListCreat(L, length); break; case '2': printf("**********打印链表**********\n"); ListPrint(L); break; case '3': printf("********获取链表长度********\n"); printf("The length of this ListCreat is: %d\n", ListLength(L)); break; case '4': printf("********获取中间结点********\n"); printf("The value of the middle node is: %d\n", ListMid(L)); break; case '5': ListClear(L); printf("**********清楚完毕**********\n"); break; case '0': printf("************退出************\n"); return 0; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LinkList</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数之筛法]]></title>
    <url>%2F2016%2F04%2F12%2Fsieve%2F</url>
    <content type="text"><![CDATA[本文主要介绍总结一下判定素数过程中使用的两种筛选方法——Eratosthenes筛法(Sieve of Eratosthenes)和Eular筛法(Sieve of Euler)。 Eratosthenes筛法基本思想： 素数的倍数一定不是素数 实现方法 使用长度为N的数组保存数字素数信息（0表示是素数，1 表示非素数） 首先将数组初始化为0，即认为所有的数都是素数 从第一个素数2开始，把所有2的倍数都记为素数（即将数组对应值置为1），一直到超出N的范围； 然后进行3的遍历，执行相同的操作； 执行到4的时候，由于之前已经将其值置为1，即判定为非素数，则执行++对下一个素数5进行操作； 依次进行上述操作，直到最后可以获得所有的素数。 举例操作（N=20） i 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 1 1 1 1 1 1 1 1 1 3 1 1 1 1 1 5 1 1 1 7 1 ALL 0 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 0： 素数1：非素数 代码实现123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int num; cin &gt;&gt; num; int flag[1000] = &#123;0&#125;; int prime[1000]; int count = 0; for(int i = 2; i &lt; num; ++i) &#123; if(!flag[i]) prime[count++] = i; for(int j = i + i; j &lt;= num; j += i) flag[j] = 1; &#125; cout &lt;&lt; "The number is: " &lt;&lt; count &lt;&lt; endl;&#125; 此算法的时间复杂度是O(nloglogn)，空间复杂度是O(n)；由上也可以看出，此算法有很多不足之处，比如6，在素数为2时处理过一次，在为3的时候也处理了一次，重复了相同的操作。下面我们将介绍一个改进算法，欧拉筛法。 Euler筛法核心思路 规定每个合数只用最小的一个质因数去筛选，比如6有2和3两个因数，只用2进行筛选和置位操作，3的情况通过条件跳过。 举例操作（N=20） i j p[j] count 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2 1 1 3 0 2 2 1 3 1 3 2 1 4 0 2 2 1 5 0 2 3 1 5 1 3 3 1 6 0 2 3 1 7 0 2 4 1 8 0 2 4 1 9 0 2 4 1 10 0 2 4 1 ALL 0 0 1 0 1 0 1 1 1 0 1 0 1 1 1 0 1 0 1 0： 素数1：非素数 代码下面直接上代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;#define Length 1000000int main()&#123; int num; cin &gt;&gt; num; int flag[Length] = &#123;0&#125;; int prime[1000]; int count = 0; for(int i = 2; i &lt;= num; ++i) &#123; if(!flag[i]) &#123; prime[++count] = i; &#125; for(int j = 1; j &lt;= count; ++j) &#123; if(i * prime[j] &gt; num) break; flag[i * prime[j]] = 1; if(i % prime[j] == 0) break; &#125; &#125; cout &lt;&lt; count &lt;&lt; endl;&#125; 代码分析 核心代码 if(i % prime[j] == 0) break； 保证了每个合数都被置位 每个合数只会筛选到一次，在取其最小质因子的情况下 Eular算法的时间复杂度为O(n)，相较之Eratosthenes算法有了很大的提升。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>素数</tag>
        <tag>Sieve of Eular</tag>
        <tag>Sieve of Eratosthenes</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Miller-Rabin质数测试]]></title>
    <url>%2F2016%2F04%2F11%2FMiller-Rabin%2F</url>
    <content type="text"><![CDATA[本文主要讨论使用Miller-Rabin算法编写素数的判定算法，题目来源于hihocoder。 题目题目要求时间限制:10000ms单点时限:1000ms内存限制:256MB描述使用Miller-Rabin算法进行质数素数测试，要求输入一个数字，对其是否是素数进行判定，并打印出相对应的结果。 提示：Miller-Rabin质数测试 输入第1行：1个正整数t，表示数字的个数，10≤t≤50第2..t+1行：每行1个正整数，第i+1行表示正整数a[i]，2≤a[i]≤10^18输出第1..t行：每行1个字符串，若a[i]为质数，第i行输出”Yes”，否则输出”No”样例输入12343 379 样例输出123YesYesNo 题目分析Miller-Rabin算法是一种基于费马小定理的扩展算法，首先我们需要知道什么是费马小定理，然后还要知道整个Miller-Rabin算法是如何扩展出来的。 费马小定理 费马小定理：对于质数p和任意整数a，有a^p ≡ a(mod p)(同余)。反之，若满足a^p ≡ a(mod p)，p也有很大概率为质数。将两边同时约去一个a，则有a^(p-1) ≡ 1(mod p) 也即是说：假设我们要测试n是否为质数。我们可以随机选取一个数a，然后计算a^(n-1) mod n，如果结果不为1，我们可以100%断定n不是质数。否则我们再随机选取一个新的数a进行测试。如此反复多次，如果每次结果都是1，我们就假定n是质数。该测试被称为Fermat测试。需要注意的是：Fermat测试不一定是准确的，有可能出现把合数误判为质数的情况。Miller和Rabin在Fermat测试上，建立了Miller-Rabin质数测试算法。 二次探测定理 如果p是奇素数，则 x^2 ≡ 1(mod p)的解为 x ≡ 1 或 x ≡ p - 1(mod p)如果a^(n-1) ≡ 1 (mod n)成立，Miller-Rabin算法不是立即找另一个a进行测试，而是看n-1是不是偶数。如果n-1是偶数，另u=(n-1)/2，并检查是否满足二次探测定理即a^u ≡ 1或 a^u ≡ n - 1(mod n)。 举个Matrix67 Blog上的例子，假设n=341，我们选取的a=2。则第一次测试时，2^340 mod 341=1。由于340是偶数，因此我们检查2^170，得到2^170 mod 341=1，满足二次探测定理。同时由于170还是偶数，因此我们进一步检查2^85 mod 341=32。此时不满足二次探测定理，因此可以判定341不为质数。 将这两条定理合起来，也就是最常见的Miller-Rabin测试。 加强版测试验证定理 尽可能提取因子2，把n-1表示成d*2^r,如果n是一个素数，那么或者a^d mod n==1，或者存在某个i使得a^(d*2^i) mod n=n-1 (0&lt;=i&lt;r)则我们认为n为素数。（注意i可以等于0，这就把a^d mod n=n-1的情况统一到后面去了） 这里需要注意的是，我们将该定理作为判定条件，仍然是一个不确定的概率判定条件。Miller-Rabin素性测试同样是不确定算法，我们把可以通过以a为底的Miller-Rabin测试的合数称作以a为底的强伪素数(strong pseudoprime)。第一个以2为底的强伪素数为2047。第一个以2和3为底的强伪素数则大到1 373 653。 所以我们在实际使用过程中，使用rand()函数生成随机数，或者进行多次检测判定，还是能够得到比较高的判定成功率，Miller-Rabin算法对于素数的研究判定有着巨大的辅助作用。 代码整体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;typedef long long llong;//求取(x * y) % nllong mod(llong x, llong y,llong n)&#123; llong res = 0; llong temp = x % n; while(y) &#123; if(y &amp; 0x1) if((res += temp) &gt; n) res -= n; if((temp &lt;&lt;= 1) &gt; n) temp -= n; y &gt;&gt;= 1; &#125; return res;&#125;//求取(x ^ y) % nllong get_mod(llong x, llong y, llong n)&#123; llong res = 1; llong temp = x; while(y) &#123; if(y &amp; 0x1) res = mod(res, temp, n); temp = mod(temp, temp, n); y &gt;&gt;= 1; &#125; return res;&#125;//编写bool函数，判定是否为素数bool is_prime(llong n, int t)&#123; if(n &lt; 2) return false; if(n == 2) return true; if(!(n &amp; 0x1)) return false; llong k = 0, m, a, i; for(m = n -1; !(m &amp; 0x1); m &gt;&gt;= 1, ++k); while(t--) &#123; a = get_mod(rand() % (n - 2) + 2, m, n); if(a != 1) &#123; for(i = 0; i &lt; k &amp;&amp; a != n-1; ++i) &#123; cout &lt;&lt; a &lt;&lt; endl; a = mod(a, a, n); &#125; //根据二次探测定理，只要不满足(a == 1) || (a == n - 1)，就会一直遍历下去，直到最后返回false if(i &gt;= k) return false; &#125; &#125; return true;&#125;//主函数int main()&#123; int times; llong num; cin &gt;&gt; times; while(times--) &#123; cin &gt;&gt; num; if(is_prime(num, 1)) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; return 0;&#125; 代码分解mod()函数12345678910111213141516//求取(x * y) % nllong mod(llong x, llong y,llong n)&#123; llong res = 0; llong temp = x % n; while(y) &#123; if(y &amp; 0x1) if((res += temp) &gt; n) res -= n; if((temp &lt;&lt;= 1) &gt; n) temp -= n; y &gt;&gt;= 1; &#125; return res;&#125; 这个函数使用移位运算，通过将y转换成二进制形式，十分高效地求取了两个数字乘积的余数。 get_mod()函数1234567891011121314//求取(x ^ y) % nllong get_mod(llong x, llong y, llong n)&#123; llong res = 1; llong temp = x; while(y) &#123; if(y &amp; 0x1) res = mod(res, temp, n); temp = mod(temp, temp, n); y &gt;&gt;= 1; &#125; return res;&#125; 这个函数是经典的高次幂函数求余算法，即蒙哥马利算法，在上一篇博文中也有过介绍，博文链接。其核心思想就是将幂指数转换成二进制，通过移位运算快速地求取余数，避免了数据溢出，而且效率非常高。 is_prime()函数12345678910111213141516171819202122232425262728//编写bool函数，判定是否为素数bool is_prime(llong n, int t)&#123; if(n &lt; 2) return false; if(n == 2) return true; if(!(n &amp; 0x1)) return false; llong k = 0, m, a, i; for(m = n -1; !(m &amp; 0x1); m &gt;&gt;= 1, ++k); while(t--) &#123; a = get_mod(rand() % (n - 2) + 2, m, n); if(a != 1) &#123; for(i = 0; i &lt; k &amp;&amp; a != n-1; ++i) &#123; cout &lt;&lt; a &lt;&lt; endl; a = mod(a, a, n); &#125; //根据二次探测定理，只要不满足(a == 1) || (a == n - 1)，就会一直遍历下去，直到最后返回false if(i &gt;= k) return false; &#125; &#125; return true;&#125; 即数字是否是素数的判定函数，依照我们在上文提出的加强定理，包含如下要点： 对所需判定的奇数n进行n-1提取因子2，把n-1表示成d*2^r的形式； 取随机数a=rand()，如果a^d mod n == 1则判定为素数； 如果a^d mod n ！= 1，则通过循环查找是否有i满足a^(d*2^i) mod n = n-1，若有，则判定为素数； 如果上述条件都不成立，则遍历结果得到i == k，此时返回false Tips：这里需要注意的是，Miller-Rabin算法是一个不确定算法，仍有一定的错误概率，正如上文所述的，第一个以2为底的强伪素数为2047。第一个以2和3为底的强伪素数则大到1 373 653。在一定的使用范围内仍然可以得到高效、准确的结果！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Miller-Rabin</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高次幂函数取模算法]]></title>
    <url>%2F2016%2F04%2F04%2Fget-mod%2F</url>
    <content type="text"><![CDATA[在平常的工作学习中，我们经常需要用到求取一个数字或者幂运算的余数，尤其在密码学中最为常用的RSA算法就经常要用到这种运算，我们称之为高次幂函数的取模运算。 在本篇文章中，将会首先介绍运用程序求解高次幂函数取模的暴力求解方法，然后针对暴力方法算法效率低下的缺点，给出一种快速的取模算法。 暴力取模算法由于我们的高次幂函数往往拥有很高的幂，而我们在计算机中只有int、float、double、long long这几种变量类型，远远不能满足我们对于大数字运算的要求，从而导致数据溢出无法完成运算。所以这里我们需要在每次迭代取模的过程中进行取模运算，从而保证数据不会溢出。代码如下： 123456789int get_mod(int a, int b, int c)&#123; long long result = 1;//声明为long long类型防止溢出 while(b--) &#123; result = result * a % c;//这个算法的核心就是在迭代运算过程中进行取模运算 &#125; return static_cast&lt;int&gt; (result);&#125; 这种算法的正确性毋庸置疑，但是如果幂指数太大的话，需要耗费的时间就更非常多，直接导致运算效率低下，所以只适用于指数不大的情况下使用，下面我们要讲解的蒙哥马利算法就很好地解决了这个问题，而且该算法非常简单，效率极高，完全可以手动演算。 蒙哥马利算法蒙哥马利算法是一种快速的大数（通常达到几百个二进制）的模乘算法，由彼得·蒙哥马利在1985年提出。下面直接放代码：123456789101112131415int get_mod(int a, int b, int c)&#123; long long res = 1;//声明为long long类型防止数据溢出 int temp = a; while(b &gt; 0) &#123; if( b &amp; 1)//取幂指数二进制最后一位 &#123; res = (res * temp) % c; &#125; temp = (temp * temp) % c; b &gt;&gt;= 1;//幂指数二进制向右移动一位 &#125; return static_cast&lt;int&gt; (res);//以int类型返回最终结果&#125; 使用这个算法，即便是处理很大的数据都可以快速的求得余数，非常好用，这里想说，学好数学才是真的生产力！]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>取余</tag>
        <tag>幂指数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 14.04下安装ns2.35]]></title>
    <url>%2F2016%2F03%2F30%2FUbuntu-14-04%E4%B8%8B%E5%AE%89%E8%A3%85ns2-35%2F</url>
    <content type="text"><![CDATA[本文主要介绍在Ubuntu 14.04系统下，ns2.35的安装过程，本次选择的版本是2.35最新版本，安装环境是Ubuntu 14.04，其他系统环境和ns的版本安装过程相似，均可参考本文流程。 PS：出现Bug，Error一定用用Google解决，Google大法好！ 下载ns2的安装包这里我选择的是ns-allinone-2.35.tar.gz压缩格式的all-in-one安装包，all-in-one 安装包包含所有的组件，比较方便，另附下载地址：Link： http://www.isi.edu/nsnam/ns/ns-build.html 安装前环境配置输入如下代码：123$sudo apt-get install build－essential$sudo apt-get install tcl8.4 tcl8.4-dev tk8.4 tk8.4-dev$sduo apt-get install libxmu-dev libxmu-headers ns2的解压和安装首先把ns-allinone-2.35.tar.gz复制到home/xxx的文件夹下。xxx代表是你自己设置的ns2文件夹。然后进入终端，依次输入123tar -xzvf ns-allinone-2.31.tar.gzcd ns-allinone-2.31./install 不出意外的话，这一部分肯定是要出现各种各样的问题的，比如我出现的问题是：1234linkstate/ls.h:137:58: note: declarations in dependent base ‘std::map&lt;int, LsIdSeq, std::less&lt;int&gt;, std::allocator&lt;std::pair&lt;const int, LsIdSeq&gt;&gt;&gt;’ are not found by unqualified lookuplinkstate/ls.h:137:58: note: use ‘this-&gt;erase’ insteadmake: *** [linkstate/ls.o] Error 1Ns make failed! 这个很简单，只要编辑ns-2.35/linkstate/ls.h，即1gedit ns-2.35/linkstate/ls.h 将第137行的代码由1void eraseAll() &#123; erase(baseMap::begin(), baseMap::end()); &#125; 改为1void eraseAll() &#123; this-&gt;erase(baseMap::begin(), baseMap::end()); &#125; 也就是把erase用this-&gt;erase替换掉就好了。 再次执行./install就可以安装成功了。 Tips： 由于每个人的机器环境条件不一样，出现的错误也不一样，所以有可能遇见各种各样的问题。这里建议大家讲bug代码粘贴到google中去搜索，一般都可以解决的。重要的事情说三遍：一定要用google！一定要用google！一定要用google！ 配置环境变量如果安装成功，终端会提示配置环境变量，包括PATH，LD_LIBRARY_PATH，TCL_LIBRARY三种环境变量。 重新打开一个终端，输入：1sudo gedit .bashrc 在文件最后添加如下代码： 1234export PATH=$PATH:/home/xxx/ns-allinone-2.31/bin:/home/xxx/ns-allinone-2.31/tcl8.4.14/unix:/home/xxx/ns-allinone-2.31/tk8.4.14/unixexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/xxx/ns-allinone-2.31/otcl-1.13:/home/xxx/ns-allinone-2.31/libexport TCL_LIBRARY=$TCL_LIBRARY:/home/xxx/ns-allinone-2.31/tcl8.4.14/library//注意两个环境变量路径之间要用冒号：隔开 然后运行：1source .bashrc 就完成了环境变量的配置。 安装完成的验证重新打开一个终端，输入：1ns 如果出现%就证明ns2已经安装成功了。 如果没有出现%，可以重新在终端输入：12source .bashrcns 这时候应该就完美的出现了%，证明ns2应经安装好了。 实例example在终端输入：12cd ns-allinone-2.31/ns-2.31/tcl/exns example.tcl 如果出现了数据，证明ns2运行正常。 再输入1ns simple.tcl 如果出现nam的控制窗口和帮助屏，则表示nam安装成功。可以在nam控制窗口进行动画演示。自此，ns2.35完全安装成功。]]></content>
      <categories>
        <category>NS2</category>
      </categories>
      <tags>
        <tag>ns2</tag>
        <tag>Ubuntu 14.04</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原始套接字(2)]]></title>
    <url>%2F2016%2F03%2F29%2Fsocket-2%2F</url>
    <content type="text"><![CDATA[在原始套接字学习的过程中，也遇到了一系列的问题，其中不乏自己粗心大意，也有各种没有注意的错误，这里着重写出，并保持持续的更新。 fgets()函数问题 在使用套接字搭建聊天程序的时候，我在这里使用了一个fgets()函数来保存键盘的输入，具体代码如下： 123456char Buffer[100];while(fgets(sendbuf,sizeof(sendbuf),stdin)!=0)&#123; sendto(sock,&amp;Buffer,sizeof(Buffer),0,(struct sockaddr *)addr,sizeof(addr)); bzero(Buffer,sizeof(Buffer)); &#125; 这里需要注意的问题是，由于fgets()函数是以回车键的输入来判定结束的，与此同时，回车键\n也会作为最后一个字符输入到Buffer中，所以这里在处理一些数据的时候需要注意。 socket()建立问题 在socket()构建的过程中，往往跟随一个判定建立成功与否的perror()语句，这里建议的写法是：123456int sockfd;sockfd=socket(AF_INET,SOCK_DGRAM,0);if(sockfd&lt;0)&#123; perror("socket created error"); &#125; 不推荐的写法是：12345int sockfd;if(sockfd=socket(AF_INET,SOCK_DGRAM,0)&lt;0)&#123; perror("socket created error"); &#125; 这种写法很有可能会导致你的socket建立失败，而且程序还不会报错，所以小心一点这里尽量多写一句吧，养成良好的代码习惯。 strlen()函数和sizeof()函数 strlen()：strlen()所作的仅仅是一个计数器的工作，它从内存的某个位置(可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域)开始扫描，直到碰到第一个字符串结束符\0为止，然后返回计数器值(长度不包含\0)。 sizeof()：sizeof()是C/C++中的一个操作符operator，简单的说其作用就是返回一个对象或者类型所占的内存字节数。 这两个函数在使用过程中要注意，strlen()主要是计数功能，遇到\0后就停止计数返回数字，而sizeof()则返回该对象所占的内存字节数。 下面给出一个小测试程序供参考： 123456789#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char s[22]="i love you!\0"; printf("%s\n",s); printf("%d\n",strlen(s)); return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>Socket</tag>
        <tag>原始套接字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原始套接字(1)]]></title>
    <url>%2F2016%2F03%2F29%2Fsocket%2F</url>
    <content type="text"><![CDATA[一般来说，我们会用到如下三种套接字： TCP：SOCK_STREAM套接字 UDP：SOCK_DGRAM套接字 原始套接字：SOCK_RAW套接字 对于TCP和UDP两种套接字，相对来说只要配置好IP地址和端口号就可以了，比较简单，这里我们主要介绍原始套接字的使用。 原始套接字简介 原始套接字的强大之处在于，不同与UDP和TCP套接字只能访问传输层和传输层以上的数据包，原始套接字可以访问传输层以下的数据包，实现上至应用层下至链路层的数据操作，尤其适合用来进行抓包等工作。 —— 原始套接字的建立 常用的原始套接字的建立方式有如下两种： 12int sockfd=socket(PF_PACKET,SOCK_PACKET,htons(ETH_P_ALL))；//这个socket可以访问处理链路层及以上所有的数据包int sockfd=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_IP))；//这个socket可以访问处理链路层及以上所有的IP数据包 原始套接字权限 原始套接字需要root权限即管理员权限才能够创建，所以需要sudo和su进入root模式，而且在使用原始套接字进行抓包的过程中需要设置网卡为混杂模式。 下面给出两个例子，供大家参考 原始套接字进行发包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdarg.h&gt;#include &lt;time.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/errno.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;net/if.h&gt;#include &lt;net/ethernet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netinet/ip.h&gt;#include &lt;netinet/if_ether.h&gt;#include &lt;netpacket/packet.h&gt;#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;time.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;dirent.h&gt;#include &lt;resolv.h&gt;#include &lt;signal.h&gt;#include &lt;getopt.h&gt;#ifdef HAVE_CONFIG_H#include &lt;config.h&gt;#endif//首先定义网卡端口#define PHYSICALPORT "eth0"#define PHYSICALPORT_LEN 30//创建实际网卡端口数组char physical_port[30];//定义缓存大小#define BUFSIZE 1024*5char sendbuf[BUFSIZE]=&#123;0&#125;;int main()&#123; memcpy(physical_port,PHYSICALPORT,PHYSICALPORT_LEN); int sock_send; sock_send=socket(PF_PACKET,SOCK_PACKET,htons(ETH_P_ALL)); if(sock_send&lt;0) &#123; perror("scoket created"); &#125; //设置发包地址 struct sockaddr send_addr; memset(&amp;send_addr,0,sizeof(send_addr)); strcpy(send_addr.sa_data,physical_port); //创建发送程序 while(fgets(sendbuf,sizeof(sendbuf),stdin)!=0) &#123; int len=sendto(sock_send,&amp;sendbuf,strlen(sendbuf),0,&amp;send_addr,sizeof(send_addr)); memset(sendbuf,0,sizeof(sendbuf)); &#125; return 0;&#125; 使用wireshark进行抓包，得到如下结果： 原始套接字收包解析代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdarg.h&gt;#include &lt;time.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/errno.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;sys/stat.h&gt;#include &lt;net/if.h&gt;#include &lt;net/ethernet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netinet/ip.h&gt;#include &lt;netinet/if_ether.h&gt;#include &lt;netpacket/packet.h&gt;#include &lt;netdb.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;time.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;dirent.h&gt;#include &lt;resolv.h&gt;#include &lt;signal.h&gt;#include &lt;getopt.h&gt;#ifdef HAVE_CONFIG_H#include &lt;config.h&gt;#endif//首先定义网卡端口#define PHYSICALPORT "eth0"#define PHYSICALPORT_LEN 30//创建实际网卡端口数组char physical_port[30];//定义缓存大小#define BUFSIZE 1024*5char recvbuf[BUFSIZE]=&#123;0&#125;; void ethernet_setpormisc(int fd,int i_flags);int main()&#123; memcpy(physical_port,PHYSICALPORT,PHYSICALPORT_LEN); //首先创建一个原始套接字 int sock_recv; sock_recv=socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL)); if(sock_recv&lt;0) &#123; perror("physicl socket created"); &#125; //设置网卡为混杂模式； ethernet_setpormisc(sock_recv,1); //setsockopt int recvbuf_size=BUFSIZE; setsockopt(sock_recv,SOL_SOCKET,SO_RCVBUF,&amp;recvbuf,sizeof(char)); //获取物理网卡接口索，用以传输数据 struct ifreq ifr_recv; strcpy(ifr_recv.ifr_name,physical_port); if(ioctl(sock_recv,SIOCGIFINDEX,&amp;ifr_recv)&lt;0) &#123; perror("[3]get interface index"); &#125; //绑定物理网卡 struct sockaddr_ll local_addr; local_addr.sll_family=PF_PACKET; local_addr.sll_ifindex=ifr_recv.ifr_ifindex; local_addr.sll_protocol=htons(ETH_P_ALL); if((bind(sock_recv,(struct sockaddr *)&amp;local_addr,sizeof(local_addr)))&lt;0) &#123; perror("[4]bind physical address"); &#125; //开始接收数据包 while(1) &#123; recvfrom(sock_recv,recvbuf,BUFSIZE,0,NULL,NULL); printf("%s",recvbuf); memset(recvbuf,0,sizeof(recvbuf)); &#125; close(sock_recv);&#125;//创建设置网卡混杂模式函数void ethernet_setpormisc(int fd,int i_flags)&#123; //首先获取网卡接口标志位 struct ifreq ifr_s; memcpy(ifr_s.ifr_name,physical_port,sizeof(physical_port)); if(ioctl(fd,SIOCGIFFLAGS,&amp;ifr_s)&lt;0) &#123; perror("[1]get interface flags"); &#125; if(i_flags==0) &#123; //取消混杂模式 ifr_s.ifr_flags &amp;= ~IFF_PROMISC; &#125; else &#123; //设置为混杂模式 ifr_s.ifr_flags |= IFF_PROMISC; &#125; //将接口设置为相应的模式 if(ioctl(fd,SIOCSIFFLAGS,&amp;ifr_s)&lt;0) &#123; perror("[2]set interface flags"); &#125;&#125; 在终端显示抓包结果如下： 得到的结果是各种乱码，需要继续进行解析调试。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>Socket</tag>
        <tag>原始套接字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写在最开始!]]></title>
    <url>%2F2016%2F03%2F28%2FMy-first-bolg%2F</url>
    <content type="text"><![CDATA[写在最开始！今天学会了使用Hexo+Github进行个人博客网站的搭建，发现hexo真的非常好用！ 使用Hexo进行博客的搭建和博文推送管理，实在是太方便了，只要使用hexo generate和hexo deploy就可以直接推送到我们链接的github账户！基本上配置完成之后一劳永逸，各种目录，标签，分类都可以自动生成! 在这里着重感谢Hexo作者和next博客模板的作者，感谢他们的工作给予我们的极大便利。还要感谢EZLippi和夏末两位博主，我在搭建自己博客的时候主要参考了这两位的博文，在这里表示感谢！ Hexo的安装配置这部分内容请参考Hexo官方网站给出的教程 Hexo的使用Hexo的使用请参考EZLippi的博文 第三方服务集成Hexo拥有强大的第三方服务集成功能，可以满足各种评论、数据分析、分享的功能实现。具体见如下链接 阅读量统计功能为Next模板主题添加文章阅读量统计功能请参考夏末的博文 Next的官方网站最后奉上Next的官方网站]]></content>
      <categories>
        <category>闲文</category>
      </categories>
      <tags>
        <tag>闲扯</tag>
      </tags>
  </entry>
</search>